<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[内网穿透 UDP 打洞]]></title>
    <url>%2Fblog%2F2021%2F01%2F26%2Fcsharp-UDPHole%2F</url>
    <content type="text"><![CDATA[Nat 穿透（UDP 打洞） 简介最开始源于一次去用户现场出差，TeamViewer 与 向日葵 都是开通了会员的，但还是受到各种稀奇古怪的问题阻挠无法远程到家里的电脑和公司的电脑，回来后尝试做一个内网穿透工具以 Remote Desktop Connection(RDP) 方式连接作为以后远程的备选方案。但是后期测试时发现 Remote Desktop Connection(RDP) 协议首先通过 TCP 进行第一次通讯建立连接以及输入用户名密码，验证用户凭据后重新以 TCP 进行远程通讯，UDP 仅作为辅助，所以改为 TCP 转发方式继续开发，UDP 打洞成功，或许以后或许可以在此基础上做些其他功能。 代码仓库不确定当前仓库权限是否公有12git clone https://github.com/iceelves/PenetrateRemote.gitgit reset fd217598 网络类型检测网络 Nat 类型使用开源项目 NatTypeTester 可检测本 地网络 Nat 类型。 Nat 类型 全锥型(Full Cone) 如果在 NAT 网关已经建立了一个 NAT 映射，那么任何外网的机器都可以通过这个映射来访问内网的电脑。 受限锥型(Restricted Cone)(IP受限锥型) 如果在 NAT 网关已经建立了一个 NAT 映射，那么只有与其建立映射的 IP 才能通过 NAT 访问内网的电脑。 端口受限锥型(Port Restricted Cone)(IP + PORT受限锥型) 在 IP 限制型锥型的基础上，再进行端口的限制。 对称型(Symmetric) 即对 IP 和端口都有限制，只有和其建立连接的 IP 和端口向其发送数据才不会被丢弃。 不同 Nat 类型穿透性盗的图，出处见水印 运行流程如图所示：局域网 NatA 中的机器 192.168.5.13(以下简称 ClientA) 请求与局域网 NatB 中的机器 192.168.1.100(以下简称 ClientB) 通过 UDP 打洞通信。 局域网内两台电脑运行 Client 程序，向服务器建立 Socket UDP 连接。 ClientA 向服务端发出请求与 ClientB 建立连接。 服务端验证两台电脑在线后将 ClientB Socket UDP 信息发送给 ClientA。 ClientA 发送登录信息到 ClientB，此时 ClientB 接收不到消息。 ClientA 向服务端发送反向打洞请求，让 ClientB 向自己发送数据。 服务端将 ClientA 信息发送到 ClientB。 ClientB 向 ClientA 发送登录信息后，双方建立打洞通信，关闭服务端程序后依然可以通信。 核心代码Server123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181public class Udp_Server : IDisposable&#123; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; public Udp_Server(int ListeningPort) &#123; _listeningPort = ListeningPort; _remotePoint = new IPEndPoint(IPAddress.Any, 0); _serverThread = new Thread(Run); &#125; /// &lt;summary&gt; /// 析构函数 /// &lt;/summary&gt; ~Udp_Server() &#123; Dispose(); &#125; /// &lt;summary&gt; /// 监听端口号 /// &lt;/summary&gt; private int _listeningPort; /// &lt;summary&gt; /// 服务器端消息监听 /// &lt;/summary&gt; private UdpClient _server; /// &lt;summary&gt; /// 计时器 /// &lt;/summary&gt; private readonly Thread _serverThread; /// &lt;summary&gt; /// 远程用户请求的IP地址及端口 /// &lt;/summary&gt; private IPEndPoint _remotePoint; private static ConcurrentDictionary&lt;string, HoleUserInfo&gt; _loginUser; /// &lt;summary&gt; /// 登陆打洞用户 /// &lt;/summary&gt; public static ConcurrentDictionary&lt;string, HoleUserInfo&gt; LoginUser &#123; get &#123; if (_loginUser == null) &#123; _loginUser = new ConcurrentDictionary&lt;string, HoleUserInfo&gt;(); &#125; return _loginUser; &#125; set =&gt; _loginUser = value; &#125; /// &lt;summary&gt; /// 启动 UDP 监听 /// &lt;/summary&gt; public void Start() &#123; try &#123; // 删除超时数据 System.Timers.Timer overtime = new System.Timers.Timer(); overtime.Interval = 60000 * 5; overtime.Elapsed += new System.Timers.ElapsedEventHandler(timer_Overtime); overtime.Start(); // 启动服务 _server = new UdpClient(_listeningPort); _serverThread.Start(); NLogHelper.SaveInfo($"服务启动，监听端口：&#123;_listeningPort&#125;"); &#125; catch (Exception ex) &#123; NLogHelper.SaveError(ex.ToString()); &#125; &#125; /// &lt;summary&gt; /// 移除超时数据线程 /// &lt;/summary&gt; /// &lt;param name="sender"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; private void timer_Overtime(object sender, System.Timers.ElapsedEventArgs e) &#123; List&lt;string&gt; removeKeys = LoginUser.Where(o =&gt; DateTime.Now - o.Value.LastLoginTime &gt;= new TimeSpan(0, 5, 0)).Select(o =&gt; o.Key).ToList(); if (removeKeys != null &amp;&amp; removeKeys.Count &gt;= 1) &#123; foreach (var item in removeKeys) &#123; LoginUser.TryRemove(item, out _); &#125; &#125; &#125; /// &lt;summary&gt; /// 线程主方法 /// &lt;/summary&gt; private void Run() &#123; byte[] msgBuffer; while (true) &#123; try &#123; // 接受消息 msgBuffer = _server.Receive(ref _remotePoint); // 将消息转换为对象 var msgObject = ObjectSerializerHelper.JsonDeserialize(msgBuffer); if (msgObject == null) &#123; continue; &#125; // 解析消息 if (msgObject.ModelName == typeof(MessageLogin).Name) &#123; // 用户登陆/心跳 var lginMsg = JsonConvert.DeserializeObject&lt;MessageLogin&gt;(msgObject.ModelData); if (LoginUser.ContainsKey(lginMsg.MacAddress)) &#123; // 更新数据 var vLoginUser = LoginUser.Where(o =&gt; o.Key.Equals(lginMsg.MacAddress)).First(); vLoginUser.Value.UserName = lginMsg.UserName; vLoginUser.Value.NetPoint = new IPEndPoint(_remotePoint.Address, _remotePoint.Port); vLoginUser.Value.LastLoginTime = DateTime.Now; &#125; else &#123; // 新增数据 HoleUserInfo holeUserInfo = new HoleUserInfo &#123; MacAddress = lginMsg.MacAddress, UserName = lginMsg.UserName, NetPoint = new IPEndPoint(_remotePoint.Address, _remotePoint.Port), LastLoginTime = DateTime.Now &#125;; LoginUser.TryAdd(lginMsg.MacAddress, holeUserInfo); &#125; &#125; else if (msgObject.ModelName == typeof(MessageHolePunchingRequest).Name) &#123; // 打洞请求 var holeMsg = JsonConvert.DeserializeObject&lt;MessageHolePunchingRequest&gt;(msgObject.ModelData); var vSelectUsers = LoginUser.Where(o =&gt; o.Key.Equals(holeMsg.TargetMacAddress))?.ToList(); if (vSelectUsers != null &amp;&amp; vSelectUsers.Count &gt;= 1) &#123; var vSelectUser = vSelectUsers.First(); byte[] buffer = ObjectSerializerHelper.JsonSerialize(new MessageHolePunching() &#123; MacAddress = holeMsg.RequestorMacAddress, RequestorNetIP = _remotePoint.Address.ToString(), RequestorNetPort = _remotePoint.Port, IsFirst = holeMsg.IsAtoB &#125;); _server.Send(buffer, buffer.Length, vSelectUser.Value.NetPoint); &#125; &#125; &#125; catch (Exception ex) &#123; NLogHelper.SaveError(ex.ToString()); &#125; &#125; &#125; /// &lt;summary&gt; /// 释放资源 /// &lt;/summary&gt; public void Dispose() &#123; try &#123; if (_server != null) &#123; _serverThread.Abort(); _server.Close(); NLogHelper.SaveInfo($"服务停止！"); &#125; &#125; catch (Exception ex) &#123; NLogHelper.SaveError(ex.ToString()); &#125; &#125;&#125; Clent123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159public class Udp_Client : IDisposable&#123; /// &lt;summary&gt; /// 构造函数 /// &lt;/summary&gt; public Udp_Client(MessageLogin MessageLogin) &#123; _messageLogin = MessageLogin; // 任何与本地连接的用户IP地址 _remotePoint = new IPEndPoint(IPAddress.Any, 0); // 服务器地址 string serverIP = ConfigurationManager.AppSettings["server_remote"]; _hostPoint = new IPEndPoint(IPAddress.Parse(serverIP.Split(':')[0]), int.Parse(serverIP.Split(':')[1])); // 不指定端口,系统自动分配 _client = new UdpClient(); // 监听线程 _listenThread = new Thread(Run); &#125; /// &lt;summary&gt; /// 析构函数 /// &lt;/summary&gt; ~Udp_Client() &#123; Dispose(); &#125; /// &lt;summary&gt; /// 客户端监听 /// &lt;/summary&gt; private readonly UdpClient _client; /// &lt;summary&gt; /// 主机IP /// &lt;/summary&gt; private readonly IPEndPoint _hostPoint; /// &lt;summary&gt; /// 接收任何远程机器的数据 /// &lt;/summary&gt; private IPEndPoint _remotePoint; /// &lt;summary&gt; /// 监听线程 /// &lt;/summary&gt; private readonly Thread _listenThread; /// &lt;summary&gt; /// 登陆信息 /// &lt;/summary&gt; private MessageLogin _messageLogin &#123; get; set; &#125; /// &lt;summary&gt; /// 启动客户端 /// &lt;/summary&gt; public void Start() &#123; // 登陆打洞用户 byte[] buffer = ObjectSerializerHelper.JsonSerialize(_messageLogin); _client.Send(buffer, buffer.Length, _hostPoint); // 启动心跳线程 DispatcherTimer timerHeartbeat = new DispatcherTimer(); timerHeartbeat.Interval = new TimeSpan(TimeSpan.TicksPerMinute); timerHeartbeat.Tick += TimerHeartbeat_Tick; timerHeartbeat.Start(); // 启动主线程 if (_listenThread.ThreadState == ThreadState.Unstarted) &#123; _listenThread.Start(); &#125; &#125; /// &lt;summary&gt; /// 打洞请求 /// &lt;/summary&gt; /// &lt;param name="MacAddress"&gt;目标 Mac 地址&lt;/param&gt; public void HolePunching(string MacAddress) &#123; byte[] buffer = ObjectSerializerHelper.JsonSerialize(new MessageHolePunchingRequest() &#123; RequestorMacAddress = _messageLogin.MacAddress, TargetMacAddress = MacAddress, IsAtoB = true &#125;); _client.Send(buffer, buffer.Length, _hostPoint); &#125; /// &lt;summary&gt; /// 心跳计时器 /// &lt;/summary&gt; /// &lt;param name="sender"&gt;&lt;/param&gt; /// &lt;param name="e"&gt;&lt;/param&gt; private void TimerHeartbeat_Tick(object sender, EventArgs e) &#123; byte[] buffer = ObjectSerializerHelper.JsonSerialize(_messageLogin); _client.Send(buffer, buffer.Length, _hostPoint); &#125; /// &lt;summary&gt; /// 线程主方法 /// &lt;/summary&gt; private void Run() &#123; byte[] msgBuffer; while (true) &#123; try &#123; // 接受消息 msgBuffer = _client.Receive(ref _remotePoint); // 将消息转换为对象 var msgObject = ObjectSerializerHelper.JsonDeserialize(msgBuffer); if (msgObject == null) &#123; continue; &#125; // 解析消息 if (msgObject.ModelName == typeof(MessageHolePunching).Name) &#123; // 接受打洞请求 var holeMsg = JsonConvert.DeserializeObject&lt;MessageHolePunching&gt;(msgObject.ModelData); byte[] bufferUserLogin = ObjectSerializerHelper.JsonSerialize(_messageLogin); _client.Send(bufferUserLogin, bufferUserLogin.Length, new IPEndPoint(IPAddress.Parse(holeMsg.RequestorNetIP), holeMsg.RequestorNetPort)); // 反向打洞 if (holeMsg.IsFirst) &#123; byte[] bufferHolePunchingRequest = ObjectSerializerHelper.JsonSerialize(new MessageHolePunchingRequest() &#123; RequestorMacAddress = _messageLogin.MacAddress, TargetMacAddress = holeMsg.MacAddress, IsAtoB = false &#125;); _client.Send(bufferHolePunchingRequest, bufferHolePunchingRequest.Length, _hostPoint); &#125; &#125; else if (msgObject.ModelName == typeof(MessageLogin).Name) &#123; // 打洞连接成功,接收到对方登陆信息 var lginMsg = JsonConvert.DeserializeObject&lt;MessageLogin&gt;(msgObject.ModelData); NLogHelper.SaveInfo($"P2P打洞成功：&#123;JsonConvert.SerializeObject(lginMsg)&#125;"); &#125; &#125; catch (Exception ex) &#123; NLogHelper.SaveError(ex.ToString()); &#125; &#125; &#125; /// &lt;summary&gt; /// 释放资源 /// &lt;/summary&gt; public void Dispose() &#123; try &#123; if (_client != null) &#123; _listenThread.Abort(); _client.Close(); NLogHelper.SaveInfo($"客户端停止！"); &#125; &#125; catch (Exception ex) &#123; NLogHelper.SaveError(ex.ToString()); &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>udp</tag>
        <tag>hole</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 博客升级]]></title>
    <url>%2Fblog%2F2021%2F01%2F11%2Fblog-IndexNull%2F</url>
    <content type="text"><![CDATA[Hexo 博客生成后 Index 文件为空 简介出差时在一台新系统中装环境，执行生成博客命令 hexo generate 后检查生成目录 public 中的 index.html 文件都为空。调试后发现是新装的 Node.js 版本与 Hexo 版本不匹配，旧版 Nodejs 版本为 v12.14.0，新装版本为 v14.15.4，Hexo 版本为 v3.9。 解决办法降级 Nodejs降级 Nodejs 版本至 v12 升级 Hexo升级 Hexo 版本至与 Nodejs v14.15 匹配的 Hexo v5.3.0 修改配置文件版本修改 Hexo 目录中 package.json 文件12345678910&#123; /* ··· */ "hexo": &#123; "version": "5.3.0" &#125;, "dependencies": &#123; "hexo": "^5.3.0", /* ··· */ &#125;&#125; 执行命令升级版本1npm update 安装 swig如果直接生成博客则会出现 “ { % extends ‘_layout.swig‘ % } { % import ‘_macro/post.swig‘ as post_template % }“ 问题。原因是 hexo 在 5.0 之后把 swig 给删除了需要自己手动安装。1npm i hexo-renderer-swig 修改 external_link生成博客提示异常信息12INFO Validating configWARN Deprecated config detected: &quot;external_link&quot; with a Boolean value is deprecated. See https://hexo.io/docs/configuration for more details. 修改文件 _config.yml 中的节点12external_link: enable: true|false 改为1234external_link: enable: true # Open external links in new tab field: site # Apply to the whole site exclude: '' Next 主题分页显示异常参考最新的 pagination.swig修改 Next 主题的配置文件 ../themes/next/layout/_partials/pagination.swig123456789101112&#123;%- if page.prev or page.next %&#125; &lt;nav class=&quot;pagination&quot;&gt; &#123;&#123; paginator(&#123; prev_text: &apos;&lt;i class=&quot;fa fa-angle-left&quot; aria-label=&quot;&apos; + __(&apos;accessibility.prev_page&apos;) + &apos;&quot;&gt;&lt;/i&gt;&apos;, next_text: &apos;&lt;i class=&quot;fa fa-angle-right&quot; aria-label=&quot;&apos; + __(&apos;accessibility.next_page&apos;) + &apos;&quot;&gt;&lt;/i&gt;&apos;, mid_size : 1, escape : false &#125;) &#125;&#125; &lt;/nav&gt;&#123;%- endif %&#125; Hexo 无法解析特殊字符导致生成失败标题中的中括号，例如：1title: 网页使用 &lt;iframe&gt; 嵌入部分其他网页 解决方法文章中的特殊字符，例如：1&#123;&#123; &#125;&#125;、&#123;% %&#125; 推荐避免使用类似字符或使用HTML转义字符对照表进行转义。 NexT5 中文超链接乱码导致不能跳转博客文章左侧超链接点击无效无法跳转，控制台报错：Cannot read property ‘top’ of undefined。 解决方法由于 href 链接中文 url 未经转码导致中文链接无法跳转，使用 decodeURI() 方法进行重新编码。12// 对获取到的url进行重编码targetSelector = decodeURI(this.getAttribute('href')); 完整段落代码1234567891011121314151617// TOC item animation navigate &amp; prevent #item selector in adress bar.$('.post-toc a').on('click', function(e) &#123; e.preventDefault(); var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href')); // 对获取到的url进行重编码 targetSelector = decodeURI(this.getAttribute('href')); var offset = $(targetSelector).offset().top; hasVelocity ? html.velocity('stop').velocity('scroll', &#123; offset : offset + 'px', mobileHA: false &#125;) : $('html, body').stop().animate(&#123; scrollTop: offset &#125;, 500);&#125;);]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页使用 iframe 嵌入部分其他网页]]></title>
    <url>%2Fblog%2F2021%2F01%2F02%2Fhtml-IframeEmbed%2F</url>
    <content type="text"><![CDATA[在网页中嵌入其他网页中的一部分 简介iframe 元素会创建包含另外一个文档的内联框架，平时使用不多，但是也确实蛮好用的，比如在博客关于页面中嵌入了一个网易云音乐的播放插件，但是有时在嵌入其他页面时直想截取部分嵌入，再此解决。 如何使用最简单的加载加载一个中国天气网中北京的天气预报，看起来很简单，伴随这一篇没用的广告，不认真看甚至根本不敢相信这是中国天气预报的官方网站。 代码1&lt;iframe src="http://www.weather.com.cn/weather/101010100.shtml" width="100%" height="400px" sframeborder="0"&gt;&lt;/iframe&gt; 示例 仅截取天气预报地图部分并嵌入在网页中原理 加载一个 iframe 标签，设置网页长度宽度拉伸网页确保样式符合预期，重要内容无广告遮挡。 iframe 外层添加 div 标签，用于移动 iframe 嵌入网页的坐标，宽度高度为实际选取内容宽度高度，参考 CSS margin 属性 设置偏移量 div 外层在添加一层 div 标签作为遮罩层，用于遮罩偏移量产生的多余信息，宽度高度为实际选取内容宽度高度，设置边框 0 与溢出隐藏 CSS overflow 属性 代码12345&lt;div style="width:680px;height:640px;overflow:hidden;border:0px;"&gt; &lt;div style="width:680px;height:640px;margin:-145px 0px 0px -140px;"&gt; &lt;iframe src="http://www.weather.com.cn/weather/101010100.shtml" height="850" width="1280" frameborder="0"&gt;&lt;/iframe&gt; &lt;/div&gt; &lt;/div&gt; 示例 其他示例(嵌入可交互网页)另一篇博客 Luminox 8821 更换电池 中嵌入日本官网(瑞士官网仅有文档美国官网被跳转成某东了)中的可交互页面 代码12345&lt;div style="width:100%;height:820px;overflow:hidden;border:0px;"&gt; &lt;div style="width:100%;height:820px;margin:-90px 0px 0px 0px;"&gt; &lt;iframe src="https://luminox.jp/watch-collection/land/recon-point-man-8820-series-ref8821-km/" scrolling="no" height="900" width="767" frameborder="0"&gt;&lt;/iframe&gt; &lt;/div&gt;&lt;/div&gt; 示例]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>iframe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Luminox 8821 更换电池]]></title>
    <url>%2Fblog%2F2021%2F01%2F02%2Frepair-Luminox8821%2F</url>
    <content type="text"><![CDATA[简介Luminox 8821 最开始是13年在蚂蚁甩棍论坛看到棍友发的，一直很喜欢这块石英表，工作后17年才买到手，就在前几天没电了，戴了三年多，简单的换一下电池。 氚气发光还是很不错的官网的展示，可以拖动显示正常和夜间的效果 更换电池参数背后四颗螺丝，型号：十字 PH00。电池型号：原厂 RENATA 395，店家给我发货发的 RENATA 371，厚度上薄不到1毫米，可以替换使用。 更换螺丝拧开后盖后向上拨开电池上的压片换上新电池后复原就好，可以在防水胶圈上涂一层防水膏。]]></content>
      <categories>
        <category>Repair</category>
      </categories>
      <tags>
        <tag>repair</tag>
        <tag>watch</tag>
        <tag>luminox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jmeter 使用介绍]]></title>
    <url>%2Fblog%2F2020%2F12%2F25%2Fsoftware-Jmeter%2F</url>
    <content type="text"><![CDATA[简介Apache JMeter 是Apache组织开发的基于Java的压力测试工具。用于对软件做压力测试，它最初被设计用于Web应用测试，但后来扩展到其他测试领域。对测试并不是很熟悉，跟朋友聊天时提到了这个软件，正好也想对自己原来做的东西做一下压力测试，结果实实在在的发现了不少问题。 搭建环境前置条件Java 8+ 下载安装 Jmeterapache jmeter解压文件 配置环境变量 变量名 变量值 JMETER_HOME 解压路径 Path %JMETER_HOME%\bin 控制台输入 jmeter 即可运行123456789PS C:\Users\Administrator&gt; jmeter================================================================================Don't use GUI mode for load testing !, only for Test creation and Test debugging.For load testing, use CLI Mode (was NON GUI): jmeter -n -t [jmx file] -l [results file] -e -o [Path to web report folder]&amp; increase Java Heap to meet your test requirements: Modify current env variable HEAP="-Xms1g -Xmx1g -XX:MaxMetaspaceSize=256m" in the jmeter batch fileCheck : https://jmeter.apache.org/usermanual/best-practices.html================================================================================ 初步使用添加线程组可在线程组中设置压力测试线程数量以及重复次数 添加自定义变量创建自定义变量，在后续的配置中使用可随时调用 添加信息头管理器用于请求默认信息头，例如：content-type：application/json; charset=UTF-8 http 请求可直接用 “${}” 的方式直接使用前面添加的自定义变量 正则表达式提取 Token正常情况下多数接口都需要通过 Token 认证在能访问，但是 Token 通常从登录接口中返回，通过正则表达式匹配到 Token 数据存为自定义变量使用 提取到的 Token 变量存入信息头管理器Token 的使用方法可能不仅限于通过参数传递，也可能通过信息头来传递 调用带 Token 认证的 http 请求 添加结果树与报告可在线程组下添加结果树与报告树图标等统计结果，点击顶部绿色三角等待完成压力测试 使用 Badboy 录制个人感觉配置 Jmeter 是一件很麻烦的事情，可以使用第三方工具 Badboy 录制操作并导出为 .jmx 格式后由 Jmeter 测试。官方网站打不开可以从 softonic 下载]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>jmeter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SwiftUI 隐藏 NavigationView 导航栏]]></title>
    <url>%2Fblog%2F2020%2F11%2F30%2Fswift-NavigationViewHidden%2F</url>
    <content type="text"><![CDATA[SwiftUI 对 NavigationView 导航栏的一些操作 简介原本简单的一个需求，但是相关的文档较少，所以还是记录一下的好 需求描述在 SwiftUI 开发 IOS 应用时，官方建议使用 NavigationView 来跳转页面，使用环境例如登录页弹出注册与修改密码二级菜单，登陆页需要隐藏导航栏，注册与修改密码菜单则需要显示导航栏显示标题并且可以返回登录页。 遇到问题直接使用 .navigationBarHidden(true) 可以使标题隐藏，但是二级菜单中的导航栏同步也会被隐藏，额外增加 .onAppear 与 .onDisappear 控制变量使导航栏在什么时候显示。 修改前截图示例 修改前代码片段1234567891011121314151617181920212223242526struct LoginView: View &#123; var body: some View &#123; NavigationView&#123; VStack()&#123; …… HStack()&#123; NavigationLink( destination: RegisterView(), label: &#123; Text("注册用户") &#125;) Spacer() NavigationLink( destination: RetrievePasswordView(), label: &#123; Text("找回密码") &#125;) &#125; .padding(EdgeInsets(top: 30, leading: 40, bottom: 0, trailing: 40)) &#125; .navigationBarTitle(Text("登录")) &#125; &#125;&#125; 修改后截图示例 修改后代码片段123456789101112131415161718192021222324252627282930313233343536struct LoginView: View &#123; @State var isNavigationBarHidden: Bool = true var body: some View &#123; NavigationView&#123; VStack()&#123; …… HStack()&#123; NavigationLink( destination: RegisterView(), label: &#123; Text("注册用户") &#125;) Spacer() NavigationLink( destination: RetrievePasswordView(), label: &#123; Text("找回密码") &#125;) &#125; .padding(EdgeInsets(top: 30, leading: 40, bottom: 0, trailing: 40)) &#125; .navigationBarTitle(Text("登录")) .navigationBarHidden(self.isNavigationBarHidden) .onAppear &#123; self.isNavigationBarHidden = true &#125; .onDisappear &#123; self.isNavigationBarHidden = false &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>swiftui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 Release 下输出堆栈信息]]></title>
    <url>%2Fblog%2F2020%2F11%2F25%2Fcsharp-CallerMemberName%2F</url>
    <content type="text"><![CDATA[使用 CallerMemberNameAttribute 类获取堆栈信息 简介在项目中需要在打印日志同时打印堆栈信息，通常使用 StackTrace 来捕获堆栈信息，并跟随日志一同打印，但是生产环境部署通常使用 Release 方式打包，这会导致 StackTrace 方法失效。测试改用 CallerMemberNameAttribute 方式可以解决。 代码StackTrace 方式获取堆栈信息123456789public static void SaveError(string message)&#123; var stackTrace = new StackTrace(true); var stackFrame = stackTrace.GetFrame(1); if (stackFrame != null) &#123; logger.Error($"[&#123;stackFrame?.GetMethod()?.DeclaringType?.Name&#125;][&#123;stackFrame?.GetMethod()?.Name&#125;] &#123;message&#125;"); &#125;&#125; CallerMemberNameAttribute 改用方式获取堆栈信息1234567public static void SaveError(string message,[System.Runtime.CompilerServices.CallerMemberName] string memberName = "",[System.Runtime.CompilerServices.CallerFilePath] string sourceFilePath = "",[System.Runtime.CompilerServices.CallerLineNumber] int sourceLineNumber = 0)&#123; logger.Error($"[&#123;System.IO.Path.GetFileName(sourceFilePath)&#125;][&#123;memberName&#125;] &#123;message&#125;");&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>.net core</tag>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode IOS 真机调试]]></title>
    <url>%2Fblog%2F2020%2F10%2F23%2Fxcode-RealMachineDebugging%2F</url>
    <content type="text"><![CDATA[简介IOS 开发使用真机有线调试和无线 Wi-Fi 调试 调试环境电脑：MacBook pro 16电脑系统：macOS Catalina 10.15.7手机：iPhone 6s手机系统：IOS 13.6.1开发软件：Xcode 12.1 配置方式有线调试设置证书 打开用户菜单Xcode → Preferences 添加用户菜单中选择 Accounts 添加一个用户 添加证书点击右下角 Manage Certificates… → 添加 Apple Development 证书 证书管理如果需要删除证书，在 keychain access 程序中删除 在应用中添加组织编辑 .xcodeproj 配置 → Signing &amp; Capabilities → 选择刚才添加的用户 手机数据线链接至电脑 iPhone 中设置信任设置 → 通用 → 设备管理 运行程序选择真机设备如需登录输入钥匙串密码，输入系统密码即可 无线调试（需完成有线调试步骤） 打开链接设备菜单Window → DevicesAndSimulators 开启远程 Wi-Fi 调试保证电脑与手机在同一网络下 → 勾选 Connect via network → 左侧设备中显示一个地球则可以 Wi-Fi 调试]]></content>
      <categories>
        <category>IOS</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>xcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 真机调试]]></title>
    <url>%2Fblog%2F2020%2F10%2F23%2Fandroid-RealMachineDebugging%2F</url>
    <content type="text"><![CDATA[简介Android 开发使用真机有线调试和无线 wifi 调试 配置方式有线调试Android 手机数据线链接电脑并开启 USB 调试大部分 Android 默认不显示 USB 调试，多次点击系统版本号开启开发者模式 Windows安装 Google USB Driver 选择 File → Setting… 选择 Appearance &amp; Behavior → System Settings → Android SDK → SDK Tools 勾选 Android SDK Tools 选项安装 在计算机管理 → 设备管理器 → 便携设备中选择手机型号，更新驱动，期间可能会在手机中认证授权设备，确认即可 确保正确开启 USB 调试后可以真机调试 Mac OS获取 Android ADB 路径 选择 File → Project Structure… 选择 SDK Location → 选中位置为 Android ADB 路径 配置 Android ADB 环境变量在 ～/.bash_profile 文件中配置 创建 .bash_profile 文件（如果不存在） 12cd ~touch .bash_profile 编辑 .bash_profile 文件，ANDROID_HOME 参数为上一步获取的 ADB 路径 1open .bash_profile 保存文件后执行配置立即生效命令，输入 adb version 检查是否配置成功 12source .bash_profileadb version 配置手机可被识别 执行命令获取 usb 接入信息，查询信息中会显示链接的 Android 信息，记录 Vendor ID 备用 1system_profiler SPUSBDataType 在 ～/.android/.adb_usb 文件中配置，目录如下 创建 .adb_usb 文件（如果不存在） 12cd ~touch .android/.adb_usb 编辑 .adb_usb 文件，填写上一步获取的 Vendor ID 并保存 执行 adb 命令，显示出链接的手机信息后可以真机调试 1adb devices 无线调试（需完成有线调试步骤）Windows &amp; Mac OS 配置 ADB 环境变量（如果未配置）Windows 通常 ADB 路径：..\Android\Sdk\platform-toolsMac OS 通常 ADB 路径：~/Library/Android/sdk 使用命令检测 Android 手机是否链接正常（有线连接） 1adb devices 创建 adb 端口 使用命令 adb tcpip [port] 让手机的某个端口处于监听状态 服务器端通过扫描5555到5585之间的奇数端口来寻找模拟器或设备实例并与找到的建立链接。 1adb topic 5555 返回 restarting in TCP mode port:5555 为创建成功 创建 adb 无线连接 保证手机与电脑在一个网络中 使用命令行 adb connect [ip-address]:[port-num] 连接手机 命令中 ip 地址为手机在网络中的 ip 地址，端口号为上一步创建的监听端口 1adb connect 192.168.1.101:5555 返回 connected to 192.168.1.101:5555 为创建成功，此时可以断开有线连接 重新执行命令检查 adb 链接情况 1adb devices 返回 {ip 地址}:{端口号} 正确则可以进行无线调试 断开 Wi-Fi 链接 使用命令 adb disconnect [ip-address]:[port-num] 来中断连接 1adb disconnect 192.168.1.101:5555 返回 disconnected 192.168.1.101:5555 断开成功 命令展示]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>android studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 CEF 控件在桌面应用中加载百度地图]]></title>
    <url>%2Fblog%2F2020%2F08%2F11%2Fcsharp-CefBaiduMap%2F</url>
    <content type="text"><![CDATA[在 WPF 中调用 CEF 加载百度地图简介最近有需求需要把带定位的百度地图加载到桌面应用中 前置条件使用 CEF 在 PC 客户端中加载网页 开发 BaiduMap 用户控件创建带参数百度地图 WEB 页面map.baidu.html?Lon=116.4716&amp;Lat=40.01849123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript" src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="https://api.map.baidu.com/api?v=3.0&amp;您的ak"&gt;&lt;/script&gt; &lt;style type="text/css"&gt; body &#123; margin: 0; &#125; #allmap &#123; width: 100%; height: 100%; overflow: hidden; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="allmap"&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; //获取经纬度参数 function getUrlParam(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)"); var r = window.location.search.substr(1).match(reg); if (r != null) &#123; return unescape(r[2]); &#125; else &#123; return null; &#125; &#125; var vLon = getUrlParam('Lon'); var vLat = getUrlParam('Lat'); //加载百度地图 //创建Map实例 var map = new BMap.Map("allmap"); //创建点坐标 var point = new BMap.Point(vLon, vLat); map.centerAndZoom(point, 17); //启用滚轮放大缩小 map.enableScrollWheelZoom(); //创建标注 var marker = new BMap.Marker(point); //将标注添加到地图中 map.addOverlay(marker);&lt;/script&gt;&lt;/html&gt; BaiduMap.xaml 用户控件12345678910111213&lt;UserControl x:Class="Ice.BaiduMap.Control.BaiduMap" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:d="http://schemas.microsoft.com/expression/blend/2008" xmlns:chrome="clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf" xmlns:local="clr-namespace:Ice.BaiduMap.Control" mc:Ignorable="d" d:DesignHeight="450" d:DesignWidth="800"&gt; &lt;Grid&gt; &lt;chrome:ChromiumWebBrowser x:Name="Browser"/&gt; &lt;/Grid&gt;&lt;/UserControl&gt; BaiduMap.xaml.cs 用户控件后台12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455using CefSharp.Wpf;using System;using System.IO;using System.Windows;using System.Windows.Controls;namespace Ice.BaiduMap.Control&#123; /// &lt;summary&gt; /// BaiduMap.xaml 的交互逻辑 /// &lt;/summary&gt; public partial class BaiduMap : UserControl &#123; public BaiduMap() &#123; InitializeComponent(); this.Loaded += BaiduMap_Loaded; &#125; private void BaiduMap_Loaded(object sender, RoutedEventArgs e) &#123; if (File.Exists(_webapp_baidumap_path) &amp;&amp; !string.IsNullOrEmpty(Lon) &amp;&amp; !string.IsNullOrEmpty(Lat)) &#123; Browser.Address = $"&#123;_webapp_baidumap_path&#125;?Lon=&#123;Lon&#125;&amp;Lat=&#123;Lat&#125;"; &#125; &#125; /// &lt;summary&gt; /// 百度地图加载文件 /// &lt;/summary&gt; private string _webapp_baidumap_path = $"&#123;AppDomain.CurrentDomain.BaseDirectory&#125;WebApp\\map.baidu.html"; /// &lt;summary&gt; /// 经度 /// &lt;/summary&gt; public string Lon &#123; get &#123; return (string)GetValue(LonProperty); &#125; set &#123; SetValue(LonProperty, value); &#125; &#125; public static readonly DependencyProperty LonProperty = DependencyProperty.Register("Lon", typeof(string), typeof(BaiduMap)); /// &lt;summary&gt; /// 纬度 /// &lt;/summary&gt; public string Lat &#123; get &#123; return (string)GetValue(LatProperty); &#125; set &#123; SetValue(LatProperty, value); &#125; &#125; public static readonly DependencyProperty LatProperty = DependencyProperty.Register("Lat", typeof(string), typeof(BaiduMap)); &#125;&#125; 在使用的地方引用123&lt;Grid&gt; &lt;control:BaiduMap Lon="116.4716" Lat="40.01849"/&gt;&lt;/Grid&gt;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>baidu</tag>
        <tag>c#</tag>
        <tag>wpf</tag>
        <tag>cef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 CEF 在 PC 客户端中加载网页]]></title>
    <url>%2Fblog%2F2020%2F08%2F11%2Fcsharp-CefSharp%2F</url>
    <content type="text"><![CDATA[在 WPF 中调用 CEF 加载网页简介最近有需求在 wpf 中加载网页，尝试使用 CEF 加载 Chrome 内核浏览器显示。 引用库介绍NuGet 中引用 CefSharp.Wpf 设置需要在项目 .csproj 文件中增加代码1234567891011&lt;ItemGroup&gt; &lt;Reference Update="CefSharp"&gt; &lt;Private&gt;true&lt;/Private&gt; &lt;/Reference&gt; &lt;Reference Update="CefSharp.Core"&gt; &lt;Private&gt;true&lt;/Private&gt; &lt;/Reference&gt; &lt;Reference Update="CefSharp.Wpf"&gt; &lt;Private&gt;true&lt;/Private&gt; &lt;/Reference&gt;&lt;/ItemGroup&gt; 使用.xaml 文件中 增加引用和样式1xmlns:chrome="clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf" 123&lt;Grid&gt; &lt;chrome:ChromiumWebBrowser x:Name="Browser"/&gt;&lt;/Grid&gt; .xaml.cs 文件中增加代码1Browser.Address = @"https://www.baidu.com/"; 即可显示 CefSharp 使用优化屏蔽或修改右键菜单123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using CefSharp;namespace *&#123; /// &lt;summary&gt; /// 关联 Cef 右键菜单 /// &lt;/summary&gt; public class RightMenuHandler : IContextMenuHandler &#123; public void OnBeforeContextMenu(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IContextMenuParams parameters, IMenuModel model) &#123; //主要修改代码在此处;如果需要完完全全重新添加菜单项,首先执行model.Clear()清空菜单列表即可. //需要自定义菜单项的,可以在这里添加按钮; if (model.Count &gt; 0) &#123; model.AddSeparator();//添加分隔符; &#125; //清理所有右键菜单 model.Clear(); //打开调试 //model.AddItem((CefMenuCommand)26501, "Show DevTools"); //model.AddItem((CefMenuCommand)26502, "Close DevTools"); &#125; public bool OnContextMenuCommand(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IContextMenuParams parameters, CefMenuCommand commandId, CefEventFlags eventFlags) &#123; //命令的执行,点击菜单做什么事写在这里. if (commandId == (CefMenuCommand)26501) &#123; browser.GetHost().ShowDevTools(); return true; &#125; if (commandId == (CefMenuCommand)26502) &#123; browser.GetHost().CloseDevTools(); return true; &#125; return false; &#125; public void OnContextMenuDismissed(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame) &#123; &#125; public bool RunContextMenu(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IContextMenuParams parameters, IMenuModel model, IRunContextMenuCallback callback) &#123; //return false 才可以弹出 return false; &#125; &#125;&#125; 调用时引用 12// 关联右键菜单Browser.MenuHandler = new RightMenuHandler(); 捕获快捷键(调试使用)1234567891011121314151617181920212223242526272829303132333435363738394041424344using CefSharp;using System;using System.Windows.Forms;namespace *&#123; /// &lt;summary&gt; /// 捕获 Cef 快捷键 /// &lt;/summary&gt; public class KeyBoardHandler : IKeyboardHandler &#123; public bool OnKeyEvent(IWebBrowser browserControl, IBrowser browser, KeyType type, int windowsKeyCode, int nativeKeyCode, CefEventFlags modifiers, bool isSystemKey) &#123; if (type == KeyType.KeyUp &amp;&amp; Enum.IsDefined(typeof(Keys), windowsKeyCode)) &#123; var key = (Keys)windowsKeyCode; switch (key) &#123; case Keys.F12: browser.ShowDevTools(); break; case Keys.F5: if (modifiers == CefEventFlags.ControlDown) &#123; //MessageBox.Show("ctrl+f5"); browser.Reload(true); &#125; else &#123; //MessageBox.Show("f5"); browser.Reload(); &#125; break; &#125; &#125; return false; &#125; public bool OnPreKeyEvent(IWebBrowser browserControl, IBrowser browser, KeyType type, int windowsKeyCode, int nativeKeyCode, CefEventFlags modifiers, bool isSystemKey, ref bool isKeyboardShortcut) &#123; return false; &#125; &#125;&#125; 调用时引用 1234#if DEBUG // 关联快捷键 Browser.KeyboardHandler = new KeyBoardHandler();#endif CefSharp 以 Any CPU 平台编译并且使文件生成在子目录参考文档Add AnyCPU SupportCopy CefSharp Files 代码部分编辑项目文件 project.csproj 加入以下内容123456789101112&lt;Project Sdk="Microsoft.NET.Sdk.WindowsDesktop"&gt; &lt;PropertyGroup&gt; &lt;!--允许在 Any CPU 平台下允许编译--&gt; &lt;CefSharpAnyCpuSupport&gt;true&lt;/CefSharpAnyCpuSupport&gt; &lt;!--拷贝 CefSharp 相关文件至 \CefSharp 子文件夹--&gt; &lt;!--x86 与 x64 平台下编译会生成在 \CefSharp 目录下--&gt; &lt;!--Any CPU 平台下编译会在 \CefSharp 下生成 \x86 与 \x64 子文件夹--&gt; &lt;CefSharpTargetDir&gt;\CefSharp&lt;/CefSharpTargetDir&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; 在运行初始时执行代码 WPF 为：App.xaml.cs 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869using CefSharp;using CefSharp.Wpf;using System;using System.IO;using System.Reflection;using System.Runtime.CompilerServices;using System.Threading;using System.Windows;namespace *&#123; /// &lt;summary&gt; /// Interaction logic for App.xaml /// &lt;/summary&gt; public partial class App : Application &#123; protected override void OnStartup(StartupEventArgs e) &#123; // Add Custom assembly resolver AppDomain.CurrentDomain.AssemblyResolve += Resolver; // Any CefSharp references have to be in another method with NonInlining // attribute so the assembly rolver has time to do it's thing. InitializeCefSharp(); // 启动主程序 &#125; [MethodImpl(MethodImplOptions.NoInlining)] private static void InitializeCefSharp() &#123; var settings = new CefSettings(); // 不对日志进行保存 settings.LogSeverity = LogSeverity.Disable; // Set BrowserSubProcessPath based on app bitness at runtime settings.BrowserSubprocessPath = GetCefSharpFilePath("CefSharp.BrowserSubprocess.exe"); // Make sure you set performDependencyCheck false Cef.Initialize(settings, performDependencyCheck: false, browserProcessHandler: null); &#125; // Will attempt to load missing assembly from either x86 or x64 subdir // Required by CefSharp to load the unmanaged dependencies when running using AnyCPU private static Assembly Resolver(object sender, ResolveEventArgs args) &#123; if (args.Name.StartsWith("CefSharp")) &#123; string assemblyName = args.Name.Split(new[] &#123; ',' &#125;, 2)[0] + ".dll"; string archSpecificPath = GetCefSharpFilePath(assemblyName); return File.Exists(archSpecificPath) ? Assembly.LoadFile(archSpecificPath) : null; &#125; return null; &#125; /// &lt;summary&gt; /// 获取 CefSharp 文件路径 /// &lt;/summary&gt; /// &lt;param name="assemblyName"&gt;文件名称&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; private static string GetCefSharpFilePath(string assemblyName) &#123; var vAnyCpuPath = Path.Combine(AppDomain.CurrentDomain.SetupInformation.ApplicationBase, "CefSharp", Environment.Is64BitProcess ? "x64" : "x86", assemblyName); var vNoAnyCpuPath = Path.Combine(AppDomain.CurrentDomain.SetupInformation.ApplicationBase, "CefSharp", assemblyName); return Directory.Exists(Path.GetDirectoryName(vAnyCpuPath)) ? vAnyCpuPath : vNoAnyCpuPath; &#125; &#125;&#125; CefSharp 报错：试图加载格式不正确的程序。默认 CefSharp 仅允许在设置为 x86 或 x64 平台下运行，修改设置即可。但是有时会在配置了允许 Any CPU 后出现 x86 平台下正常 x64 平台下运行报同样错误，最后找到问题出现在独立创建用的于调用 Cef 库不知何时生成出一些不必要的内容，删除 project.csproj 文件下不必要的内容即可。1234567891011&lt;PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'"&gt; &lt;PlatformTarget&gt;x86&lt;/PlatformTarget&gt;&lt;/PropertyGroup&gt;&lt;PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x86'"&gt; &lt;PlatformTarget&gt;x86&lt;/PlatformTarget&gt;&lt;/PropertyGroup&gt;&lt;PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'"&gt; &lt;PlatformTarget&gt;x86&lt;/PlatformTarget&gt;&lt;/PropertyGroup&gt;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>wpf</tag>
        <tag>cef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[插入无线网卡后局域网无法连接]]></title>
    <url>%2Fblog%2F2020%2F07%2F16%2Fsystem-Route%2F</url>
    <content type="text"><![CDATA[通过 rount 命令编辑路由表 简介在一次出差时遇到插入无线网卡后内网无法访问，通过 rount 命令配置路由表后解决。 网络环境用户现场内网绑定地址IPV4 地址：10.69.129.126IPV4 子网掩码：255.255.255.0IPV4 默认网关：10.69.129.254 其他使用的内网地址IPV4 地址1：10.69.176.1IPV4 地址2：10.69.177.1 无线网卡HUAWEI e8372h-155 解决方法调用命令解决 10.69.129.1 网段访问1route -p add 10.69.129.0 mask 255.255.255.0 10.69.129.254 网段 10.69.176.1 与 10.69.177.1 访问转发 10.69.129.254 路由12route -p add 10.69.176.0 mask 255.255.255.0 10.69.129.254route -p add 10.69.177.0 mask 255.255.255.0 10.69.129.254 命令语法介绍1route [-f] [-p] [Command] [Destination] [mask Netmask] [Gateway] [metric Metric] [if Interface] -f清除所有不是主路由（网掩码为 255.255.255.255 的路由）、环回网络路由（目标为 127.0.0.0，网掩码为 255.255.255.0 的路由）或多播路由（目标为 224.0.0.0，网掩码为 240.0.0.0 的路由）的条目的路由表。如果它与命令之一（例如 add、change 或 delete）结合使用，表会在运行命令之前清除。 -p与 add 命令共同使用时，指定路由被添加到注册表并在启动 TCP/IP 协议的时候初始化 IP 路由表。默认情况下，启动 TCP/IP 协议时不会保存添加的路由。与 print 命令一起使用时，则显示永久路由列表。所有其它的命令都忽略此参数。永久路由存储在注册表中的位置是 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\PersistentRoutes。 command指定要运行的命令。下表列出了有效的命令。 命令 目的 add 添加路由 change 更改现存路由 delete 删除路由 print 打印路由 Destination指定路由的网络目标地址。目标地址可以是一个 IP 网络地址（其中网络地址的主机地址位设置为 0），对于主机路由是 IP 地址，对于默认路由是 0.0.0.0。 mask subnetmask指定与网络目标地址相关联的网掩码（又称之为子网掩码）。子网掩码对于 IP 网络地址可以是一适当的子网掩码，对于主机路由是 255.255.255.255 ，对于默认路由是 0.0.0.0。如果忽略，则使用子网掩码 255.255.255.255。定义路由时由于目标地址和子网掩码之间的关系，目标地址不能比它对应的子网掩码更为详细。换句话说，如果子网掩码的一位是 0，则目标地址中的对应位就不能设置为 1。 Gateway指定超过由网络目标和子网掩码定义的可达到的地址集的前一个或下一个跃点 IP 地址。对于本地连接的子网路由，网关地址是分配给连接子网接口的 IP 地址。对于要经过一个或多个路由器才可用到的远程路由，网关地址是一个分配给相邻路由器的、可直接达到的 IP 地址。 metric Metric为路由指定所需跃点数的整数值（范围是 1 ~ 9999），它用来在路由表里的多个路由中选择与转发包中的目标地址最为匹配的路由。所选的路由具有最少的跃点数。跃点数能够反映跃点的数量、路径的速度、路径可靠性、路径吞吐量以及管理属性。 if Interface指定目标可以到达的接口的接口索引。使用 route print 命令可以显示接口及其对应接口索引的列表。对于接口索引可以使用十进制或十六进制的值。对于十六进制值，要在十六进制数的前面加上 0x。忽略 if 参数时，接口由网关地址确定。]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>windows</tag>
        <tag>rount</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Rose 使用介绍]]></title>
    <url>%2Fblog%2F2020%2F05%2F11%2Fsoftware-Rose%2F</url>
    <content type="text"><![CDATA[本地灾备、远程容灾，快速恢复数据和业务简介RoseReplicator是基于网络的实时数据容灾复制以及业务连续性保护产品，实现生产数据的本地/远程实时容灾备份，保证数据的安全。实时监测应用资源运行状态，实现资源故障时自动/手动应急切换，解决软、硬件的单点故障，提供高级别的容灾保护。 前置条件1.虚拟机（VMware）测试，两台（Windows Server 2016）2.两台机器部署 MySQL，版本 5.7.293.两台机器部署 RoseReplicatorPlus，版本 5.8.04.Rose 客服人员微信号：cathy_shen10015.两台虚拟机IP地址： 主机：192.168.5.210;192.168.6.210; 备机：192.168.5.215;192.168.6.215; 虚拟地址：192.168.5.212; 创建管理软件账户（主备都要创建）1.进入安装目录 C:\Program Files\ReplicatorPlus\bin 以管理员方式运行（否则会报 File open error 错误） account.exe 应用程序。2.根据需求创建不同权限的用户。3.输入用户名密码，显示 Change successfully! 注册成功。 向导安装1.选择：系统→配置向导 2.选择活动主机登录 3.选择备用主机登录 4.添加客服手里要来的注册码 5.创建主机关系，创建心跳网(心跳要求与局域网IP不同网段，添加一个新网段后可在主机列表更新系统信息后重新创建心跳，测试使用时把心跳IP网段改为了6网段) 6.选择应用服务类型，类型中不包含MySQL，客服建议选择USERDEF（用户自定义） 7.应用服务数据→勾选绑定数据→添加一对心跳包网段的IP对，定制用于复制的数据集合点击修改→选择mysql数据库data目录（Rose会同步MySQL的Data目录）。 8.设置IP资源：勾选主机网卡中局域网IP对，活动IP中新增一个局域网中未规划的IP。 9.仲裁磁盘：跳过10.选择共享卷：跳过11.选择NT服务：添加MySQL57服务，弹出确定将非手动启动类型的NT服务修改为手动启动类型选择是。 12.设置文件共享：跳过13.进程：跳过，这个主要是针对第三方开发的应用程序，通过exe启动，没有在Windows服务列表中注册服务的，如果是mysql应用不需要配置。14.设置代理参数：跳过，这个主要是针对bat启动的应用15.配置详细信息：确认无误点击完成开始配置。 16.关闭后咨询是否带入，点击否。 后续操作1.手动停止两台电脑MySQL，手动备份Data目录。2.在RoseReplicatorPlus 控制中心点击中间方块右键带入。 3.修改数据库内容后，数据同步正常。4.在方块上右键转移，连接数据库同步后同步正常。5.关闭一台机器后，另一台电脑 MySQL 服务正常启动。]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>rose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Clumsy 使用介绍]]></title>
    <url>%2Fblog%2F2020%2F03%2F20%2Fsoftware-Clumsy%2F</url>
    <content type="text"><![CDATA[用于模拟极端网络环境的网络干扰软件简介Clumsy makes your network condition on Windows significantly worse, but in a controlled and interactive manner.公司工作需要，使用该软件模拟测试极端网络情况下的软件稳定性。 使用官方手册：http://jagt.github.io/clumsy/manual.html 配置过滤条件参考 WinDivert 配置文档 干扰方式 Function 翻译 功能说明 Lag 滞后 将数据包保留一小段时间以模拟网络滞后 Dorp 丢弃 随机丢弃数据包 Throttle 节流阀 在给定的时间段内阻塞流量，然后分批发送 Duplicate 复制 将克隆后的数据包立即发送到原始数据包 Out of order 乱序 重新排列数据包的顺序 Tamper 篡改 微调数据包内容的位]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>clumsy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机硬件维修检测]]></title>
    <url>%2Fblog%2F2020%2F02%2F07%2Frepair-ComputerHardware%2F</url>
    <content type="text"><![CDATA[简介在上大学之前，曾在百脑汇电子城工作过大半年，有维修过电脑、打印机、监控摄像头，时隔多年，这依然使我受益匪浅，在此记录一些硬件故障排除的经验，以及一些检测软件的使用。以组装台式机为主，部分介绍笔记本。 电脑构成以及可能存在的问题 计算机硬件 是否必须 可能存在的问题 机箱 可选 内部静电导致无法开机、机箱前面板接主板容易接错 电源 是 风扇转速不够导致声音大或过热短路、电源不工作 主板 是 主板南桥北桥芯片过热、电容鼓包等导致运行中断电或无法开机、按开机键无反应、无法从U盘启动 CPU 是 CPU 完全不工作(可能性较低并且不能修复) 内存 是 闪存颗粒损坏(不建议维修)、接触不良导致无法开机(参考：接口虚连) 硬盘 是 (机械)硬盘坏道导致数据丢失或电脑死机、(机械)硬盘主控板损坏、(固态)硬盘写入次数达到上限、(固态)硬盘内存颗粒损坏(不建议维修)、系统引导错误无法进入系统、SATA 线损坏导致无法读取磁盘、FAT32 磁盘格式单个文件最大只能支持4GB 显卡 可选(板载) 电容鼓包(参考：电容鼓包等导致运行中断电或无法开机)、接触不良导致无法开机(参考：接口虚连) 散热器 是 缺少硅脂或风扇转速不够导致声音大或过热短路 光驱 可选 标记为 RW 的光驱才可以刻录光盘 声卡 可选(板载) 由于接口错误或系统设置导致的麦克风或音响失效 网卡 可选(板载) 网线损坏、部分系统安装不包含网卡驱动、配置问题导致的网络无法连接 显示器 可选(远程) 线材损坏(VGA/DVI/HDMI/DP)无法显示、高压板或驱动板损坏、亮点或屏线(修复概率较低) 键盘 是 维修建议使用 PS/2 接口、(机械)键盘轴脱焊 鼠标 可选(极客) 鼠标连键(单击变双击) 音响 可选(耳麦) 外置 USB 供电的音响出现杂音 打印机 可选 驱动问题导致无法使用、(针式)打印机色带打卷或断裂、(喷墨式)打印机喷头堵塞或需更换墨盒、(激光)打印机卡纸重影 游戏手柄 可选 连接数据线虚连 运行中故障(软件或硬件导致) 问题状况 可能存在的问题 移动电脑后无法开机 搬运导致的 PCI 或内存接口松动，参考：按开机键无反应 电脑运行一段时间后突然关机 温度过高、电压不稳 电脑运行一段时间后突然蓝屏 磁盘出现坏道、系统软件或应用软件导致驱动异常 鼠标键盘操作明显延迟 CPU/内存/磁盘占用过高导致 屏幕花屏或色彩异常 线材松动或损坏(VGA/DVI/HDMI/DP)、显卡接触不良 系统软件或应用软件相关推荐 软件功能 推荐软件 简介 U盘启动(WinPE) Rufus、 老毛桃、大白菜 通过U盘启动提供的 WinPE 包含很多有用的工具，比如：DiskGenius 分区工具、Ghost 操作系统 Windows、Linux 现大部分装电脑都会选择 Windows(原版建议通过itellyou下载，Ghost 版建议使用Deepin或雨林木风)、部分企业或个人学习选择 Linux(建议使用Ubuntu、CentOS、Red Hat、Debian)、MAC(黑苹果请移步到社区论坛吧) 系统还原 冰点还原 重启电脑还原至初始状态，避免病毒入侵，广泛用于银行学校宾馆，除了硬件 PCI 接口的还原卡之外，用软件还原也是不错的选择 磁盘分区/坏道检测/数据恢复 DiskGenius、MHDD、EasyRecovery 1.DiskGenius 是一个常用的分区、坏道检测以及数据恢复的工具。2.MHDD 是一个古老的坏道检测工具，适用于老式 AMD 型机器坏道检测，但是其工具强大可以抹除坏道，现 U 盘启动 DOS 工具箱包含3. EasyRecovery 更专业的数据恢复厂商 光盘刻录 UltraISO、Nero 个人觉着重要的数据刻录在光盘里还是蛮棒的 副本分屏 OnTopReplica 这超过了维修的范围，但还是推荐一下，一个打游戏时可以优雅的把小地图投到另一块屏幕上(放大至全屏) 驱动安装 鲁大师、驱动精灵、驱动人生、万能驱动 除了官网下载指定型号的驱动外，选择国内厂商制作的一键安装也不错。1.鲁大师(娱乐大师、鲁大姐)是最常见的驱动安装软件，压力检测也可以很好的测试电脑问题以及…没什么太大用的跑分2.驱动精灵、驱动人生 特色在于可以下载带网卡驱动版，有些时候系统装完没有安装网卡驱动，需要联网才能下载网卡驱动，没有网卡驱动又连不上网，陷入死循环3.万能驱动是 IT 天空制作的整合版驱动包，文件较大，一般 Ghost 系统中集成的就是万能驱动，另外 IT 天空提供了完整的工具程序，直接 Ghost 出一个自己的系统也不错哦 测试软件 3DMark、FritzChessBenchmark、FurMark、Unigine Heaven、CrystalDiskMark 1.3DMark 测试显卡游戏性能的专业软件2.FritzChessBenchmark 国际象棋算法测试 CPU 运算速度3. FurMark 知名的 GPU 拷机压力测试软件4. Unigine Heaven 同样是知名的性能稳定测试软件5.知名的磁盘读写基准测试软件 维修维修前建议准备1.各种型号螺丝刀2.条件允许的情况下准备测试机(能够正常运行的低配零件)，用于维修时替换部分可用零件检测。3.主板诊断卡4.U盘或光盘(包含启动项和系统)5.电烙铁、焊锡、焊油、匹配型号的电容等零件、电工万能表6.网线钳、水晶头、网线、网线测线仪 机箱内部静电导致无法开机有遇到过几次这样的情况：电脑无法开机，短接主板开关灯不亮风扇不转，主板诊断卡不显示数字，主板上不存在明显损坏(鼓电容等)，重新插拔内存以及 PCI 接口设备后无明显改善，短接电源却可以使电源正常工作，尝试将所有零部件取出放在桌子上可以正常运行，应该是机箱设计缺陷或太多灰尘导致主板短路无法运行，全部拆出来清理灰尘即可。 机箱前面板接主板容易接错机箱的前面板都会有一些功能型接线，常见的有音频、USB/SD、电源开关/复位需要对应的接在主板的接口上(通常是下方)，每种主板的接口顺序和位置不一样，建议查看主板上标记的缩写，或根据型号查询使用手册。举例我现在使用的主板是 ASUS PRIME Z390-A 电源不工作1.确认其他硬件正常后无法通过主板开关运行电源，可尝试通过短路电源 ATX 24 PIN 接线的 PS-ON 与 COM 尝试启动电源。2.尝试更换 220V 接入电源线(电脑通用三口品字尾电源线，实在没有多余可以找找身边电饭锅)3.如果是内部高压滤波电容损坏或变压器损坏，不建议维修，想动手尝试的可以玩一玩。 风扇转速不够导致声音大或过热短路目前大部分设备还避免不了使用风冷散热，使用过久以后会导致积灰严重，噪音较大或没有良好散热后导致计算机突然保护断电。1.拆出风扇清理灰尘、可适当涂抹润滑油。2.直接更换相同型号风扇部件。3.CPU 由于缺少硅脂也会出现过热保护断电情况。 主板南桥北桥芯片过热1.如果运行时突然保护断电，可尝试触摸桥芯片是否过热，如果没有影响到基础硬件使用，可尝试在桥芯片上涂抹硅脂然后贴上一片铝制散热片。2.如果无法开机或影响其他硬件工作且桥芯片过热，需要更换桥芯片才可以，通常桥芯片为 BGA 封装，除了购买到型号匹配的芯片外(通常电脑店都是用废板上拆一个同型号的)，还需要准备热风枪或 BGA 焊台(芯片级维修存在很大风险，救活了赚不少，救不活赔个芯片钱还有时间)。 电容鼓包等导致运行中断电或无法开机电容鼓包是主板上比较常见的问题，大部分情况更换电容可以修复好，但是也难免有出现隐藏的其他问题导致更换完部件效果，下图是一个比较常见的鼓电容情况，更换同型号电容即可。 按开机键无反应有时难免遇到接通电源后按开机键电脑无响应，逐步排除1.机箱前面板按钮或连接线出现问题，尝试使用短接主板上的开关启动，以主板 ASUS PRIME Z390-A 为例：短接 PWRSW 2.如依旧无法点亮机器依次更换电源，主板等主要零件测试。 如果按开机键后点亮机器，但是短时间内未进系统再次关机，逐步排除1.如果有主板诊断卡，可插入诊断卡开机检查故障诊断码检测对应的硬件设备。通常来说两位诊断卡会提示大概错误如下，详细错误请查询购买诊断卡说明书。 故障代码 故障位置 FF、00、C0、D0、CF、F1 CPU 未通过 C1、C6、C3、D3、D4、D6、D8、B0、A7、E1 内存未通过 24、25、26、01、0A、0B、2A、2B、31 显卡未通过 2.如手头没有诊断卡，尝试重新插拔 PCI 接口上的设备和内存，参考接口虚连，减少至最简零件数启动，通过替换配件检测故障。 无法从U盘启动对于维修人员来讲，排除所有硬件问题后，重装系统就可以做最后的收尾了，但是对于市面上各式各样的 U 盘来说，主板经常存在无法识别的情况，如果 U 盘作为系统盘的话，购买时优先考虑与主板类似时间出厂的产品，匹配 USB 标准(v1.1/v2.0/v3.0)，WinPE 推荐使用与主板出厂时间相近的镜像(老毛桃、大白菜)，选择与主板设置匹配的启动方式(BIOS/UEFI)，如果依旧无法启动，建议把系统镜像以 ISO 光盘的方式写入到 U 盘中。以下记录各厂商进入 BIOS 的快捷键： 组装机主板 品牌笔记本 品牌台式机 主板品牌 启动按键 笔记本品牌 启动按键 台式机品牌 启动按键 华硕主板 F8 联想笔记本 F12 联想台式机 F12 技嘉主板 F12 弘基笔记本 F12 惠普台式机 F12 微星主板 F11 华硕笔记本 ESC 宏基台式机 F12 映泰主板 F9 惠普笔记本 F9 戴尔台式机 ESC 梅捷主板 ESC或F12 联想Thinkpad F12 神舟台式机 F12 七彩虹主板 ESC或F11 戴尔笔记本 F12 华硕台式机 F8 华擎主板 F11 神舟笔记本 F12 方正台式机 F12 斯巴达主板 ESC 东芝笔记本 F12 清华同方台式机 F12 昂达主板 F11 三星笔记本 F12 海尔台式机 F12 双敏主板 ESC IBM笔记本 F12 明基台式机 F8 翔升主板 F10 富士通笔记本 F12 精英主板 ESC或F11 海尔笔记本 F12 冠盟主板 F11或F12 方正笔记本 F12 富士康主板 ESC或F12 清华同方笔记本 F12 顶星主板 F11或F12 微星笔记本 F11 铭瑄主板 ESC 明基笔记本 F9 盈通主板 F8 技嘉笔记本 F12 捷波主板 ESC Gateway笔记本 F12 Intel主板 F12 eMachines笔记本 F12 杰微主板 ESC或F8 索尼笔记本 ESC 致铭主板 F12 磐英主板 ESC 磐正主板 ESC 冠铭主板 F9 CPU 完全不工作由于 CPU 的做工及其技术导致无法修复，排除 CPU 损坏，尝试更换相同针脚的 CPU 测试。扔了怪可惜的，做成项链还是蛮不错的(上班路上偷拍) PCI-E 接口设备与内存接口氧化虚连电脑无法开机最常见的问题之一，由于 PCI-E 接口设备(例如显卡)和内存氧化或颠簸导致接触不良的虚连，使用主板诊断卡可以检测出具体故障的位置，参考按开机键无反应中故障代码部分。拔出设备使用橡皮擦擦拭金手指部分(解决氧化问题)，重新插好尝试，如问题没有改善，尝试插在其它插槽尝试，或在测试机中测试硬件是否损坏。 (机械)硬盘坏道导致数据丢失或电脑死机机械硬盘比较常见的问题就是磁盘出现坏道，其实一块刚出厂全新的硬盘或多或少的也存在坏道，不过会被厂商隐藏在P表和G表中，使用时根本不会有任何察觉，但是用过一段时间之后硬盘中出现的新的坏道，就是一件麻烦事了，数据丢失可是头等大事，还会造成操作系统的不稳定。如果电脑经常出现一块分区中的数据损坏，或者操作系统异常死机或蓝屏，建议使用 DiskGenius、MHDD 优先检查硬盘。 (机械)硬盘主控板损坏机械硬盘主控盘是暴露在硬盘外面的一部分电路板，损坏少见却存在的情况，我没有直接购买到过主控板，店里工作时都是拿其它损坏的硬盘拆除部件替换尝试。如果没有办法找到相同型号的主控板就不要对修好硬盘抱有希望了，如果硬盘上有重要的数据，还是优先考虑恢复数据吧，由于硬盘已经无法正常运行，需要在无尘环境中拿出盘片放到其它硬盘中拷贝出数据。 (固态)硬盘写入次数达到上限固态提供的飞速同时，就是拥有者写入次数上限的弊端，理论上来说正常使用可能其它硬件比固态先报废，但是我还是遇到过两次，体现为硬盘正常识别，原有的文件可以向外拷贝，但是却无法编辑内容或创建拷贝进新内容，相当于是一次性刻好的光盘，寿命到了无法修复，建议备份好重要文件，留作纪念或是销毁。 系统引导错误无法进入系统在装系统时，或在安装双系统或多系统时或是受病毒感染，可能会存在开机时找不到磁盘引导，首先在 BIOS 中确认可以识别到硬盘，然后通过 U盘进入 WinPE 进行修复，可以使用 DiskGenius 工具重建主引导记录(重建MBR或重建GUID)，双系统或多系统可使用 WinPE 中的引导修复工具。 SATA 线损坏导致无法读取磁盘其实有时数据线比硬盘更容易损坏，曾经在店里干活的时候有这样一段插曲：我在五楼维修，一楼一位惠普的员工带来一对母女来修电脑，他初步检测是硬盘坏了，他跟师娘打了个招呼，这个任务就到我手里了，我首先拿来一块硬盘装好准备重装系统，但是 BIOS 依旧没有识别，顺手就换了一根新的线接上，硬盘识别了，我又把硬盘换回原来的内块，电脑正常运行没有问题，我决定跟师娘确定一下，说明是 SATA 线损坏了而已，其他的都没问题，但是师娘说人家惠普的员工带来的人，说好的换硬盘，就换了硬盘吧，顺便把线也给换掉了。 FAT32 磁盘格式单个文件最大只能支持4GB比较常见的问题，现在新出厂的 U盘或是较老的系统盘(一键四分区)等默认格式化类型还是 FAT32 ，但是由于该类型单个文件最大只能支持4GB，导致一些大文件无法保存，需要重新格式化分区类型为 NTFS。 标记为 RW 的光驱才可以刻录光盘现在光盘在市面上比较少见了，但是在其它地方却有更大的用途，例如 PlayStation/Xbox 还依旧使用蓝光光盘，防盗版的效果还是很棒的！这里仅仅只是记录一下，并不是所有的光驱都可以刻录光盘，只有标记为 RW 的光驱才可以。 由于接口错误或系统设置导致的麦克风或音响失效音频输入输出接口多用颜色区分举例我现在使用的主板是 ASUS PRIME Z390-A 若连接机箱前面板没有声音，检查机箱前面板 Audio 连接线是否正常连接主板上。根据系统以及声卡不同检查对应驱动配置，例： 掐网线及检测网线作为暴露在外部的线材，还是比较脆弱的，比如家里有一只喜欢拆家的小可爱！ 常备一箱网线还是很有必要的，还需要准备网线钳、水晶头、网线测线仪1.以 RJ45 型网线插头的 T568B 线序制作 2.使用网线测线仪检测顺序：百兆网线序 1.2.3.6 亮即为可以联网，千兆网线则需要 8 根线全亮 部分系统安装不包含网卡驱动较为经常出现的情况，Ghost 版本的系统镜像包含的驱动程序包无法驱动网卡，导致无法联网，驱动又需要联网才能安装，推荐提前在官网下载网卡驱动或下载带网卡版的驱动精灵、驱动人生或是更加完整的万能驱动 高压板或驱动板损坏液晶显示器不亮，常见的情况是高压板或驱动板损坏，高压板大部分有通用型号，驱动板尽可能找匹配的型号更换测试即可。 亮点或屏线屏幕出现亮点或屏线是最糟糕不过的情况了，https://www.jscreenfix.com/ 网站提供了一种亮点的解决方案，但是我并没有成功过。 维修建议使用 PS/2 接口虽然现在主流的外设都是 USB 接口，但是不得不说 PS/2 接口依旧很强大，很多机械键盘通过 PS/2 接口连接可以支持更多键无冲突，在维修的时候，有极个别主板在 BIOS 时不识别 USB 外设。 (机械)键盘轴脱焊虽然说 Cherry 官网给出的理论寿命有5000万次，但是也难免有按到轴脱焊的情况，不妨重新焊一下吧。 鼠标连键(单击变双击)鼠标用久了就会出现连键的情况，单击变双击，打英雄联盟新买的中亚沙漏还没出门拖动一下就被用掉了，不舍得扔掉就换个微动吧，很便宜的，邮费比产品贵系列。 外置 USB 供电的音响出现杂音新买的小音箱使用 USB 独立供电，接在电脑主板上或是 Switch 的底座上就会滋滋滋的响个不停，还是老老实实的接个充电头插在插排上吧。 游戏手柄连接数据线虚连之前朋友送的一个 Xbox 360 手柄用的太久了出现时断时连的情况，检查一圈是连接的数据线虚连了，换了一根线就好了，后出的 Xbox One 手柄已经改成无线连接了，点个赞！ 电脑温度过高大部分的电脑还是采用风冷散热，难免的吸灰，清理风扇上的灰尘，或更换风扇，定期更换硅脂。 电脑电压不稳国内普遍电压为 220V，但是由于建筑原因，难免有些地区电压不稳定，导致电源的负荷过大，建议在电脑前安装不间断电源(UPS) 系统软件或应用软件导致驱动异常微软给出的意见是蓝屏大多由内存或驱动异常导致，检查每个软件的运行是否对驱动程序的运行造成了影响。当然可以准备一块完好的硬盘装一个熟悉的系统，排除一下是否是硬件原因导致。]]></content>
      <categories>
        <category>Repair</category>
      </categories>
      <tags>
        <tag>repair</tag>
        <tag>computer</tag>
        <tag>hardware</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 使用 VPN 代理加速]]></title>
    <url>%2Fblog%2F2020%2F01%2F30%2Fsystem-VPNGitAgent%2F</url>
    <content type="text"><![CDATA[解决国内 Github 访问过慢 简介开了 VPN 之后使用 Git 连接 github 的 clone pull push 命令依旧很慢，是由于 git 默认不使用代理导致，配置 git 代理后可提升速度。 配置方法查找 VPN 本地代理端口以 MonoCloud 为例，由于不同 vpn 软件或安装的随机性导致每台机器的端口号并不一致，以显示为准。 MacOS当前显示 http 端口为：8118；socks5 端口为：8119； Windows当前显示 http 与 socks5 端口为：7078； 配置 Git 代理1234567git config --global http.proxy http://127.0.0.1:&#123;port&#125;git config --global https.proxy http://127.0.0.1:&#123;port&#125;或git config --global http.proxy socks5://127.0.0.1:&#123;port&#125;git config --global https.proxy socks5://127.0.0.1:&#123;port&#125; 配置成功后可尝试查询配置或重新使用 git 命令 查询配置123456git config --global --list或git config --global --get http.proxygit config --global --get https.proxy 取消 Git 代理配置12git config --global --unset http.proxygit config --global --unset https.proxy 异常错误报错 Connection refused1fatal: unable to access 'https://github.com/*/*.git/': Failed to connect to 127.0.0.1 port 7071: Connection refused VPN 的本地映射端口配置错误，检查映射端口配置的正确性，或取消代理。]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>windows</tag>
        <tag>macos</tag>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VPN 导致的网页显示异常]]></title>
    <url>%2Fblog%2F2020%2F01%2F28%2Fsystem-VPNWebpageAbnormal%2F</url>
    <content type="text"><![CDATA[未启动 VPN 程序时网络正常，网页显示异常 简介电脑装有梯子软件，但是有时存在未启动程序时网络正常，但是网页显示异常的情况，由于安装过 VPN 后软件设置了默认代理导致。 解决方法 打开 Internet 选项，可通过 IE 设置中打开或通过运行输入打开 1inetcpl.cpl 选择菜单： 连接 → 局域网(LAN)设置 → 局域网设置(L) 取消勾选： 代理服务器 → 为 LAN 使用代理服务器(这些设置不用于拨号或 VPN 连接)(X) 确认应用保存]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>vpn</tag>
        <tag>ie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SonarQube 使用介绍]]></title>
    <url>%2Fblog%2F2020%2F01%2F16%2Fsoftware-SonarQube%2F</url>
    <content type="text"><![CDATA[简介SonarQube 是一个用于管理代码质量和安全的开源平台。 软件部署软件安装参考 官方文档使用版本 SonarQube 7.9.x LTS 下载社区版本下载地址：https://www.sonarqube.org/downloads/ 解压后运行批处理文件按顺序运行：123.\sonarqube\bin\windows-x86-64\InstallNTService.bat.\sonarqube\bin\windows-x86-64\StartNTService.bat.\sonarqube\bin\windows-x86-64\StartSonar.bat 访问网页http://localhost:9000/默认用户名密码：admin:admin Create new project创建新项目 生成 ToKen 令牌 项目根目录运行.NET Framework安装 SonarScanner for MSBuild解压后配置环境变量 Path1234:: 生成 SonarQubeSonarScanner.MSBuild.exe begin /k:"#ProjectName" /d:sonar.host.url="http://localhost:9000" /d:sonar.login="#ToKen"MsBuild.exe /t:RebuildSonarScanner.MSBuild.exe end /d:sonar.login="#ToKen" .NET Core12:: 安装 netcore sonarqube 工具dotnet tool install --global dotnet-sonarscanner 1234:: 生成 SonarQubedotnet sonarscanner begin /k:"#ProjectName" /d:sonar.host.url="http://localhost:9000" /d:sonar.login="#ToKen"MsBuild.exe /t:Rebuilddotnet sonarscanner end /d:sonar.login="#ToKen" 查看质检结果 Jenkins 中集成 SonarQube参考：集成 SonarQube]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>sonarqube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ Demo]]></title>
    <url>%2Fblog%2F2019%2F12%2F31%2Fcsharp-ActiveMQ%2F</url>
    <content type="text"><![CDATA[ActiveMQ 消息队列使用介绍 简介Apache ActiveMQ 是一个开放源代码的消息中间件。 安装部署请参阅官方文档 Docker 部署123456安装官方镜像docker pull webcenter/activemq启动 RabbitMQ 默认账户密码为 admin/admindocker run -d --name myactivemq -p 61617:61616 -p 8162:8161 webcenter/activemqWEB 端登录http://localhost:8162/ 遇到问题未找到 61616 端口错误信息：1Apache.NMS.NMSConnectionException: Error connecting to localhost:61616. ---&gt; System.Net.Sockets.SocketException: Unknown error (0xfffffffe) 使用命令查询端口号占用进程12netstat -ano|findstr "PORT"tasklist|findstr "PID" 未查到 61616 端口使用，但是开启了 61617 端口 C#代码调用引用 Apache.NMS.ActiveMQ 库 生产者1234567891011121314151617181920212223242526272829303132333435363738394041using Apache.NMS;using Apache.NMS.ActiveMQ;using System;class Program&#123; static void Main(string[] args) &#123; try &#123; //Create the Connection Factory IConnectionFactory factory = new ConnectionFactory("tcp://localhost:61617/"); using (IConnection connection = factory.CreateConnection()) &#123; //Create the Session using (ISession session = connection.CreateSession()) &#123; //Create the Producer for the topic/queue IMessageProducer prod = session.CreateProducer(new Apache.NMS.ActiveMQ.Commands.ActiveMQTopic("testing")); //Send Messages int i = 0; while (!Console.KeyAvailable) &#123; ITextMessage msg = prod.CreateTextMessage(); msg.Text = i.ToString(); Console.WriteLine("Sending: " + i.ToString()); prod.Send(msg, Apache.NMS.MsgDeliveryMode.NonPersistent, Apache.NMS.MsgPriority.Normal, TimeSpan.MinValue); System.Threading.Thread.Sleep(5000); i++; &#125; &#125; &#125; Console.ReadLine(); &#125; catch (System.Exception e) &#123; Console.WriteLine("&#123;0&#125;", e.Message); Console.ReadLine(); &#125; &#125;&#125; 消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using Apache.NMS;using Apache.NMS.ActiveMQ;using System;class Program&#123; static void Main(string[] args) &#123; try &#123; //Create the Connection factory IConnectionFactory factory = new ConnectionFactory("tcp://localhost:61617/"); //Create the connection using (IConnection connection = factory.CreateConnection()) &#123; connection.ClientId = "testing listener"; connection.Start(); //Create the Session using (ISession session = connection.CreateSession()) &#123; //Create the Consumer IMessageConsumer consumer = session.CreateDurableConsumer(new Apache.NMS.ActiveMQ.Commands.ActiveMQTopic("testing"), "testing listener", null, false); consumer.Listener += new MessageListener(consumer_Listener); Console.ReadLine(); &#125; connection.Stop(); connection.Close(); &#125; &#125; catch (System.Exception e) &#123; Console.WriteLine(e.Message); &#125; &#125; static void consumer_Listener(IMessage message) &#123; try &#123; ITextMessage msg = (ITextMessage)message; Console.WriteLine("Receive: " + msg.Text); &#125; catch (System.Exception e) &#123; Console.WriteLine(e.Message); &#125; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>activemq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 使用介绍]]></title>
    <url>%2Fblog%2F2019%2F12%2F26%2Fsoftware-Jenkins%2F</url>
    <content type="text"><![CDATA[简介Jenkins 是一个持续集成（CI&amp;CD）工具，用以构建、部署、自动化。 运行流程以部署PC客户端软件为例：1.连接 GitLab 仓库 pull 最新代码2.使用 NuGet 还原引用库3.使用 MSBuild 编译项目工程4.使用 NSIS 打包软件为安装包5.以邮件方式将打包文件发送(未完成) 软件部署软件安装参考 官方文档 遇到的问题插件安装失败登录重启页重启后重试http://localhost:8081/restart 需安装 Jenkins 插件Git、MSBuild、NuGet、PowerShell 配置系统环境变量Path 下增加 MSBuild 路径：..\Microsoft Visual Studio\2019\Preview\MSBuild\Current\Bin\amd64 NuGet 控制台程序下载https://www.nuget.org/downloads下载后拷贝至 Path 环境变量中 构建Pull Git 代码填写 Git 地址以及分支名称即可 设置 Git 用户名密码如果本地 Git 记录用户无权限访问则会报错：1234Failed to connect to repository : Command "git.exe ls-remote -h -- http://192.168.5.188:9090/***/***.git HEAD" returned status code 128:stdout:stderr: remote: HTTP Basic: Access deniedfatal: Authentication failed for 'http://192.168.5.188:9090/***/***.git/' 选择：凭据→系统→全局凭据 选择：添加凭据 配置：Git 用户名密码 配置：Credentials 中选择添加的凭据 还原 NuGet 包构建中选择：执行 Windows 批处理程序1234:: 清空项目中多余文件git checkout . &amp;&amp; git clean -xdf:: nuget 引用nuget restore project.sln 编译代码(客户端)构建中选择：Build a Visual Studio project or solution using MSBuild function value MSBuild Version Default MSBuild Build File project.sln Command Line Arguments /t:Build /p:Configuration=Release;VisualStudioVersion=16.3 编译时如需选择解决方案配置和解决方案平台123456:: 解决方案配置“Release|Any CPU”MSBuild project.sln /property:Configuration=Release:: 解决方案配置“Debug|x86”MSBuild project.sln /property:Configuration=Debug /property:Platform=x86:: 解决方案配置“Release|x64”MSBuild project.sln /property:Configuration=Release /property:Platform=x64 编译代码(服务端)调用发布文件 .\Properties\PublishProfiles\FolderProfile.pubxml测试 MSBuild 命令中加入 VisualStudioVersion=16.3 会导致不会生成发布目录123456789101112131415161718&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!--此文件由 Web 项目的发布/打包过程使用。可以通过编辑此 MSBuild 文件自定义此过程的行为。为了解与此相关的更多内容，请访问 https://go.microsoft.com/fwlink/?LinkID=208121。 --&gt;&lt;Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003"&gt; &lt;PropertyGroup&gt; &lt;WebPublishMethod&gt;FileSystem&lt;/WebPublishMethod&gt; &lt;PublishProvider&gt;FileSystem&lt;/PublishProvider&gt;3 &lt;LastUsedBuildConfiguration&gt;Release&lt;/LastUsedBuildConfiguration&gt; &lt;LastUsedPlatform&gt;Any CPU&lt;/LastUsedPlatform&gt; &lt;SiteUrlToLaunchAfterPublish /&gt; &lt;LaunchSiteAfterPublish&gt;True&lt;/LaunchSiteAfterPublish&gt; &lt;ExcludeApp_Data&gt;False&lt;/ExcludeApp_Data&gt; &lt;publishUrl&gt;.\bin\Release\PublishOutput&lt;/publishUrl&gt; &lt;DeleteExistingFiles&gt;True&lt;/DeleteExistingFiles&gt; &lt;/PropertyGroup&gt;&lt;/Project&gt; function value MSBuild Version Default MSBuild Build File project.sln Command Line Arguments /t:Build /p:Configuration=Release /p:DeployOnBuild=True /p:PublishProfile=FolderProfile 拷贝或删除多余文件123456:: 拷贝文件xcopy /s/c/h/y .\9.Reference\MediaAccessSDK\Release .\bin\Release\MediaAccessSDK\Release\:: 删除多余的pdb和xmldel /s bin\Release\*.pdbdel /s bin\Release\*.xml 程序打包构建中选择：执行 Windows 批处理程序NSIS 使用参考：使用介绍12:: 调用 makensis 命令构建 NSImakensis PanoramaClientSetup.nsi 压缩文件打包构建中选择：PowerShell123456# 调用 PowerShell 命令压缩文件# 压缩文件Compress-Archive -Path .\test -DestinationPath .\test.zip# 解压缩文件Expand-Archive -Path .\test.zip -DestinationPath .\test 构建后操作归档成品在归档成品中直接写入打包好的安装包名称，会在构建结束后在结果中显示并可以直接下载 FAQ提示 ‘xxx’ 不是内部或外部命令，也不是可运行的程序或批处理文件。通常这个提示代表着环境变量配置错误，但是检测时发现系统环境变量配置正常，可以在 Jenkins 目录中手动执行命令操作，重启电脑和 Jenkins 后依然无效。解决方式：选择 Jenkins → 左下角“构建执行状态” → 右侧齿轮标志“设置” → 节点属性 → 新增“Environment variables” → 拷贝报错(或全部)的环境变量到此处 → 保存 无法识别环境变量中的：%SystemRoot%\，改用绝对路径。 集成 SonarQube安装使用 SonarQube 参考博客：SonarQube 使用介绍 SonarQube 创建 Jenkins ToKen 下载插件 SonarQube Scanner Jenkins 配置 SonarQube添加凭据： 配置插件 SonarQube Scanner系统管理→系统配置→SonarQube servers 配置插件 SonarQube Scanner系统管理→全局工具配置→SonarQube Scanner 配置插件 SonarScanner for MSBuild系统管理→全局工具配置→SonarScanner for MSBuild 配置插件 JDK系统管理→全局工具配置→JDK 构建项目增加配置：构建中选择：SonarScanner for MSBuild - Begin Analyoio配置项 Project key 与 Project name 与 创建 SonarQube 中的 Project key 与 Project name 对应在 MSBuild 后选择： SonarScanner for MSBuild - End Analyoio]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArcGIS API for JavaScript 使用介绍]]></title>
    <url>%2Fblog%2F2019%2F11%2F04%2Fsoftware-ArcGisForJS%2F</url>
    <content type="text"><![CDATA[简介现工作中 GIS 地图使用客户提供的 AutoCAD 图纸提取图层到 ArcGIS 中导出图片模拟 GIS 显示，存在一定弊端（1.不包含经纬度数据，需要进行图像标定坐标转换；2.图像中边线粗的越放大越粗，边线细的缩放时不足一像素颜色减淡。），尝试以客户端加载 WebJS 的方式使用 GIS。 搭建环境基于 ArcGIS 提供的桌面端（用于编辑地图），服务端（用于发布地图服务）以及 ArcGIS API for JavaScript（开发 WebJS）。 搭建 ArcGIS Server 10.2参考资料 安装后默认值地图服务地址：http://localhost:6080/arcgis/manager/地图服务账号：siteadmin 搭建 ArcGIS Desktop 10.2参考资料 地图服务发布1.编辑好的地图保存为 .mxd 格式 2.在 ArcMap 目录中选择 GIS 服务器 → 添加 ArcGIS Server → 发布 GIS 服务选择发布 GIS 服务 设置服务器 URL 与用户名密码 4.在 ArcMap 目录中选择 .mxd 文件右键选择：共享为服务(S)…选择发布服务 设置服务名称 默认发布为根 1.点击分析，解决错误（例：图层坐标系异常）；2.发布 选择发布图层等待服务发布 ArcGIS Server Manager 中查看服务 搭建 ArcGIS API for JavaScript未完成]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>arcgis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cat062 报文解析]]></title>
    <url>%2Fblog%2F2019%2F10%2F15%2Fcsharp-Cat062118%2F</url>
    <content type="text"><![CDATA[Radar CAT062 1.18 报文协议解析 简介/声明Radar 雷达，源于radio detection and ranging的缩写，意思为”无线电探测和测距”，即用无线电的方法发现目标并测定它们的空间位置。因此，雷达也被称为“无线电定位”。雷达是利用电磁波探测目标的电子设备。雷达发射电磁波对目标进行照射并接收其回波，由此获得目标至电磁波发射点的距离、距离变化率（径向速度）、方位、高度等信息。 解析文档均为欧洲航空交通管理官方提供。 参考资料原文EuroControl：cat062p9ed118.pdf 测试数据解析3E0034BB7D25040203000E584F003806E501460641FD2601B70D4A000D33B3C37E2080780CCB000601000550000028002A003E04 解析步骤数据格式 CAT = 062 LEN FSPEC Items of the first record 解析报文区域数据 16进制代码 解析值（二进制或十进制） 备注 0x3E 62 报文头，转换十进制为62 0x00 00 报文长度起始位 0x34 52 报文长度 LEN，为报文数据字节数 0xBB 10111011 I062/010、I062/015、I062/070、I062/105、I062/185 0x7D 01111101 I062/060、I062/245、I062/380、I062/040、I062/080 0x25 00100101 I062/136、I062/220、 0x04 00000100 I062/500 02 2 03 3 I062/010 00 0 I062/015 0E 14 58 88 4F 79 I062/070 日时间项 00 0 38 56 06 6 E5 229 01 1 46 70 06 6 41 65 I062/105 经纬度坐标 FD 253 26 38 01 1 B7 183 I062/185 0D 13 4A 74 I062/060 00 0 0D 13 33 51 B3 179 C3 195 7E 126 20 32 I062/245 目标识别 80 128 I062/380 78 120 0C 12 I062/040 CB 203 00 0 I062/080 06 6 01 1 I062/136 00 0 05 5 I062/220 50 80 I062/500 00 00 28 00 2A 00 3E 04 代码(部分解析可参考Cat020) I062/070123456789101112131415161718192021/// &lt;summary&gt;/// 计算日时间项(I062/070)对应的值/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string I062_070(byte[] byteData)&#123; //将几个独立字节合并为一个字节 uint rhs = ((uint)byteData[0] &lt;&lt; 16) + ((uint)byteData[1] &lt;&lt; 8) + byteData[2]; //总秒数 uint value0 = rhs / 128; //小时数 uint value1 = value0 / 3600; //分钟数 uint value2 = (value0 - value1 * 3600) / 60; //秒数 uint value3 = (value0 - value1 * 3600) % 60; //毫秒数 uint value4 = ((rhs % 128) * 1000) / 128; return $"&#123;DateTime.Now.ToShortDateString()&#125; &#123;value1&#125;:&#123;value2&#125;:&#123;value3&#125;.&#123;value4&#125;";&#125; I062/245123456789101112131415161718192021222324252627282930313233/// &lt;summary&gt;/// 解析(I062_245)目标识别/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string I062_245(byte[] byteData)&#123; string str = ""; for (int i = 1; i &lt; byteData.Length; i++) &#123; // 把第一位去掉 str += Convert.ToString(byteData[i], 2).PadLeft(8, '0'); &#125; char[] strCharArray = str.ToCharArray(); string flno2BinaryStr = ""; string result = ""; for (int i = 0; i &lt; strCharArray.Length; i++) &#123; flno2BinaryStr += strCharArray[i] + ""; if ((i + 1) % 6 == 0) &#123; string flightNumberValue = Constants.flightNumberMap[flno2BinaryStr]; if (!string.IsNullOrEmpty(flightNumberValue)) &#123; result += flightNumberValue; &#125; flno2BinaryStr = ""; &#125; &#125; return result;&#125; I062/1051234567891011121314151617181920/// &lt;summary&gt;/// 解析(I062_070)经纬度坐标/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double[] I062_105(byte[] byteData)&#123; double[] relDataArray = new double[2]; if (byteData.Length == 8) &#123; // 16进制转成10进制（4位一转） string xCoordinate10 = byteData[0].ToString("X2") + byteData[1].ToString("X2") + byteData[2].ToString("X2") + byteData[3].ToString("X2"); string yCoordinate10 = byteData[4].ToString("X2") + byteData[5].ToString("X2") + byteData[6].ToString("X2") + byteData[7].ToString("X2"); // 10进制计算规则（xCoordinate10 * 180 /2^25） relDataArray[0] = double.Parse(Convert.ToInt32(xCoordinate10, 16).ToString()) * 180 / 33554432; relDataArray[1] = double.Parse(Convert.ToInt32(yCoordinate10, 16).ToString()) * 180 / 33554432; return relDataArray; &#125; return null;&#125; I062/100123456789101112131415161718192021/// &lt;summary&gt;/// 解析(I062_100)卡迪尔坐标/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double[] I062_100(byte[] byteData)&#123; double[] relDataArray = new double[2]; if (byteData.Length == 6) &#123; string xAngle16 = byteData[0].ToString("X2") + byteData[1].ToString("X2") + byteData[2].ToString("X2"); string yAngle16 = byteData[3].ToString("X2") + byteData[4].ToString("X2") + byteData[5].ToString("X2"); string xAngle10 = Convert.ToInt32(xAngle16, 16).ToString(); string yAngle10 = Convert.ToInt32(yAngle16, 16).ToString(); // 10进制计算规则（xAngle10 * 0.5） relDataArray[0] = double.Parse(xAngle10) * 0.5; relDataArray[1] = double.Parse(yAngle10) * 0.5; return relDataArray; &#125; return null;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kafka Demo]]></title>
    <url>%2Fblog%2F2019%2F09%2F16%2Fcsharp-Kafka%2F</url>
    <content type="text"><![CDATA[Kafka 消息队列使用介绍 简介Apache Kafka 是一个分布式流平台。 流平台具有三个关键功能： 发布和订阅记录流，类似于消息队列或企业消息传递系统。 以容错的持久方式存储记录流。 处理记录流。 Kafka通常用于两大类应用程序： 建立实时流数据管道，以可靠地在系统或应用程序之间获取数据 构建实时流应用程序以转换或响应数据流安装部署请参阅官方文档C#代码调用引用 Confluent.Kafka 库生产者1234567891011121314151617181920212223242526using System;using Confluent.Kafka;class Program&#123; public static void Main(string[] args) &#123; var conf = new ProducerConfig &#123; BootstrapServers = "localhost:9092" &#125;; Action&lt;DeliveryReport&lt;Null, string&gt;&gt; handler = r =&gt; Console.WriteLine(!r.Error.IsError ? $"Delivered message to &#123;r.TopicPartitionOffset&#125;" : $"Delivery Error: &#123;r.Error.Reason&#125;"); using (var p = new ProducerBuilder&lt;Null, string&gt;(conf).Build()) &#123; for (int i=0; i&lt;100; ++i) &#123; p.Produce("my-topic", new Message&lt;Null, string&gt; &#123; Value = i.ToString() &#125;, handler); &#125; // wait for up to 10 seconds for any inflight messages to be delivered. p.Flush(TimeSpan.FromSeconds(10)); &#125; &#125;&#125; 消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253using System;using System.Threading;using Confluent.Kafka;class Program&#123; public static void Main(string[] args) &#123; var conf = new ConsumerConfig &#123; GroupId = "test-consumer-group", BootstrapServers = "localhost:9092", // Note: The AutoOffsetReset property determines the start offset in the event // there are not yet any committed offsets for the consumer group for the // topic/partitions of interest. By default, offsets are committed // automatically, so in this example, consumption will only start from the // earliest message in the topic 'my-topic' the first time you run the program. AutoOffsetReset = AutoOffsetReset.Earliest &#125;; using (var c = new ConsumerBuilder&lt;Ignore, string&gt;(conf).Build()) &#123; c.Subscribe("my-topic"); CancellationTokenSource cts = new CancellationTokenSource(); Console.CancelKeyPress += (_, e) =&gt; &#123; e.Cancel = true; // prevent the process from terminating. cts.Cancel(); &#125;; try &#123; while (true) &#123; try &#123; var cr = c.Consume(cts.Token); Console.WriteLine($"Consumed message '&#123;cr.Value&#125;' at: '&#123;cr.TopicPartitionOffset&#125;'."); &#125; catch (ConsumeException e) &#123; Console.WriteLine($"Error occured: &#123;e.Error.Reason&#125;"); &#125; &#125; &#125; catch (OperationCanceledException) &#123; // Ensure the consumer leaves the group cleanly and final offsets are committed. c.Close(); &#125; &#125; &#125;&#125; 遇到问题在实际使用中消费数据使用多服务器链接追加配置多 IP 地址到 Hosts 文件中（例）：123456172.26.78.135 tdh02172.26.78.136 tdh03172.26.78.137 tdh04172.26.78.140 tdh07172.26.78.141 tdh08172.26.78.142 tdh09 Host 文件所在目录：| 系统 | 目录 || —- | —- || Windows | C:\windows\system32\drivers\etc\Hosts || Linux / Unix | /etc/Hosts || Mac OS | /private/etc/Hosts |修改部分代码：123456var conf = new ConsumerConfig&#123; GroupId = "test-consumer-group", BootstrapServers = "tdh02:9092,tdh03:9092,tdh04:9092,tdh07:9092,tdh08:9092,tdh09:9092", AutoOffsetReset = AutoOffsetReset.Earliest&#125;;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cat020 报文解析]]></title>
    <url>%2Fblog%2F2019%2F09%2F09%2Fcsharp-Cat020015%2F</url>
    <content type="text"><![CDATA[MLAT CAT020 0.15 报文协议解析 简介/声明多点定位(MLAT) 全称是 Multilateration，多点定位技术利用多个地面接收机接收到机载应答机信号的时间差，计算得出飞机位置。 解析文档均为欧洲航空交通管理官方提供。 参考资料原文EuroControl：cat020p14ed15.pdf 测试数据解析14 00 46 FF 0F 01 84 16 07 41 10 A1 A0 BB 00 57 8B 48 01 44 DC F6 00 17 06 00 1F AD 0E F2 02 78 10 45 80 0C 54 F2 DB 3C 60 00 02 20 40 19 98 D0 00 00 00 00 00 01 00 0C 00 0C 00 03 00 06 00 05 00 05 A1 A0 C2 00 解析步骤数据格式 CAT = 020 LEN FSPEC Items of the first record 解析报文区域数据 16进制代码 解析值（二进制或十进制） 备注 0x14 20 报文头，转换十进制为20 0x00 00 报文长度起始位 0x46 70 报文长度 LEN，为报文数据字节数，两个字节表示，该报文长度为0x00*256+0x46=0x46=70字节 FF 1111 1111 I020/010、I020/020、I020/140、I020/041、I020/042、I020/161、I020/170 0F 0000 1111 I020/220、I020/245、I020/110 01 0000 0001 84 1000 0100 I020/230、RE 16 22 07 7 I020/010 数据源的标识符 41 65 10 16 I020/020 目标报告描述符 A1 161 A0 160 BB 187 I020/140 日时间项 00 0 57 87 8B 139 48 72 01 1 44 68 DC 220 F6 246 I020/041 位置坐标（WGS-84）项 00 0 17 23 06 6 00 0 1F 31 AD 173 I020/042 在笛卡尔坐标中的位置 0E 14 F2 242 I020/161 跟踪号码 02 2 I020/170 追踪发送状态 78 120 10 16 45 69 I020/220 目标地址 80 128 0C 12 54 84 F2 242 DB 219 3C 60 60 96 I020/245 目标识别 航班号 00 0 02 2 I020/110 测量高度(笛卡尔坐标) 20 32 40 64 I020/230 通讯/自动识别系统的能力和飞行状态 19 98 D0 00 00 00 00 00 01 00 0C 00 0C 00 03 00 06 00 05 00 05 A1 A0 C2 00 代码 I020/1401234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// 解析I020_140日时间/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string I020_140(byte[] byteData)&#123; // 16进制转成10进制 string timeDec = (((uint)byteData[0] &lt;&lt; 16) + ((uint)byteData[1] &lt;&lt; 8) + byteData[2]).ToString(); // 字符串转数值/128 * 1000 总毫秒数 long ms = (long)((double.Parse(timeDec) / 128) * 1000); int ss = 1000; int mi = ss * 60; int hh = mi * 60; long hour = ms / hh; long minute = (ms - hour * hh) / mi; long second = (ms - hour * hh - minute * mi) / ss; long milliSecond = ms - hour * hh - minute * mi - second * ss; // 小时 string strHour = hour &lt; 10 ? "0" + hour : "" + hour; // 分钟 string strMinute = minute &lt; 10 ? "0" + minute : "" + minute; // 秒 string strSecond = second &lt; 10 ? "0" + second : "" + second; // 毫秒 string strMilliSecond = milliSecond &lt; 10 ? "0" + milliSecond : "" + milliSecond; strMilliSecond = milliSecond &lt; 100 ? "0" + strMilliSecond : "" + strMilliSecond; //增加UTC时间 strHour = int.Parse(strHour) + 8 &gt; 24 ? (int.Parse(strHour) + 8 - 24).ToString() : (int.Parse(strHour) + 8).ToString(); return $"&#123;DateTime.Now.ToShortDateString()&#125; &#123;strHour&#125;:&#123;strMinute&#125;:&#123;strSecond&#125;.&#123;strMilliSecond&#125;";&#125; I020/245123456789101112131415161718192021222324252627282930313233/// &lt;summary&gt;/// 解析I020/245目标识别/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string I020_245(byte[] byteData)&#123; string str = ""; for (int i = 1; i &lt; byteData.Length; i++) &#123; // 把第一位去掉 str += Convert.ToString(byteData[i], 2).PadLeft(8, '0'); &#125; char[] strCharArray = str.ToCharArray(); string flno2BinaryStr = ""; string result = ""; for (int i = 0; i &lt; strCharArray.Length; i++) &#123; flno2BinaryStr += strCharArray[i] + ""; if ((i + 1) % 6 == 0) &#123; string flightNumberValue = flightNumberMap[flno2BinaryStr]; if (!string.IsNullOrEmpty(flightNumberValue)) &#123; result += flightNumberValue; &#125; flno2BinaryStr = ""; &#125; &#125; return result;&#125; NOTE: See ICAO document Annex 10, Volume IV, section 3.1.2.9for the coding rules.每六字节代表一个字母或数字 I020/0411234567891011121314151617181920/// &lt;summary&gt;/// 解析I020_041在WGS-84中的坐标位置/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double[] I020_041(byte[] byteData)&#123; double[] relDataArray = new double[2]; if (byteData.Length == 8) &#123; // 16进制转成10进制（4位一转） string xCoordinate10 = byteData[0].ToString("X2") + byteData[1].ToString("X2") + byteData[2].ToString("X2") + byteData[3].ToString("X2"); string yCoordinate10 = byteData[4].ToString("X2") + byteData[5].ToString("X2") + byteData[6].ToString("X2") + byteData[7].ToString("X2"); // 10进制计算规则（xCoordinate10 * 180 /2^25） relDataArray[0] = double.Parse(Convert.ToInt32(xCoordinate10, 16).ToString()) * 180 / 33554432; relDataArray[1] = double.Parse(Convert.ToInt32(yCoordinate10, 16).ToString()) * 180 / 33554432; return relDataArray; &#125; return null;&#125; I020/04212345678910111213141516171819202122/// &lt;summary&gt;/// 解析I020_042轨道位置(直角)/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double[] I020_042(byte[] byteData)&#123; double[] relDataArray = new double[2]; if (byteData.Length == 6) &#123; // 16进制转成10进制 string xAngle16 = byteData[0].ToString("X2") + byteData[1].ToString("X2") + byteData[2].ToString("X2"); string yAngle16 = byteData[3].ToString("X2") + byteData[4].ToString("X2") + byteData[5].ToString("X2"); string xAngle10 = Convert.ToInt32(xAngle16, 16).ToString(); string yAngle10 = Convert.ToInt32(yAngle16, 16).ToString(); // 10进制计算规则（xAngle10 * 0.5） relDataArray[0] = double.Parse(xAngle10) * 0.5; relDataArray[1] = double.Parse(yAngle10) * 0.5; return relDataArray; &#125; return null;&#125; I020/161123456789/// &lt;summary&gt;/// 解析I020_161/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static int I020_161(byte[] byteData)&#123; return Convert.ToInt32(byteData[0].ToString("X2") + byteData[1].ToString("X2"), 16);&#125; I020/110123456789101112131415161718192021/// &lt;summary&gt;/// 解析I020_110/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double I020_110(byte[] byteData)&#123; string strByteData = byteData[0].ToString("X2") + byteData[1].ToString("X2"); double dByteData = Convert.ToInt32(strByteData, 16); if (Convert.ToString(byteData[0], 2).Substring(0, 1).Equals("1")) &#123; // 如果2进制长度为16，说明第16位一定为1，则为负数 return -(Math.Pow(2, 16) - dByteData) * 6.25; &#125; else &#123; // 如果2进制长度不为16，说明第16位一定为0，则为正数 return dByteData * 6.25; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析-航空公司]]></title>
    <url>%2Fblog%2F2019%2F08%2F20%2Fdata-AirlineCompany%2F</url>
    <content type="text"><![CDATA[航空公司数据分析 简介为便于组织运输生产，每个航班都按照一定的规律编有不同的号码以便于区别和管理，这种号码称为航班号。 参考资料航班号编排方式参考 2004 年中国民用航空局发布政府公文：关于印发《中国民航航班号分配和使用方案》的通知 航班号组成航空公司代码由民航局规定发布，包含 IATA 发布的二字码和 ICAO 发布的三字码，航班号使用的是二字码加四或三位阿拉伯数字组成(不同的设备可能使用不同的标准)，还有各个航空公司向民航局自己登记的呼号，用于无线电通讯中使用的代号。 爬虫爬取携程网航空公司二字码LOGO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# _*_coding:utf-8_*_import requestsimport reimport osclass GetImage(object): def __init__(self, url): self.url = url self.headers = &#123; 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36' &#125; self.dir_path = os.path.dirname(os.path.abspath(__file__)) self.path = self.dir_path+'/imgs' isExists = os.path.exists(self.dir_path+'/imgs') # 创建目录 if not isExists: os.makedirs(self.path) def download(self, url): try: res = requests.get(url, headers=self.headers) return res except Exception as e: print(url+'下载失败,原因:'+e.args) def save(self, res_img, file_name): if res_img: with open(file_name, 'wb') as f: f.write(res_img.content) print(url+'下载成功') def run(self): # 下载图片 res_img = self.download(self.url) name = self.url.strip().split('/').pop() file_name = self.path+'/'+name # 保存 self.save(res_img, file_name)if __name__ == '__main__': url_list = [] Letter = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '1', '2', '3', '4', '5', '6', '7', '8', '9', '0'] for i in Letter: for j in Letter: url_list.append( "http://pic.c-ctrip.com/AssetCatalog/airline/32/" + i + j + ".png") for url in url_list: print(url) text = GetImage(url) text.run() 航空公司信息查询下载：航空公司信息.xlsx]]></content>
      <categories>
        <category>Data</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>data</tag>
        <tag>aviation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cat021 报文解析]]></title>
    <url>%2Fblog%2F2019%2F08%2F19%2Fcsharp-Cat021026%2F</url>
    <content type="text"><![CDATA[ADS-B CAT021 0.26 报文协议解析 简介/声明ADS-B 全称是Automatic Dependent Surveillance - Broadcast，中文是广播式自动相关监视，即无需人工操作或者询问，可以自动地从相关机载设备获取飞机或地面站广播飞机的位置、高度、速度、航向、识别号等参数信息，以供管制员对飞机状态进行监控。它衍生于ADS（自动相关监视），最初是为越洋飞行的航空器在无法进行雷达监视的情况下，希望利用卫星实施监视所提出的解决方案。 解析文档均为欧洲航空交通管理官方提供。 参考资料原文EuroControl：cat021p12ed026.pdf 测试数据解析15002efba1df80000100302327660055a0b60144ae0a7802610006080388000a077e043e0d33b3c72de000800002 解析步骤数据格式 CAT = 021 LEN FSPEC Items of the first record 解析报文区域数据 16进制代码 解析值（二进制或十进制） 备注 0x15 21 报文头，转换十进制为21 0x00 00 报文长度起始位 0x2e 46 报文长度 LEN，为报文数据字节数，两个字节表示，该报文长度为0x00*256+0x2e=0x2e=46字节 0xfb 1111 1011 1021/010，1021/040，1021/030，1021/130，1021/080，1021/090 0xa1 1010 0001 1021/210，1021/145 0xdf 1101 1111 1021/157，1021/160，1021/170，1021/095，1021/032，1021/200 0x80 1000 0000 1021/020（FSPEC 字段，该字段可变，(x&lt;&lt;=7;x&gt;&gt;=7)==0 下一条数据不为 FSPEC） 0x00 0x01 1021/010 0x00 0x30 1021/040 0x23 35 0x27 39 0x66 102 1021/030 日时间项 0x00 0 0x55 85 0xa0 160 0xb6 182 0x01 1 0x44 68 0xae 174 0x0a 10 1021/130 位置坐标（WGS-84）项，前四位为纬度值，后四位为经度值 0x78 120 0x02 2 0x61 97 1021/080 目标地址项 0x00 0x06 1021/090 0x08 1021/210 0x03 0x88 1021/145 0x00 0 0x0a 10 1021/157 0x07 0x7e 0x04 0x3e 1021/160 0x0d 13 0x33 51 0xb3 179 0xc7 199 0x2d 45 0xe0 224 1021/170 0x00 1021/095 0x80 1021/032 0x00 1021/200 0x02 1021/020 代码 1021/030123456789101112131415161718192021/// &lt;summary&gt;/// 计算日时间项(I021/030)对应的值/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string I021_030(byte[] byteData)&#123; //将几个独立字节合并为一个字节 uint rhs = ((uint)byteData[0] &lt;&lt; 16) + ((uint)byteData[1] &lt;&lt; 8) + byteData[2]; //总秒数 uint value0 = rhs / 128; //小时数 uint value1 = value0 / 3600; //分钟数 uint value2 = (value0 - value1 * 3600) / 60; //秒数 uint value3 = (value0 - value1 * 3600) % 60; //毫秒数 uint value4 = ((rhs % 128) * 1000) / 128; return $"&#123;DateTime.Now.ToShortDateString()&#125; &#123;value1&#125;:&#123;value2&#125;:&#123;value3&#125;.&#123;value4&#125;";&#125; 1021/13012345678910111213141516171819202122/// &lt;summary&gt;/// 计算位置坐标(WGS-84中)项(I021/130)对应的值/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double[] I021_130(byte[] byteData)&#123; double[] res = &#123; 0, 0 &#125;; int value1; //将容器中前4个字节合并为一个字节，用以计算纬度。 value1 = (byteData[0] &lt;&lt; 24) + (byteData[1] &lt;&lt; 16) + (byteData[2] &lt;&lt; 8) + byteData[3]; double temp1 = value1 * (5.364418e-6); //Console.WriteLine($"坐标值:纬度值&#123;temp1&#125;"); res[1] = temp1; int value0; //将容器中后4个字节合并为一个字节，用以计算经度。 value0 = (byteData[4] &lt;&lt; 24) + (byteData[5] &lt;&lt; 16) + (byteData[6] &lt;&lt; 8) + byteData[7]; double temp0 = value0 * (5.364418e-6); //Console.WriteLine($"经度值&#123;temp0&#125;"); res[0] = temp0; return res;&#125; 1021/08012345678910/// &lt;summary&gt;/// 计算目标地址项(I021/080)对应的值/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string I021_080(byte[] byteData)&#123; uint rhs = ((uint)byteData[0] &lt;&lt; 16) + ((uint)byteData[1] &lt;&lt; 8) + byteData[2]; return string.Format("&#123;0:X&#125;", rhs);&#125; 1021/15712345678910/// &lt;summary&gt;/// 计算几何垂直速率项(I021/157)对应的值/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double I021_157(byte[] byteData)&#123; uint rhs = byteData[0] + (uint)byteData[1]; return rhs * 6.25;&#125; 1021/170123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/// &lt;summary&gt;/// 计算目标识别项(I021/170)对应的值/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static string I021_170(byte[] byteData)&#123; string res = ""; //将6个独立字节合并为一个字节 long rhs = ((long)byteData[0] &lt;&lt; 40) + ((long)byteData[1] &lt;&lt; 32) + ((long)byteData[2] &lt;&lt; 24) + ((long)byteData[3] &lt;&lt; 16) + ((long)byteData[4] &lt;&lt; 8) + byteData[5]; //取出第42~47位 long value0 = (rhs &gt;&gt; 42) &amp; 63; //取出新的二进制数的第5位，并判断为0还是1. long value01 = (value0 &gt;&gt; 5) &amp; 1; if (value01 == 1) &#123; char value02 = (char)value0; res += value02; &#125; else &#123; //value0 = (value0^(1 &lt;&lt; 6)); //如果第5位为1，则将第6位取反。 value0 ^= (1 &lt;&lt; 6); char value03 = (char)value0; res += value03; &#125; //取出第36~41位 long value1 = (rhs &gt;&gt; 36) &amp; 63; long value11 = (value1 &gt;&gt; 5) &amp; 1; if (value11 == 1) &#123; char value12 = (char)value1; res += value12; &#125; else &#123; value1 ^= (1 &lt;&lt; 6); char value13 = (char)value1; res += value13; &#125; //取出第30~35位 long value2 = (rhs &gt;&gt; 30) &amp; 63; long value21 = (value2 &gt;&gt; 5) &amp; 1; if (value21 == 1) &#123; char value22 = (char)value2; res += value22; &#125; else &#123; value2 ^= (1 &lt;&lt; 6); char value23 = (char)value2; res += value23; &#125; //取出第24~29位 long value3 = (rhs &gt;&gt; 24) &amp; 63; long value31 = (value3 &gt;&gt; 5) &amp; 1; if (value31 == 1) &#123; char value32 = (char)value3; res += value32; &#125; else &#123; value3 ^= (1 &lt;&lt; 6); char value33 = (char)value3; res += value33; &#125; //取出第18~23位 long value4 = (rhs &gt;&gt; 18) &amp; 63; long value41 = (value4 &gt;&gt; 5) &amp; 1; if (value41 == 1) &#123; char value42 = (char)value4; res += value42; ; &#125; else &#123; value4 ^= (1 &lt;&lt; 6); char value43 = (char)value4; res += value43; &#125; //取出第12~17位 long value5 = (rhs &gt;&gt; 12) &amp; 63; long value51 = (value5 &gt;&gt; 5) &amp; 1; if (value51 == 1) &#123; char value52 = (char)value5; res += value52; &#125; else &#123; value5 ^= (1 &lt;&lt; 6); char value53 = (char)value5; res += value53; &#125; //取出第6~11位 long value6 = (rhs &gt;&gt; 6) &amp; 63; long value61 = (value6 &gt;&gt; 5) &amp; 1; if (value61 == 1) &#123; char value62 = (char)value6; res += value62; &#125; else &#123; value6 ^= (1 &lt;&lt; 6); char value63 = (char)value6; res += value63; &#125; //取出第0~5位 long value7 = rhs &amp; 63; long value71 = (value7 &gt;&gt; 5) &amp; 1; if (value71 == 1) &#123; char value72 = (char)value7; res += value72; &#125; else &#123; value7 ^= (1 &lt;&lt; 6); char value73 = (char)value7; res += value73; &#125; return res;&#125; 1021/14012345678910/// &lt;summary&gt;/// 计算几何高度项(I021/140)对应的值/// &lt;/summary&gt;/// &lt;param name="byteData"&gt;二进制数据&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static double I021_140(byte[] byteData)&#123; uint rhs = ((uint)byteData[0] &lt;&lt; 8) + byteData[1]; return rhs * 6.25;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迁移博客至 GitHub Pages + Hexo]]></title>
    <url>%2Fblog%2F2019%2F06%2F18%2Fblog-TransferHexo%2F</url>
    <content type="text"><![CDATA[简介原来只有使用 WordPress 记录一部分博客，以及平时有随手记录工作生活的习惯，这次迁移博客统一整理一遍。 技术简介博客主体使用 GitHub Pages 作为静态网站托管平台，使用 Hexo 作为静态博客生成框架，以及使用 theme-next 主题。 开发环境VSCode + Node.js + Hexo + Python + GIT 搭建创建 GitHub PagesGitHub 仓库创建与用户名同名的 “.github.io” 库要求：名称必须为小写字母或数字例：Github 用户名为：Test；则创建库为：test.github.io库地址即为：https://github.com/Test/test.github.iogit地址为：https://github.com/Test/test.github.io.gitPages访问地址为：https://test.github.io设置网站为HTTPS：库 Settings 中勾选：Enforce HTTPS 域名配置在阿里云中购买域名（例：test.com）后需实名认证安全设置中设置禁止转移锁、禁止更新锁设置域名解析：新增两条记录1、记录类型：CNAME；主机记录：www；解析线路：默认；记录值：test.github.io；TTL：10分钟；2、记录类型：CNAME；主机记录：@；解析线路：默认；记录值：test.github.io；TTL：10分钟；即可跳转为 test.github.io 地址设置打开网站为域名地址：GitHub 库中新增 CNAME 文件 保存内容为域名地址（例：test.com）Settings 中显示 “Your site is published at https://test.com/ “ 即可 目录结构 目录文件夹或文件 作用及功能 blog 用于发布的静态博客 flash 网页中加载的Flash文件 hexoblog Hexo 编译博客源码 images 网页中加载的图片文件 resume 简历页面 .nojekyll 关闭jekyll检查 404.html 网站404页面 CNAME 设置Pages解析域名地址 README.md 自述文件 index.html 博客主界面 修改主题样式仅展示代码样式部分，主题配置文件请查阅官网 theme-next修改文件路径：hexoblog/themes/next/source/css/_custom/custom.styl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Custom styles.// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 20px; padding: 10px; background: #FFF; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;.content-wrap &#123; background: transparent;&#125;.footer &#123; padding: 0px; padding-bottom: 20px;&#125;// 主页文章内间距.content-wrap &#123; padding: 0px;&#125;.posts-expand &#123; padding-top: 0px;&#125;// 超链接颜色.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;// 主页文章块缩进.posts-expand .post-eof &#123; margin: 30px auto 10px; width: 0px; height: 0px;&#125;.posts-expand .post-meta &#123; margin: 3px 0 30px 0;&#125;.posts-expand .post-body img &#123; margin: 0px auto 0px;&#125;.post-button &#123; margin-top: 30px;&#125;// 底部页码格式.pagination &#123; margin: 40px 0 30px; border-top: 0px;&#125; 压缩Hexo博客生成空白行解决Hexo博客系统生成导致大量空白行问题自动遍历目录下所有html文件，创建临时文件，把非空格行拷贝，最后在重命名文件恢复生成博客文章后执行命令：python compress.py 即可1234567891011121314151617181920212223242526272829import reimport osdef minify_html(filename): with open(filename, 'r', encoding='utf-8') as p: with open(filename+'.tmp', 'w', encoding='utf-8') as t: while True: l = p.readline() if not l: break else: if re.search(r'\S', l): t.write(l) os.remove(filename) os.rename(filename+'.tmp', filename) print('%s 已压缩！' % filename)def yasuo(dir_path): if dir_path[len(dir_path)-1] == '/': dir_path = dir_path[:len(dir_path)-1] file_list = os.listdir(dir_path) for i in file_list: if i.find('html') &gt; 0: minify_html(dir_path+'/'+i) elif os.path.isdir(dir_path+'/'+i) and not re.match(r'\.|\_', i): yasuo("%s/%s" % (dir_path, i))# dir_path：压缩相对路径yasuo('public') 拷贝Hexo博客系统public目录当前系统Hexo博客源码在 /hexoblog 目录下（该目录不被上传），将生成文件自动拷贝至上层目录 /blog 下生成博客文章后执行命令：python deploy.py 即可123456789101112131415161718192021import osimport shutildef deploy(dir_path, dir_copy): dirpath = r'%s\%s' % (os.path.dirname( os.path.realpath(__file__)), dir_path) dircopy = r'%s\%s' % (os.path.abspath( os.path.dirname(os.getcwd())), dir_copy) print('dirpath：%s', dirpath) print('dircopy：%s', dircopy) # 删除文件夹 if os.path.exists(dircopy): shutil.rmtree(dircopy) print('删除文件夹成功！') # 拷贝文件夹 shutil.copytree(dirpath, dircopy) print('拷贝文件夹成功！')# 生成博客相对路径# 拷贝上级目录相对路径deploy('public', 'blog') 遇到的问题使用VSCode开发时生成静态页不加载CSS样式插件：View In Browser 本地网页打开插件：Live Server 启动一个服务打开网站 上传Hexo博客源码后报错：Date is not a valid datetime由于GitHub Pages默认使用jekyll作为代码检查，在上传Hexo源码之后存在编译不通过的情况，所以需要创建.nojekyll空文件在Repository的根目录下以关闭针对jekyll的检查。Windows下创建以“.”开头文件夹和文件（执行命令）：12md .folder //创建文件夹echo &gt;.file //创建文件 Hexo生成静态博客存在大量空白行请查看文章：压缩Hexo博客生成空白行 执行命令123456789101112cd hexoblog //进入博客源码文件夹hexo new &lt;title&gt; //创建新文章hexo clean //清理博客生成文件hexo generate //生成博客静文件hexo server //启动博客服务测试内容python compress.py //压缩Hexo生成空白行python deploy.py //拷贝至上级 "../blog" 发布目录cd .. //回到上级 "../" 目录git status //对比差异文件git add . //添加修改至缓存区git commit -m "Message" //填写修改内容git push //提交修改]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>python</tag>
        <tag>cmd</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科盾科技股份有限公司]]></title>
    <url>%2Fblog%2F2019%2F06%2F12%2Fwork-KedunTech%2F</url>
    <content type="text"><![CDATA[人像识别重建系统个人简介2018年07月12日 - 2019年08月09日 就职于 科盾科技股份有限公司 软件研发工程师岗位。 公司简介科盾科技股份有限公司 成立于1999年，公司总部和研发中心位于北京中关村，试验验证展示基地在昌平区，生产基地在山东莱阳，在济南、深圳、武汉和南京等地设有办事处。目前拥有员工六百余人，是国内领先的安防和夜视产品专业供应商。（股票代码：835902）。 由于拖欠工资，已申请劳动仲裁，强制执行中，拖欠工资差额 40293 元，拖欠公积金 10 个月。仲裁编号：京海劳人仲字[2019]第 20462 号案件编号：(2020)京0108执5448号 项目介绍（由于签署保密协议，仅介绍大致工作内容）人像识别重建系统，主要用于公安部门使用，当前视频监控得到了迅速发展。视频监控普遍存在的问题是：人脸图像分辨率低下。对于低分辨率的人脸图像，需要清晰化目标人的人脸图像和确定监控中目标人的真实身份，以便于公安部门提高破案率。现模拟画像破案率提高30% 指纹提高破案率10%。以及对于寻找失踪人口及儿童得到极大帮助！ 声明该项目为：第八届国际警用装备及反恐技术装备展览会 展出产品，功能及介绍均为宣传内容，如有兴趣请联系科盾科技股份有限公司。 项目背景该项目由清华大学 苏光大 教授多项国家发明专利为基础研发。主要使用技术有 OpenCV、深度学习、DNN（深度神经网络）、Caffe（卷积神经网络框架） 构成。 参与内容在该项目中负责完整的架构设计、系统原型设计（Axure RP）、系统流程设计（Visio）、系统UI设计（Photoshop、Illustrator）、编码开发（不包含算法部分）。 设计概要系统现由服务端与客户端组成：服务端采用 ASP.NET MVC，后转 .NET Core 框架。客户端采用 WPF MVVM、Prism、NSIS 架构；其他技术使用：数据库：MySQL高速缓存：Redis消息队列：RabbitMQ 重建流程 功能介绍超分辨率重建使监控拍摄到的模糊人像通过算法优化重建出意向人脸，增加案件破获概率。1、加载监控拍摄到的图像（正脸角度60以内） 2、归一化图像480*360（自动处理）；调整直方图均衡及噪点；超分辨率重建 人脸识别使超分辨率重建得到的意向人脸或清晰人脸照片匹配数据库中相似的人像数据，从而排查可疑人员。 模拟画像通过人脸识别到的人像自由添加替换五官部件、调整，达到更趋向于犯罪嫌疑人的画像。]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>asp</tag>
        <tag>c#</tag>
        <tag>mysql</tag>
        <tag>c++</tag>
        <tag>axure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调用神思二代身份证读卡器]]></title>
    <url>%2Fblog%2F2019%2F04%2F06%2Fcpp-Sdses%2F</url>
    <content type="text"><![CDATA[基于神思二代身份证读卡器做二次开发简介公司中项目人证合一核查系统需要，使用神思二代身份证读卡器二次开发集成。由于神思二代证SKD只提供了C++/Java接口，项目还是采用C#作为主要开发语言，使用WPF开发界面，所以采用 C#/C++ 混合编程 的方式开发。 封装代码由官方提供的C++SDK二次封装为非托管动态链接库暴露接口给C#端调用读卡器读取身份证照片存为 RdCard.dll 库目录下 zp.bmp 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include "stdafx.h"#include "2ndCardReader.h"// 主符号#include "resource.h"#include "Ucmd.h"#include &lt;fstream&gt;#include &lt;atlimage.h&gt;#pragma warning(disable:4996)using namespace std;typedef unsigned char BYTE;typedef unsigned short WORD;typedef unsigned long DWORD;typedef long LONG;//位图文件头文件定义typedef struct&#123; DWORD bfSize; //文件大小 WORD bfReserved1; //保留字 WORD bfReserved2; //保留字 DWORD bfOffBits; //实际位图数据偏移字节数=前三个部分长度之和&#125;ClBITMAPHEADER;//信息头BITMAPINFOHEADERtypedef struct&#123; DWORD biSize; //指定此结构体长度40 LONG biWidth; LONG biHeight; WORD biPlanes; //平面数 为1 WORD biBitCount; //采用颜色位数 DWORD biCompression; //压缩方式 DWORD biSizeImage; //实际位图占用字节数 LONG biXPelsPerMeter; //x方向分辨率 LONG biYPelsPerMeter; //y方向分辨率 DWORD biClrUsed; //使用的颜色数 DWORD biClrImportant; //重要的颜色数&#125;ClBITMAPINFOHEADER;typedef struct&#123; unsigned char rgbBlue; unsigned char rgbGreen; unsigned char rgbRed; unsigned char rgbReserved;&#125;ClRGBQUAD;typedef int(__stdcall *_UCommand1)(unsigned char* pCmd, int* parg0, int* parg1, int* parg2);typedef int(__stdcall *_GetAddr)(char* pbuf);typedef int(__stdcall *_GetBegin)(char* pbuf);typedef int(__stdcall *_GetName)(char* pbuf);typedef int(__stdcall *_GetSex)(char* pbuf);typedef int(__stdcall *_GetSexGB)(char* pbuf);typedef int(__stdcall *_GetFolk)(char* pbuf);typedef int(__stdcall *_GetFolkGB)(char* pbuf);typedef int(__stdcall *_GetIDNum)(char* pbuf);typedef int(__stdcall *_GetDep)(char* pbuf);typedef int(__stdcall *_GetBirth)(char* pbuf);typedef int(__stdcall *_GetEnd)(char* pbuf);typedef int(__stdcall *_GetNewAddr)(char* pbuf);typedef int(__stdcall *_FID_GetEnName)(char* pbuf);typedef int(__stdcall *_FID_GetSex)(char* pbuf);typedef int(__stdcall *_FID_GetSexGB)(char* pbuf);typedef int(__stdcall *_FID_GetIDNum)(char* pbuf);typedef int(__stdcall *_FID_GetNationality)(char* pbuf);typedef int(__stdcall *_FID_GetChNationality)(char* pbuf);typedef int(__stdcall *_FID_GetChName)(char* pbuf);typedef int(__stdcall *_FID_GetBegin)(char* pbuf);typedef int(__stdcall *_FID_GetEnd)(char* pbuf);typedef int(__stdcall *_FID_GetBirth)(char* pbuf);typedef int(__stdcall *_FID_GetVersion)(char* pbuf);typedef int(__stdcall *_FID_GetDep)(char* pbuf);typedef int(__stdcall *_GetSAMIDToStr)(char* id);_UCommand1 UCommand1;_GetAddr GetAddr;_GetBegin GetBegin;_GetName GetName;_GetSex GetSex;_GetSexGB GetSexGB;_GetFolk GetFolk;_GetFolkGB GetFolkGB;_GetIDNum GetIDNum;_GetDep GetDep;_GetBirth GetBirth;_GetEnd GetEnd;_GetNewAddr GetNewAddr;_FID_GetEnName FID_GetEnName;_FID_GetSex FID_GetSex;_FID_GetSexGB FID_GetSexGB;_FID_GetIDNum FID_GetIDNum;_FID_GetNationality FID_GetNationality;_FID_GetChNationality FID_GetChNationality;_FID_GetChName FID_GetChName;_FID_GetBegin FID_GetBegin;_FID_GetEnd FID_GetEnd;_FID_GetBirth FID_GetBirth;_FID_GetVersion FID_GetVersion;_FID_GetDep FID_GetDep;_GetSAMIDToStr GetSAMIDToStr;extern "C" char* TrimStr(char *str)&#123; char *head = str; while (*head == ' ') &#123; ++head; &#125; char *end = head + strlen(head) - 1; while (*end == ' ') &#123; --end; &#125; *(end + 1) = 0; strcpy(str, head); return str;&#125;extern "C" MY2NDCARDREADER_API int fn2ndCardReaderInfo(IDInfo* pIDInfo)&#123; int i = LoadDll(); if (i != 1) &#123; return -10; &#125; HINSTANCE hDll = LoadLibraryEx(L"RdCard.dll", 0, LOAD_WITH_ALTERED_SEARCH_PATH); if (hDll == NULL) &#123; return -10; &#125; UCommand1 = (_UCommand1)GetProcAddress(hDll, "UCommand1"); GetAddr = (_GetAddr)GetProcAddress(hDll, "GetAddr"); GetBegin = (_GetBegin)GetProcAddress(hDll, "GetBegin"); GetName = (_GetName)GetProcAddress(hDll, "GetName"); GetSex = (_GetSex)GetProcAddress(hDll, "GetSex"); GetSexGB = (_GetSexGB)GetProcAddress(hDll, "GetSexGB"); GetFolk = (_GetFolk)GetProcAddress(hDll, "GetFolk"); GetFolkGB = (_GetFolkGB)GetProcAddress(hDll, "GetFolkGB"); GetIDNum = (_GetIDNum)GetProcAddress(hDll, "GetIDNum"); GetDep = (_GetDep)GetProcAddress(hDll, "GetDep"); GetBirth = (_GetBirth)GetProcAddress(hDll, "GetBirth"); GetEnd = (_GetEnd)GetProcAddress(hDll, "GetEnd"); GetNewAddr = (_GetNewAddr)GetProcAddress(hDll, "GetNewAddr"); FID_GetEnName = (_FID_GetEnName)GetProcAddress(hDll, "FID_GetEnName"); FID_GetSex = (_FID_GetSex)GetProcAddress(hDll, "FID_GetSex"); FID_GetSexGB = (_FID_GetSexGB)GetProcAddress(hDll, "FID_GetSexGB"); FID_GetIDNum = (_FID_GetIDNum)GetProcAddress(hDll, "FID_GetIDNum"); FID_GetNationality = (_FID_GetNationality)GetProcAddress(hDll, "FID_GetNationality"); FID_GetChNationality = (_FID_GetChNationality)GetProcAddress(hDll, "FID_GetChNationality"); FID_GetChName = (_FID_GetChName)GetProcAddress(hDll, "FID_GetChName"); FID_GetBegin = (_FID_GetBegin)GetProcAddress(hDll, "FID_GetBegin"); FID_GetEnd = (_FID_GetEnd)GetProcAddress(hDll, "FID_GetEnd"); FID_GetBirth = (_FID_GetBirth)GetProcAddress(hDll, "FID_GetBirth"); FID_GetVersion = (_FID_GetVersion)GetProcAddress(hDll, "FID_GetVersion"); FID_GetDep = (_FID_GetDep)GetProcAddress(hDll, "FID_GetDep"); GetSAMIDToStr = (_GetSAMIDToStr)GetProcAddress(hDll, "GetSAMIDToStr"); if (UCommand1 == NULL || GetAddr == NULL || GetBegin == NULL || GetName == NULL || GetSex == NULL || GetSexGB == NULL || GetFolk == NULL || GetFolkGB == NULL || GetIDNum == NULL || GetDep == NULL || GetBirth == NULL || GetEnd == NULL || GetNewAddr == NULL || FID_GetEnName == NULL || FID_GetSex == NULL || FID_GetSexGB == NULL || FID_GetIDNum == NULL || FID_GetNationality == NULL || FID_GetChNationality == NULL || FID_GetChName == NULL || FID_GetBegin == NULL || FID_GetEnd == NULL || FID_GetBirth == NULL || FID_GetVersion == NULL || FID_GetDep == NULL || GetSAMIDToStr == NULL) &#123; return FALSE; &#125; //连接设备 unsigned char cmd = 0x41; int para0 = 0, para1 = 8811, para2 = 9986; int ret = UCommand1(&amp;cmd, &amp;para0, &amp;para1, &amp;para2); if (ret != 62171) &#123; //MessageBox("设备连接失败，请检查设备是否插好！"); return -11; &#125; //验证卡（寻卡） cmd = 0x43; ret = UCommand1(&amp;cmd, &amp;para0, &amp;para1, &amp;para2); //读卡 cmd = 0x49; ret = UCommand1(&amp;cmd, &amp;para0, &amp;para1, &amp;para2); if (ret != 62171) &#123; //MessageBox("读卡失败！"); return -12; &#125; GetAddr = (_GetAddr)GetProcAddress(hDll, "GetAddr"); GetName = (_GetName)GetProcAddress(hDll, "GetName"); GetSex = (_GetSex)GetProcAddress(hDll, "GetSex"); GetFolk = (_GetFolkGB)GetProcAddress(hDll, "GetFolkGB"); GetIDNum = (_GetIDNum)GetProcAddress(hDll, "GetIDNum"); GetBegin = (_GetBegin)GetProcAddress(hDll, "GetBegin"); GetEnd = (_GetEnd)GetProcAddress(hDll, "GetEnd"); GetDep = (_GetDep)GetProcAddress(hDll, "GetDep"); if (GetAddr == NULL || GetName == NULL || GetSex == NULL || GetFolk == NULL || GetIDNum == NULL || GetBegin == NULL || GetDep == NULL || GetEnd == NULL) &#123; return -22; &#125; GetName(pIDInfo-&gt;Name); TrimStr(pIDInfo-&gt;Name); GetSexGB(pIDInfo-&gt;Gender); GetBirth(pIDInfo-&gt;BirthDate); GetAddr(pIDInfo-&gt;Address); TrimStr(pIDInfo-&gt;Address); GetIDNum(pIDInfo-&gt;IDNumber); GetBegin(pIDInfo-&gt;Begin); GetEnd(pIDInfo-&gt;End); GetFolk(pIDInfo-&gt;Folk); GetDep(pIDInfo-&gt;IssuanceAuthority); pIDInfo-&gt;Nation = "中国"; //关闭读卡器 cmd = 0x42; UCommand1(&amp;cmd, &amp;para0, &amp;para1, &amp;para2); FreeDll(); return 1;&#125; 调用代码12[DllImport(@"2ndCardReader.dll", EntryPoint = "fn2ndCardReaderInfo", CallingConvention = CallingConvention.Cdecl)]public static extern int fn2ndCardReaderInfo(ref IDInfo pIDInfo); 12345678910111213141516 [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 1)]public struct IDInfo&#123; //二代证信息 public IntPtr Name; public IntPtr Gender; public IntPtr Folk; public IntPtr Nation; public IntPtr BirthDate; public IntPtr Address; public IntPtr IDNumber; public IntPtr IssuanceAuthority; public IntPtr Begin; public IntPtr End; public IntPtr Image;&#125; 12345678910111213141516171819202122232425IDInfo pIDInfo = new IDInfo();pIDInfo.Name = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Gender = Marshal.StringToHGlobalAnsi("");pIDInfo.Nation = Marshal.StringToHGlobalAnsi(" ");pIDInfo.BirthDate = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Address = Marshal.StringToHGlobalAnsi(" ");pIDInfo.IDNumber = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Image = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Begin= Marshal.StringToHGlobalAnsi(" ");pIDInfo.End = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Folk = Marshal.StringToHGlobalAnsi(" ");pIDInfo.IssuanceAuthority = Marshal.StringToHGlobalAnsi(" ");int i = fn2ndCardReaderInfo(ref pIDInfo);string Name = Marshal.PtrToStringAnsi(pIDInfo.Name);string Gender = Marshal.PtrToStringAnsi(pIDInfo.Gender);string Nation = Marshal.PtrToStringAnsi(pIDInfo.Nation);string BirthDate = Marshal.PtrToStringAnsi(pIDInfo.BirthDate);string Address = Marshal.PtrToStringAnsi(pIDInfo.Address);string IDNumber = Marshal.PtrToStringAnsi(pIDInfo.IDNumber);string IssuanceAuthority = Marshal.PtrToStringAnsi(pIDInfo.IssuanceAuthority);string Begin = Marshal.PtrToStringAnsi(pIDInfo.Begin);string End = Marshal.PtrToStringAnsi(pIDInfo.End);string Folk = Marshal.PtrToStringAnsi(pIDInfo.Folk);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>c++</tag>
        <tag>sdses</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp服务端文件下载]]></title>
    <url>%2Fblog%2F2019%2F03%2F11%2Fasp-DownloadFile%2F</url>
    <content type="text"><![CDATA[服务端提供网页点击下载功能，或 WebApi 接口提供软件更新下载服务 继承 Controller 接口的控制器方法下载方式使用环境：网页端按钮点击下载按钮脚本链接进入这个方法之后，服务端直接生成文件，浏览器自动下载 1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt;/// 下载文件/// &lt;/summary&gt;/// &lt;returns&gt;是否下载成功&lt;/returns&gt;public ActionResult DownLoadFile()&#123; string filePath = "服务端文件路径（程序自动获取路径或根据传入参数判断文件路径）"; FileInfo fileInfo = new FileInfo(filePath); if (fileInfo.Exists) &#123; Response.Clear(); Response.ClearContent(); Response.ClearHeaders(); Response.Buffer = true; Response.AddHeader("Content-Disposition", "attachment;filename=" + Server.UrlEncode(fileInfo.Name)); Response.AddHeader("Content-Length", fileInfo.Length.ToString()); Response.AddHeader("Content-Transfer-Encoding", "binary"); Response.ContentType = "application/x-msdownload"; Response.ContentEncoding = System.Text.Encoding.GetEncoding("gb2312"); Response.WriteFile(fileInfo.FullName); Response.Flush(); Response.End(); return Json(true); &#125; else &#123; return Json(false); &#125;&#125; 继承 ApiController 接口的 WebApi 方法下载方式使用环境：桌面端自动更新 提交需要更新的文件名 获取下载服务端返回文件流，桌面端接收并保存到指定目录替换 12345678910/// &lt;summary&gt;/// 下载文件/// &lt;/summary&gt;/// &lt;returns&gt;文件数据流&lt;/returns&gt;[HttpGet]public byte[] DownLoadFile()&#123; string filePath = "服务端文件路径（程序自动获取路径或根据传入参数判断文件路径）"; return File.Exists(filePath) ? File.ReadAllBytes(filePath) : null;&#125;]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>asp</tag>
        <tag>download</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nsis 使用介绍]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2Fsoftware-Nsis%2F</url>
    <content type="text"><![CDATA[基于 NSIS 的 Windows 桌面端打包程序简介NSIS（Nullsoft Scriptable Install System）是一个专业的开源系统，用于创建Windows安装程序。它的设计尽可能小巧灵活，因此非常适合互联网分发。只做了一个最基础安装包程序，如需定制样式可查阅官方网站。 安装包截图 脚本代码替换脚本中 “#” 开头的部分即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118; 自定义常量!define MainWindow "#主程序名称"!define /date PRODUCT_TIME %Y%m%d%H%M!ifdef ClientVersion!else !define ClientVersion 0.0.0.0!endif; 安装程序初始定义常量!define PRODUCT_NAME "#产品名称"!define PRODUCT_VERSION $&#123;ClientVersion&#125;!define PRODUCT_PUBLISHER "#产品发布者"!define PRODUCT_WEB_SITE "#产品官网"!define PRODUCT_DIR_REGKEY "Software\Microsoft\Windows\CurrentVersion\App Paths\$&#123;MainWindow&#125;"!define PRODUCT_UNINST_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\$&#123;PRODUCT_NAME&#125;"!define PRODUCT_UNINST_ROOT_KEY "HKLM"SetCompressor lzma; ------ MUI 现代界面定义 (1.67 版本以上兼容) ------!include "MUI.nsh"; MUI 预定义常量!define MUI_ABORTWARNING!define MUI_ICON "$&#123;NSISDIR&#125;\Contrib\Graphics\Icons\modern-install.ico"!define MUI_UNICON "$&#123;NSISDIR&#125;\Contrib\Graphics\Icons\modern-uninstall.ico"; 欢迎页面!insertmacro MUI_PAGE_WELCOME; 许可协议页面!insertmacro MUI_PAGE_LICENSE "许可协议.txt"; 安装目录选择页面!insertmacro MUI_PAGE_DIRECTORY; 安装过程页面!insertmacro MUI_PAGE_INSTFILES; 安装完成页面!define MUI_FINISHPAGE_RUN "$INSTDIR\$&#123;MainWindow&#125;"!insertmacro MUI_PAGE_FINISH; 安装卸载过程页面!insertmacro MUI_UNPAGE_INSTFILES; 安装界面包含的语言设置!insertmacro MUI_LANGUAGE "SimpChinese"; 安装预释放文件!insertmacro MUI_RESERVEFILE_INSTALLOPTIONS; ------ MUI 现代界面定义结束 ------Name "$&#123;PRODUCT_NAME&#125; $&#123;PRODUCT_VERSION&#125;"OutFile "$&#123;PRODUCT_NAME&#125;Setup_$&#123;ClientVersion&#125;_$&#123;PRODUCT_TIME&#125;.exe"InstallDir "$PROGRAMFILES64\$&#123;PRODUCT_PUBLISHER&#125;\$&#123;PRODUCT_NAME&#125;"InstallDirRegKey HKLM "$&#123;PRODUCT_UNINST_KEY&#125;" "UninstallString"ShowInstDetails showShowUnInstDetails showSection "MainSection" SEC01 ExecWait "taskkill /f /im $&#123;MainWindow&#125;" SetOutPath "$INSTDIR" SetOverwrite ifnewer CreateDirectory "$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;" CreateShortCut "$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;\$&#123;PRODUCT_NAME&#125;.lnk" "$INSTDIR\$&#123;MainWindow&#125;" CreateShortCut "$DESKTOP\$&#123;PRODUCT_NAME&#125;.lnk" "$INSTDIR\$&#123;MainWindow&#125;" File /r "bin\Release\*.*" ExecWait 'cmd.exe /c takeown /f "$INSTDIR" /r /d y &amp;&amp; icacls "$INSTDIR" /grant administrators:F /t'SectionEndSection -AdditionalIcons WriteIniStr "$INSTDIR\$&#123;PRODUCT_NAME&#125;.url" "InternetShortcut" "URL" "$&#123;PRODUCT_WEB_SITE&#125;" CreateShortCut "$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;\Website.lnk" "$INSTDIR\$&#123;PRODUCT_NAME&#125;.url" CreateShortCut "$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;\Uninstall.lnk" "$INSTDIR\uninst.exe"SectionEndSection -Post WriteUninstaller "$INSTDIR\uninst.exe" WriteRegStr HKLM "$&#123;PRODUCT_DIR_REGKEY&#125;" "" "$INSTDIR\$&#123;MainWindow&#125;" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "DisplayName" "$(^Name)" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "UninstallString" "$INSTDIR\uninst.exe" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "DisplayIcon" "$INSTDIR\$&#123;MainWindow&#125;" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "DisplayVersion" "$&#123;PRODUCT_VERSION&#125;" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "URLInfoAbout" "$&#123;PRODUCT_WEB_SITE&#125;" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "Publisher" "$&#123;PRODUCT_PUBLISHER&#125;"SectionEnd/****************************** * 以下是安装程序的卸载部分 * ******************************/Section Uninstall Delete "$INSTDIR\$&#123;PRODUCT_NAME&#125;.url" Delete "$INSTDIR\uninst.exe" Delete "$INSTDIR\*.*" Delete "$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;\Uninstall.lnk" Delete "$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;\Website.lnk" Delete "$DESKTOP\$&#123;PRODUCT_NAME&#125;.lnk" Delete "$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;\$&#123;PRODUCT_NAME&#125;.lnk" RMDir "$SMPROGRAMS\$&#123;PRODUCT_NAME&#125;" RMDir /r "$INSTDIR" DeleteRegKey $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" DeleteRegKey HKLM "$&#123;PRODUCT_DIR_REGKEY&#125;" SetAutoClose trueSectionEnd#-- 根据 NSIS 脚本编辑规则，所有 Function 区段必须放置在 Section 区段之后编写，以避免安装程序出现未可预知的问题。--#Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2 "您确实要完全移除 $(^Name) ，及其所有的组件？" IDYES +2 AbortFunctionEndFunction un.onUninstSuccess HideWindow MessageBox MB_ICONINFORMATION|MB_OK "$(^Name) 已成功地从您的计算机移除。"FunctionEnd 使用命令调用构建打包程序12:: 调用 makensis 命令构建 NSImakensis Setup.nsi 1234:: 调用 makensis 命令带参数构建 NSI:: 从文本中读取版本号传入 NSI 中作为常量set /p var= &lt; ClientVersionmakensis /DClientVersion=%var% Setup.nsi]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>nsis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印Word文件]]></title>
    <url>%2Fblog%2F2018%2F10%2F25%2Fasp-PrintWord%2F</url>
    <content type="text"><![CDATA[服务端调用打印机打印Word文件 简介工作时需要直接操作 OA系统 调用打印机打印 Word 文件。 引用库介绍需要电脑安装 Microsoft Office 并引用COM组件 Microsoft.Office.Interop.Word 才可以调用打印机。 代码及调用打印Word12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using Word = Microsoft.Office.Interop.Word;/// &lt;summary&gt;/// 打印Word/// &lt;/summary&gt;/// &lt;param name="filePath"&gt;需要打印的文件&lt;/param&gt;/// &lt;param name="PrintName"&gt;打印机名称&lt;/param&gt;private static void PrintWord(string filePath, string PrintName)&#123; try &#123; //要打印的文件路径 Object wordFile = filePath; object oMissing = Missing.Value; //自定义object类型的布尔值 object oTrue = true; object oFalse = false; object doNotSaveChanges = Word.WdSaveOptions.wdDoNotSaveChanges; //Word.Application appWord = null; //定义word Application相关 Word.Application appWord = new Word.Application(); //word程序不可见 appWord.Visible = false; //不弹出警告框 appWord.DisplayAlerts = Word.WdAlertLevel.wdAlertsNone; //先保存默认的打印机 string defaultPrinter = appWord.ActivePrinter; //打开要打印的文件 Word.Document doc = appWord.Documents.Open( ref wordFile, ref oMissing, ref oTrue, ref oFalse, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing ); //设置指定的打印机名字 appWord.ActivePrinter = PrintName; //打印 doc.PrintOut( ref oTrue,//此处为true表示后台打印 ref oFalse, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing ); //打印完关闭word文件 doc.Close(ref doNotSaveChanges, ref oMissing, ref oMissing); //还原原来的默认打印机 appWord.ActivePrinter = defaultPrinter; //退出word程序 appWord.Quit(ref oMissing, ref oMissing, ref oMissing); doc = null; appWord = null; &#125; catch (Exception ex) &#123; //代码行数 string line = ex.StackTrace.ToString(); //返回错误发生的方法定义 string errorfunction = ex.TargetSite.ToString(); int code = ex.HResult; &#125;&#125; 调用方法12//打印WordPrintWord(dialog.FileName, "审批打印机");]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>asp</tag>
        <tag>printer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/S端调用 WebApi 帮助类]]></title>
    <url>%2Fblog%2F2018%2F08%2F27%2Fcsharp-WebApiHelper%2F</url>
    <content type="text"><![CDATA[使用 HttpClient 与 HttpWebRequest 两种方式调用 WebApi 帮助类 简介现最常见的软件开发模式就是 服务端（B/S、WebApi、WebServer) + 客户端(C/S、Android、IOS)。公司有部分新项目修改为逻辑在服务端处理，所以通过两种方法封装一个C/S端调用WebApi接口的帮助类。调试WebApi推荐使用：Postman。 帮助类HttpClientHttpClientHelper 创建Get请求123456789101112131415161718192021222324252627282930313233343536373839/// &lt;summary&gt;/// 创建Get请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreateGetHttpClient(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters)&#123; try &#123; StringBuilder builder = new StringBuilder(); builder.Append(url); builder.Append(requestUrl); if (parameters != null &amp;&amp; parameters.Count &gt;= 1) &#123; builder.Append("?"); int i = 0; foreach (var item in parameters) &#123; if (i &gt; 0) &#123; builder.Append("&amp;"); &#125; builder.AppendFormat("&#123;0&#125;=&#123;1&#125;", item.Key, item.Value); i++; &#125; &#125; HttpClient httpClient = new HttpClient(); httpClient.BaseAddress = new Uri(url); var result = httpClient.GetAsync(builder.ToString()).Result; return result.Content.ReadAsStringAsync().Result; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125; 创建Post请求12345678910111213141516171819202122/// &lt;summary&gt;/// 创建Post请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreatePostHttpClient(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters)&#123; try &#123; HttpClient httpClient = new HttpClient(); httpClient.BaseAddress = new Uri(url); var result = httpClient.PostAsync(requestUrl, new FormUrlEncodedContent(parameters)).Result; return result.Content.ReadAsStringAsync().Result; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125; HttpWebRequest创建Get请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/// &lt;summary&gt;/// 创建Get请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreateGetHttpWebRequest(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters)&#123; try &#123; StringBuilder builder = new StringBuilder(); builder.Append(url); builder.Append(requestUrl); if (parameters != null &amp;&amp; parameters.Count &gt;= 1) &#123; builder.Append("?"); int i = 0; foreach (var item in parameters) &#123; if (i &gt; 0) &#123; builder.Append("&amp;"); &#125; builder.AppendFormat("&#123;0&#125;=&#123;1&#125;", item.Key, item.Value); i++; &#125; &#125; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(builder.ToString()); request.Method = "GET"; request.ContentType = "application/x-www-form-urlencoded"; StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream(), Encoding.UTF8); return reader.ReadToEnd(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125;/// &lt;summary&gt;/// 创建Get请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;param name="encoding"&gt;字符编码&lt;/param&gt;/// &lt;param name="timout "&gt;请求超时前等待的毫秒数,默认值是 100,000 毫秒（100 秒）&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreateGetHttpWebRequest(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters, Encoding encoding, int timout)&#123; try &#123; StringBuilder builder = new StringBuilder(); builder.Append(url); builder.Append(requestUrl); if (parameters != null &amp;&amp; parameters.Count &gt;= 1) &#123; builder.Append("?"); int i = 0; foreach (var item in parameters) &#123; if (i &gt; 0) &#123; builder.Append("&amp;"); &#125; builder.AppendFormat("&#123;0&#125;=&#123;1&#125;", item.Key, item.Value); i++; &#125; &#125; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(builder.ToString()); request.Method = "GET"; request.ContentType = "application/x-www-form-urlencoded"; request.Timeout = timout; StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream(), encoding); return reader.ReadToEnd(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125; 创建Post请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/// &lt;summary&gt;/// 创建Post请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreatePostHttpWebRequest(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters)&#123; try &#123; HttpWebRequest request = WebRequest.Create(url + requestUrl) as HttpWebRequest; request.ProtocolVersion = HttpVersion.Version10; request.Method = "POST"; request.ContentType = "application/x-www-form-urlencoded"; //如果需要POST数据 if (!(parameters == null || parameters.Count == 0)) &#123; StringBuilder buffer = new StringBuilder(); int i = 0; foreach (string key in parameters.Keys) &#123; if (i &gt; 0) &#123; buffer.AppendFormat("&amp;&#123;0&#125;=&#123;1&#125;", key, parameters[key]); &#125; else &#123; buffer.AppendFormat("&#123;0&#125;=&#123;1&#125;", key, parameters[key]); &#125; i++; &#125; byte[] data = Encoding.GetEncoding("utf-8").GetBytes(buffer.ToString()); using (Stream stream = request.GetRequestStream()) &#123; stream.Write(data, 0, data.Length); &#125; &#125; StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream(), Encoding.UTF8); return reader.ReadToEnd(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125;/// &lt;summary&gt;/// 创建Post请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;param name="encoding"&gt;字符编码&lt;/param&gt;/// &lt;param name="timout "&gt;请求超时前等待的毫秒数,默认值是 100,000 毫秒（100 秒）&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreatePostHttpWebRequest(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters, Encoding encoding, int timout)&#123; try &#123; HttpWebRequest request = WebRequest.Create(url + requestUrl) as HttpWebRequest; request.ProtocolVersion = HttpVersion.Version10; request.Method = "POST"; request.ContentType = "application/x-www-form-urlencoded"; request.Timeout = timout; //如果需要POST数据 if (!(parameters == null || parameters.Count == 0)) &#123; StringBuilder buffer = new StringBuilder(); int i = 0; foreach (string key in parameters.Keys) &#123; if (i &gt; 0) &#123; buffer.AppendFormat("&amp;&#123;0&#125;=&#123;1&#125;", key, parameters[key]); &#125; else &#123; buffer.AppendFormat("&#123;0&#125;=&#123;1&#125;", key, parameters[key]); &#125; i++; &#125; byte[] data = encoding.GetBytes(buffer.ToString()); using (Stream stream = request.GetRequestStream()) &#123; stream.Write(data, 0, data.Length); &#125; &#125; StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream(), Encoding.UTF8); return reader.ReadToEnd(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>webapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Depends 使用介绍]]></title>
    <url>%2Fblog%2F2018%2F08%2F01%2Fsoftware-Depends%2F</url>
    <content type="text"><![CDATA[简介Depends：可以扫描任何32位或64位Windows模块（exe，dll，ocx，sys等），并构建所有相关模块的分层树形图。对于找到的每个模块，它列出了该模块导出的所有函数，以及其他模块实际调用了哪些函数。另一个视图显示所需文件的最小集合，以及每个文件的详细信息，包括文件的完整路径，基本地址，版本号，机器类型，调试信息等。对于解决与加载和执行模块相关的系统错误也非常有用。Dependency Walker检测到许多常见的应用程序问题，例如缺少模块，模块无效，导入/导出不匹配，循环依赖性错误，模块的机器类型不匹配以及模块初始化失败。工作中需要使用到 C#/C++ 混合编程，或者安装一个软件后提示丢失某些类库导致无法运行时，Depends是最好的选择。 使用引用类库缺少软件安装包或开发环境提示错误：无法加载 DLL“xxx.dll”: 找不到指定的模块。使用Depends检查缺少模块，模块无效的库。下图：OpenCV 使用 Visual Studio 2015 开发缺少mfc120d.dll、msvcr120d.dll、msvcp120d.dll库 C/C++开发方法声明为C++方法时，DllImport 引用被不明方法加密，调用时需拷贝对应方法的Function名字粘贴到EntryPoint。 12[DllImport(@"CPP_Demo.dll", EntryPoint = "?filePath@@YAPADPAD@Z", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)]public static extern IntPtr filePath(IntPtr filePath);]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>depends</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#/C++ 混合编程]]></title>
    <url>%2Fblog%2F2018%2F08%2F01%2Fcpp-HybridCSharp%2F</url>
    <content type="text"><![CDATA[使用C++开发算法（全景拼接、人脸识别、超分辨率重建）/使用C#开发服务端业务逻辑和UI 简介现工作中作由于C++的UI（MFC、QT）开发界面比较难看，定制用户控件复杂且样式一般。而C#又不擅长于开发算法逻辑，效率不如C++。所以现在大部分公司都会选用C#/C++混合编程。 性能分析使用C#做界面要比C++高效的多，但是存在算法逻辑的时候由于性能问题不得不把部分模块交给C++处理，C++可以使用高效的栈内存对象（CCalc），而C#所有对象只能放在托管堆中。测试C#调用C++类库使用托管方式性能得到了一定程度的提升，但比起单纯的C++项目，还是差了很多；测试C#调用C++类库使用 DllImport Attribute 混合方式由非托管动态链接库效率与单独运行C++相差无几。 简单基础参数传递例子：1.最基础的加法运算；2.传入图片地址，通过OpenCV处理后返回图片地址；3.传入图片地址，通过OpenCV把彩色图像转换为灰度图像，然后返回给C#；方法声明为C++方法时，DllImport 引用被不明方法加密，调用时需使用Depends工具拷贝对应方法的Function名字粘贴到EntryPoint。详情查看Depends 使用介绍1234567891011121314151617181920212223242526272829303132int Add(int a, int b)&#123; return a + b;&#125;char* filePath(char* filePath)&#123; char* resurlt; resurlt = filePath; IplImage* img = cvLoadImage(filePath); //用原图像指针创建新图像 IplImage* dst = cvCreateImage(cvGetSize(img), IPL_DEPTH_8U, 1); if (NULL == dst) &#123; return FALSE; &#125; cvCvtColor(img, dst, CV_BGR2GRAY); return resurlt;&#125;IplImage* Color2Gray(char* filePath)&#123; IplImage* img = cvLoadImage(filePath); //用原图像指针创建新图像 IplImage* dst = cvCreateImage(cvGetSize(img), IPL_DEPTH_8U, 1); if (NULL == dst) &#123; return FALSE; &#125; cvCvtColor(img, dst, CV_BGR2GRAY); return dst;&#125; 123456789101112131415161718192021[DllImport(@"CPP_Demo.dll", EntryPoint = "?Add@@YAHHH@Z", CallingConvention = CallingConvention.Cdecl)]public static extern int Add(int a, int b);[DllImport(@"CPP_Demo.dll", EntryPoint = "?filePath@@YAPEADPEAD@Z", CallingConvention = CallingConvention.Cdecl)]public static extern IntPtr filePath(IntPtr filePath);[DllImport(@"CPP_Demo.dll", EntryPoint = "?Color2Gray@@YAPEAU_IplImage@@PEAD@Z", CallingConvention = CallingConvention.Cdecl)]public static extern IntPtr Color2Gray(IntPtr filePath);//加载基础图片image1.Source = new BitmapImage(new Uri(@"./image/HUA1.JPG", UriKind.Relative));//测试1int iAdd = Add(8, 12);//测试2string strFile = Marshal.PtrToStringAnsi(filePath(Marshal.StringToHGlobalAnsi(@"F:\Demos\C#调用C++类库(OpenCV)\CSharp_Demo\CSharp_Demo\Image\HUA1.JPG")));//测试3IntPtr imageGray = Color2Gray(Marshal.StringToHGlobalAnsi(@"F:\Demos\C#调用C++类库(OpenCV)\CSharp_Demo\CSharp_Demo\Image\HUA1.JPG"));MIplImage lplimage = (Emgu.CV.Structure.MIplImage)System.Runtime.InteropServices.Marshal.PtrToStructure(imageGray, typeof(Emgu.CV.Structure.MIplImage));Image&lt;Gray, Byte&gt; dst = new Image&lt;Gray, Byte&gt;(lplimage.Width, lplimage.Height, lplimage.WidthStep, lplimage.ImageData);image2.Source = ChangeBitmapToImageSource(dst.ToBitmap()); 错误及处理报错：无法加载 DLL“xxx.dll”: 找不到指定的模块推荐使用 Depends 工具检测缺少引用类库 报错：调用 Dll “试图加载格式不正确的程序。(异常来自 HRESULT:0x8007000B)调用64位类库需要把项目改为64位桌面端修改：属性→生成→目标平台设为”Any Cpu”，取消勾选”首选32位”。Web端修改：工具→选项→项目和解决方案→Web项目→勾选”对网站和项目使用 IIS Express 的 64 位版”]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>c++</tag>
        <tag>depends</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis操作帮助类]]></title>
    <url>%2Fblog%2F2018%2F07%2F07%2Fcsharp-RedisHelper%2F</url>
    <content type="text"><![CDATA[基于 StackExchange.Redis 库操作 Redis 帮助类 简介Redis 作为典型的 非关系型数据库（NoSQL） 采用Key-Value方式储存数据，持久化储存于内存中，对于请发请求速度要远高于传统数据库。 帮助类RedisHelper 引用 StackExchange.Redis 库。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229/// &lt;summary&gt;/// Redis 排序类型/// &lt;/summary&gt;public enum OrderType&#123; /// &lt;summary&gt; /// 提升 /// &lt;/summary&gt; Ascending, /// &lt;summary&gt; /// 下降 /// &lt;/summary&gt; Descending&#125;/// &lt;summary&gt;/// 获取 Redis 连接对象/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public IConnectionMultiplexer GetConnectionRedisMultiplexer()&#123; if (_connMultiplexer == null || !_connMultiplexer.IsConnected) lock (Locker) &#123; if (_connMultiplexer == null || !_connMultiplexer.IsConnected) _connMultiplexer = ConnectionMultiplexer.Connect(ConnectionString); &#125; return _connMultiplexer;&#125;#region 其它/// &lt;summary&gt;/// 获取事务/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public ITransaction GetTransaction()&#123; return _db.CreateTransaction();&#125;#endregion 其它#region private field/// &lt;summary&gt;/// 连接字符串/// &lt;/summary&gt;private static readonly string ConnectionString;/// &lt;summary&gt;/// redis 连接对象/// &lt;/summary&gt;private static IConnectionMultiplexer _connMultiplexer;/// &lt;summary&gt;/// 默认的 Key 值（用来当作 RedisKey 的前缀）/// &lt;/summary&gt;private static readonly string DefaultKey;/// &lt;summary&gt;/// 锁/// &lt;/summary&gt;private static readonly object Locker = new object();/// &lt;summary&gt;/// 数据库/// &lt;/summary&gt;private readonly IDatabase _db;#endregion private field#region 构造函数/// &lt;summary&gt;/// 构造函数/// &lt;/summary&gt;static RedisHelper()&#123; try &#123; ConnectionString = ConfigurationManager.ConnectionStrings["RedisConnectionString"].ConnectionString; &#125; catch (Exception) &#123; ConnectionString = "127.0.0.1:6379"; &#125; _connMultiplexer = ConnectionMultiplexer.Connect(ConnectionString); try &#123; DefaultKey = ConfigurationManager.AppSettings["Redis.DefaultKey"]; &#125; catch (Exception) &#123; DefaultKey = string.Empty; &#125; AddRegisterEvent();&#125;/// &lt;summary&gt;/// 构造函数/// &lt;/summary&gt;/// &lt;param name="db"&gt;&lt;/param&gt;public RedisHelper(int db = 0)&#123; _db = _connMultiplexer.GetDatabase(db);&#125;#endregion 构造函数#region String 操作/// &lt;summary&gt;/// 设置 key 并保存字符串（如果 key 已存在，则覆盖值）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool StringSet(string redisKey, string redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return _db.StringSet(redisKey, redisValue, expiry);&#125;/// &lt;summary&gt;/// 保存多个 Key-value/// &lt;/summary&gt;/// &lt;param name="keyValuePairs"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool StringSet(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; keyValuePairs)&#123; var pairs = keyValuePairs.Select(x =&gt; new KeyValuePair&lt;RedisKey, RedisValue&gt;(AddKeyPrefix(x.Key), x.Value)); return _db.StringSet(pairs.ToArray());&#125;/// &lt;summary&gt;/// 获取字符串/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string StringGet(string redisKey, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return _db.StringGet(redisKey);&#125;/// &lt;summary&gt;/// 存储一个对象（该对象会被序列化保存）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool StringSet&lt;T&gt;(string redisKey, T redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(redisValue); return _db.StringSet(redisKey, json, expiry);&#125;/// &lt;summary&gt;/// 获取一个对象（会进行反序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T StringGet&lt;T&gt;(string redisKey, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(_db.StringGet(redisKey));&#125;#region async/// &lt;summary&gt;/// 保存一个字符串值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; StringSetAsync(string redisKey, string redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.StringSetAsync(redisKey, redisValue, expiry);&#125;/// &lt;summary&gt;/// 保存一组字符串值/// &lt;/summary&gt;/// &lt;param name="keyValuePairs"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; StringSetAsync(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; keyValuePairs)&#123; var pairs = keyValuePairs.Select(x =&gt; new KeyValuePair&lt;RedisKey, RedisValue&gt;(AddKeyPrefix(x.Key), x.Value)); return await _db.StringSetAsync(pairs.ToArray());&#125;/// &lt;summary&gt;/// 获取单个值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;string&gt; StringGetAsync(string redisKey, string redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.StringGetAsync(redisKey);&#125;/// &lt;summary&gt;/// 存储一个对象（该对象会被序列化保存）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; StringSetAsync&lt;T&gt;(string redisKey, T redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(redisValue); return await _db.StringSetAsync(redisKey, json, expiry);&#125;/// &lt;summary&gt;/// 获取一个对象（会进行反序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;T&gt; StringGetAsync&lt;T&gt;(string redisKey, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(await _db.StringGetAsync(redisKey));&#125;#endregion async#endregion String 操作#region Hash 操作/// &lt;summary&gt;/// 判断该字段是否存在 hash 中/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool HashExists(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return _db.HashExists(redisKey, hashField);&#125;/// &lt;summary&gt;/// 从 hash 中移除指定字段/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool HashDelete(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return _db.HashDelete(redisKey, hashField);&#125;/// &lt;summary&gt;/// 从 hash 中移除指定字段/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long HashDelete(string redisKey, IEnumerable&lt;string&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var fields = hashFields.Select(x =&gt; (RedisValue)x); return _db.HashDelete(redisKey, fields.ToArray());&#125;/// &lt;summary&gt;/// 在 hash 设定值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool HashSet(string redisKey, string hashField, string value)&#123; redisKey = AddKeyPrefix(redisKey); return _db.HashSet(redisKey, hashField, value);&#125;/// &lt;summary&gt;/// 在 hash 中设定值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;public void HashSet(string redisKey, IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var entries = hashFields.Select(x =&gt; new HashEntry(x.Key, x.Value)); _db.HashSet(redisKey, entries.ToArray());&#125;/// &lt;summary&gt;/// 在 hash 中获取值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string HashGet(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return _db.HashGet(redisKey, hashField);&#125;/// &lt;summary&gt;/// 在 hash 中获取值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; HashGet(string redisKey, IEnumerable&lt;string&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var fields = hashFields.Select(x =&gt; (RedisValue)x); return ConvertStrings(_db.HashGet(redisKey, fields.ToArray()));&#125;/// &lt;summary&gt;/// 从 hash 返回所有的字段值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; HashKeys(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(_db.HashKeys(redisKey));&#125;/// &lt;summary&gt;/// 返回 hash 中的所有值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; HashValues(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(_db.HashValues(redisKey));&#125;/// &lt;summary&gt;/// 在 hash 设定值（序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool HashSet&lt;T&gt;(string redisKey, string hashField, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(redisValue); return _db.HashSet(redisKey, hashField, json);&#125;/// &lt;summary&gt;/// 在 hash 中获取值（反序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T HashGet&lt;T&gt;(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(_db.HashGet(redisKey, hashField));&#125;#region async/// &lt;summary&gt;/// 判断该字段是否存在 hash 中/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; HashExistsAsync(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.HashExistsAsync(redisKey, hashField);&#125;/// &lt;summary&gt;/// 从 hash 中移除指定字段/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; HashDeleteAsync(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.HashDeleteAsync(redisKey, hashField);&#125;/// &lt;summary&gt;/// 从 hash 中移除指定字段/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; HashDeleteAsync(string redisKey, IEnumerable&lt;string&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var fields = hashFields.Select(x =&gt; (RedisValue)x); return await _db.HashDeleteAsync(redisKey, fields.ToArray());&#125;/// &lt;summary&gt;/// 在 hash 设定值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; HashSetAsync(string redisKey, string hashField, string value)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.HashSetAsync(redisKey, hashField, value);&#125;/// &lt;summary&gt;/// 在 hash 中设定值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;public async Task HashSetAsync(string redisKey, IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var entries = hashFields.Select(x =&gt; new HashEntry(AddKeyPrefix(x.Key), x.Value)); await _db.HashSetAsync(redisKey, entries.ToArray());&#125;/// &lt;summary&gt;/// 在 hash 中获取值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;string&gt; HashGetAsync(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.HashGetAsync(redisKey, hashField);&#125;/// &lt;summary&gt;/// 在 hash 中获取值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; HashGetAsync(string redisKey, IEnumerable&lt;string&gt; hashFields, string value)&#123; redisKey = AddKeyPrefix(redisKey); var fields = hashFields.Select(x =&gt; (RedisValue)x); return ConvertStrings(await _db.HashGetAsync(redisKey, fields.ToArray()));&#125;/// &lt;summary&gt;/// 从 hash 返回所有的字段值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; HashKeysAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(await _db.HashKeysAsync(redisKey));&#125;/// &lt;summary&gt;/// 返回 hash 中的所有值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; HashValuesAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(await _db.HashValuesAsync(redisKey));&#125;/// &lt;summary&gt;/// 在 hash 设定值（序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; HashSetAsync&lt;T&gt;(string redisKey, string hashField, T value)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(value); return await _db.HashSetAsync(redisKey, hashField, json);&#125;/// &lt;summary&gt;/// 在 hash 中获取值（反序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;T&gt; HashGetAsync&lt;T&gt;(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(await _db.HashGetAsync(redisKey, hashField));&#125;#endregion async#endregion Hash 操作#region List 操作/// &lt;summary&gt;/// 移除并返回存储在该键列表的第一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string ListLeftPop(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListLeftPop(redisKey);&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的最后一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string ListRightPop(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListRightPop(redisKey);&#125;/// &lt;summary&gt;/// 移除列表指定键上与该值相同的元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListRemove(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListRemove(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 在列表尾部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListRightPush(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListRightPush(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 在列表头部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListLeftPush(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListLeftPush(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 返回列表上该键的长度，如果不存在，返回 0/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListLength(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListLength(redisKey);&#125;/// &lt;summary&gt;/// 返回在该列表上键所对应的元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="start"&gt;&lt;/param&gt;/// &lt;param name="stop"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; ListRange(string redisKey, long start = 0L, long stop = -1L)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(_db.ListRange(redisKey, start, stop));&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的第一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T ListLeftPop&lt;T&gt;(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(_db.ListLeftPop(redisKey));&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的最后一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T ListRightPop&lt;T&gt;(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(_db.ListRightPop(redisKey));&#125;/// &lt;summary&gt;/// 在列表尾部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListRightPush&lt;T&gt;(string redisKey, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListRightPush(redisKey, Serialize(redisValue));&#125;/// &lt;summary&gt;/// 在列表头部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListLeftPush&lt;T&gt;(string redisKey, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListLeftPush(redisKey, Serialize(redisValue));&#125;#region List-async/// &lt;summary&gt;/// 移除并返回存储在该键列表的第一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;string&gt; ListLeftPopAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListLeftPopAsync(redisKey);&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的最后一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;string&gt; ListRightPopAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListRightPopAsync(redisKey);&#125;/// &lt;summary&gt;/// 移除列表指定键上与该值相同的元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListRemoveAsync(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListRemoveAsync(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 在列表尾部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListRightPushAsync(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListRightPushAsync(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 在列表头部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListLeftPushAsync(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListLeftPushAsync(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 返回列表上该键的长度，如果不存在，返回 0/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListLengthAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListLengthAsync(redisKey);&#125;/// &lt;summary&gt;/// 返回在该列表上键所对应的元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="start"&gt;&lt;/param&gt;/// &lt;param name="stop"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; ListRangeAsync(string redisKey, long start = 0L, long stop = -1L)&#123; redisKey = AddKeyPrefix(redisKey); var query = await _db.ListRangeAsync(redisKey, start, stop); return query.Select(x =&gt; x.ToString());&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的第一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;T&gt; ListLeftPopAsync&lt;T&gt;(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(await _db.ListLeftPopAsync(redisKey));&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的最后一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;T&gt; ListRightPopAsync&lt;T&gt;(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(await _db.ListRightPopAsync(redisKey));&#125;/// &lt;summary&gt;/// 在列表尾部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListRightPushAsync&lt;T&gt;(string redisKey, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListRightPushAsync(redisKey, Serialize(redisValue));&#125;/// &lt;summary&gt;/// 在列表头部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListLeftPushAsync&lt;T&gt;(string redisKey, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListLeftPushAsync(redisKey, Serialize(redisValue));&#125;#endregion List-async#endregion List 操作#region SortedSet 操作/// &lt;summary&gt;/// SortedSet 新增/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="score"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool SortedSetAdd(string redisKey, string member, double score)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetAdd(redisKey, member, score);&#125;/// &lt;summary&gt;/// 在有序集合中返回指定范围的元素，默认情况下从低到高。/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="start"&gt;&lt;/param&gt;/// &lt;param name="stop"&gt;&lt;/param&gt;/// &lt;param name="order"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; SortedSetRangeByRank(string redisKey, long start = 0L, long stop = -1L, OrderType order = OrderType.Ascending)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetRangeByRank(redisKey, start, stop, (Order)order).Select(x =&gt; x.ToString());&#125;/// &lt;summary&gt;/// 返回有序集合的元素个数/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long SortedSetLength(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetLength(redisKey);&#125;/// &lt;summary&gt;/// 返回有序集合的元素个数/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="memebr"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool SortedSetLength(string redisKey, string memebr)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetRemove(redisKey, memebr);&#125;/// &lt;summary&gt;/// SortedSet 新增/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="score"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool SortedSetAdd&lt;T&gt;(string redisKey, T member, double score)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(member); return _db.SortedSetAdd(redisKey, json, score);&#125;/// &lt;summary&gt;/// 增量的得分排序的集合中的成员存储键值键按增量/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public double SortedSetIncrement(string redisKey, string member, double value = 1)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetIncrement(redisKey, member, value);&#125;#region SortedSet-Async/// &lt;summary&gt;/// SortedSet 新增/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="score"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; SortedSetAddAsync(string redisKey, string member, double score)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.SortedSetAddAsync(redisKey, member, score);&#125;/// &lt;summary&gt;/// 在有序集合中返回指定范围的元素，默认情况下从低到高。/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; SortedSetRangeByRankAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(await _db.SortedSetRangeByRankAsync(redisKey));&#125;/// &lt;summary&gt;/// 返回有序集合的元素个数/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; SortedSetLengthAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.SortedSetLengthAsync(redisKey);&#125;/// &lt;summary&gt;/// 返回有序集合的元素个数/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="memebr"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; SortedSetRemoveAsync(string redisKey, string memebr)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.SortedSetRemoveAsync(redisKey, memebr);&#125;/// &lt;summary&gt;/// SortedSet 新增/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="score"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; SortedSetAddAsync&lt;T&gt;(string redisKey, T member, double score)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(member); return await _db.SortedSetAddAsync(redisKey, json, score);&#125;/// &lt;summary&gt;/// 增量的得分排序的集合中的成员存储键值键按增量/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public Task&lt;double&gt; SortedSetIncrementAsync(string redisKey, string member, double value = 1)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetIncrementAsync(redisKey, member, value);&#125;#endregion SortedSet-Async#endregion SortedSet 操作#region key 操作/// &lt;summary&gt;/// 移除指定 Key/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool KeyDelete(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.KeyDelete(redisKey);&#125;/// &lt;summary&gt;/// 移除指定 Key/// &lt;/summary&gt;/// &lt;param name="redisKeys"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long KeyDelete(IEnumerable&lt;string&gt; redisKeys)&#123; var keys = redisKeys.Select(x =&gt; (RedisKey)AddKeyPrefix(x)); return _db.KeyDelete(keys.ToArray());&#125;/// &lt;summary&gt;/// 校验 Key 是否存在/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool KeyExists(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.KeyExists(redisKey);&#125;/// &lt;summary&gt;/// 重命名 Key/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisNewKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool KeyRename(string redisKey, string redisNewKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.KeyRename(redisKey, redisNewKey);&#125;/// &lt;summary&gt;/// 设置 Key 的时间/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool KeyExpire(string redisKey, TimeSpan? expiry)&#123; redisKey = AddKeyPrefix(redisKey); return _db.KeyExpire(redisKey, expiry);&#125;#region key-async/// &lt;summary&gt;/// 移除指定 Key/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; KeyDeleteAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.KeyDeleteAsync(redisKey);&#125;/// &lt;summary&gt;/// 移除指定 Key/// &lt;/summary&gt;/// &lt;param name="redisKeys"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; KeyDeleteAsync(IEnumerable&lt;string&gt; redisKeys)&#123; var keys = redisKeys.Select(x =&gt; (RedisKey)AddKeyPrefix(x)); return await _db.KeyDeleteAsync(keys.ToArray());&#125;/// &lt;summary&gt;/// 校验 Key 是否存在/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; KeyExistsAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.KeyExistsAsync(redisKey);&#125;/// &lt;summary&gt;/// 重命名 Key/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisNewKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; KeyRenameAsync(string redisKey, string redisNewKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.KeyRenameAsync(redisKey, redisNewKey);&#125;/// &lt;summary&gt;/// 设置 Key 的时间/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; KeyExpireAsync(string redisKey, TimeSpan? expiry)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.KeyExpireAsync(redisKey, expiry);&#125;#endregion key-async#endregion key 操作#region private method/// &lt;summary&gt;/// 添加 Key 的前缀/// &lt;/summary&gt;/// &lt;param name="key"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static string AddKeyPrefix(string key)&#123; return $"&#123;DefaultKey&#125;&#123;key&#125;";&#125;/// &lt;summary&gt;/// 转换为字符串/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;/// &lt;param name="list"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static IEnumerable&lt;string&gt; ConvertStrings&lt;T&gt;(IEnumerable&lt;T&gt; list) where T : struct&#123; if (list == null) throw new ArgumentNullException(nameof(list)); return list.Select(x =&gt; x.ToString());&#125;#region 注册事件/// &lt;summary&gt;/// 添加注册事件/// &lt;/summary&gt;private static void AddRegisterEvent()&#123; _connMultiplexer.ConnectionRestored += ConnMultiplexer_ConnectionRestored; _connMultiplexer.ConnectionFailed += ConnMultiplexer_ConnectionFailed; _connMultiplexer.ErrorMessage += ConnMultiplexer_ErrorMessage; _connMultiplexer.ConfigurationChanged += ConnMultiplexer_ConfigurationChanged; _connMultiplexer.HashSlotMoved += ConnMultiplexer_HashSlotMoved; _connMultiplexer.InternalError += ConnMultiplexer_InternalError; _connMultiplexer.ConfigurationChangedBroadcast += ConnMultiplexer_ConfigurationChangedBroadcast;&#125;/// &lt;summary&gt;/// 重新配置广播时（通常意味着主从同步更改）/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ConfigurationChangedBroadcast(object sender, EndPointEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ConfigurationChangedBroadcast)&#125;: &#123;e.EndPoint&#125;");&#125;/// &lt;summary&gt;/// 发生内部错误时（主要用于调试）/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_InternalError(object sender, InternalErrorEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_InternalError)&#125;: &#123;e.Exception&#125;");&#125;/// &lt;summary&gt;/// 更改集群时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_HashSlotMoved(object sender, HashSlotMovedEventArgs e)&#123; Console.WriteLine( $"&#123;nameof(ConnMultiplexer_HashSlotMoved)&#125;: &#123;nameof(e.OldEndPoint)&#125;-&#123;e.OldEndPoint&#125; To &#123;nameof(e.NewEndPoint)&#125;-&#123;e.NewEndPoint&#125;, ");&#125;/// &lt;summary&gt;/// 配置更改时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ConfigurationChanged(object sender, EndPointEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ConfigurationChanged)&#125;: &#123;e.EndPoint&#125;");&#125;/// &lt;summary&gt;/// 发生错误时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ErrorMessage(object sender, RedisErrorEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ErrorMessage)&#125;: &#123;e.Message&#125;");&#125;/// &lt;summary&gt;/// 物理连接失败时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ConnectionFailed(object sender, ConnectionFailedEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ConnectionFailed)&#125;: &#123;e.Exception&#125;");&#125;/// &lt;summary&gt;/// 建立物理连接时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ConnectionRestored(object sender, ConnectionFailedEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ConnectionRestored)&#125;: &#123;e.Exception&#125;");&#125;#endregion 注册事件/// &lt;summary&gt;/// 序列化/// &lt;/summary&gt;/// &lt;param name="obj"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static byte[] Serialize(object obj)&#123; if (obj == null) return null; var binaryFormatter = new BinaryFormatter(); using (var memoryStream = new MemoryStream()) &#123; binaryFormatter.Serialize(memoryStream, obj); var data = memoryStream.ToArray(); return data; &#125;&#125;/// &lt;summary&gt;/// 反序列化/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;/// &lt;param name="data"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static T Deserialize&lt;T&gt;(byte[] data)&#123; if (data == null) return default(T); var binaryFormatter = new BinaryFormatter(); using (var memoryStream = new MemoryStream(data)) &#123; var result = (T)binaryFormatter.Deserialize(memoryStream); return result; &#125;&#125;#endregion private method 2018年9月6日补充方法：获得所有Key/Key-Value123456789101112131415161718192021222324252627282930313233/// &lt;summary&gt;/// 获得Redis所有Key值/// &lt;/summary&gt;/// &lt;returns&gt;Redis所有Key值&lt;/returns&gt;public List&lt;string&gt; GetAllKeys()&#123; List&lt;string&gt; keyList = new List&lt;string&gt;(); foreach (var ep in _connMultiplexer.GetEndPoints()) &#123; var server = _connMultiplexer.GetServer(ep); var keys = server.Keys(0, "*"); foreach (var item in keys) &#123; keyList.Add((string)item); &#125; &#125; return keyList;&#125;/// &lt;summary&gt;/// 获得Redis所有Key值和Value值/// &lt;/summary&gt;/// &lt;returns&gt;Redis所有Key值和Value值&lt;/returns&gt;public Dictionary&lt;string, string&gt; GetAllKeysValues()&#123; Dictionary&lt;string, string&gt; dicAllKeysValues = new Dictionary&lt;string, string&gt;(); List&lt;string&gt; listAllKeys = GetAllKeys(); foreach (var item in listAllKeys) &#123; dicAllKeysValues.Add(item, StringGet(item)); &#125; return dicAllKeysValues;&#125; 错误处理Redis错误信息：MISCONG Redis is configured to save RDB执行：config set stop-writes-on-bgsave-error no]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ Demo]]></title>
    <url>%2Fblog%2F2018%2F07%2F07%2Fcsharp-RabbitMQ%2F</url>
    <content type="text"><![CDATA[RabbitMQ 消息队列使用介绍 简介RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。具备异步、解耦等机制。RabbitMQ在全球范围内在小型初创公司和大型企业中进行了超过35,000次RabbitMQ生产部署，是最受欢迎的开源消息代理。RabbitMQ轻量级，易于在内部和云中部署。它支持多种消息传递协议。RabbitMQ可以部署在分布式和联合配置中，以满足高规模，高可用性要求。RabbitMQ可在许多操作系统和云环境中运行，并为大多数流行语言提供各种开发人员工具。 安装部署请参阅官方文档 Docker 部署12345678安装官方镜像docker pull rabbitmq启动 RabbitMQdocker run -d --name myrabbitmq -p 5672:5672 -p 15672:15672 docker.io/rabbitmq:3-management设置 RabbitMQ 默认账户密码为 guest/guestdocker run -d --hostname my-rabbit --name some-rabbit -e RABBITMQ_DEFAULT_USER=user -e RABBITMQ_DEFAULT_PASS=password rabbitmq:3-managementWEB 端登录http://localhost:15672/#/ C#代码调用引用 RabbitMQ.Client 库 生产者123456789101112131415161718192021/// &lt;summary&gt;/// 生产者/// &lt;/summary&gt;public static void Send()&#123; var factory = new ConnectionFactory() &#123; HostName = "localhost" &#125;; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) &#123; channel.QueueDeclare(queue: "hello", durable: false, exclusive: false, autoDelete: false, arguments: null); string message = "Hello World!"; var body = Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchange: "", routingKey: "hello", basicProperties: null, body: body); Console.WriteLine(" [x] Sent &#123;0&#125;", message); &#125; Console.WriteLine(" Press [enter] to exit."); Console.ReadLine();&#125; 消费者123456789101112131415161718192021222324/// &lt;summary&gt;/// 消费者/// &lt;/summary&gt;public static void Receive()&#123; var factory = new ConnectionFactory() &#123; HostName = "localhost" &#125;; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) &#123; channel.QueueDeclare(queue: "hello", durable: false, exclusive: false, autoDelete: false, arguments: null); var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =&gt; &#123; var body = ea.Body; var message = Encoding.UTF8.GetString(body); Console.WriteLine(" [x] Received &#123;0&#125;", message); &#125;; channel.BasicConsume(queue: "hello", autoAck: true, consumer: consumer); Console.WriteLine(" Press [enter] to exit."); Console.ReadLine(); &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EntityFramework Demo]]></title>
    <url>%2Fblog%2F2018%2F07%2F02%2Fcsharp-EntityFramework%2F</url>
    <content type="text"><![CDATA[EntityFramework 框架使用介绍 简介Entity Framework 是微软以 ADO.NET 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案。在.NET 3.5之前，开发者通常使用 ADO.NET 直接连接操作数据库，而Entity Framework的出现可以让开发者更多的从代码层面考虑数据交互，Entity Framework 会把字段映射为实体模型，通过 Lambda表达式 来操作数据，不需要考虑各种类型数据库和拼写SQL语句。同时也有效的防止了 SQL注入。 搭建-以MySQL为例类库或应用程序项目下新建项 实体模型向导从EF 4.X开始支持三种构建方法：Database First：数据库优先，你的项目已经有一个数据库，并且使用工具（如Visual Studio中的EF设计器)依据数据库生成C#或VB类。你可以通过EF设计器修改这些创建的类以及类和数据库之间的映射关系；这种方式的关键是先要有数据，然后才有代码和模型。Model First：模型优先，通过在EF设计器中创建一个空的容器，在其中设计实体数据模型。这个模型将用于生成数据库以及C#或者VB类。这种方式的关键是先要有模型，然后才有数据库和代码。Code First：代码优先，开发者只需要写代码，将会自动创建模型和数据库。现采用基础又最常用的 Database First 方式创建！ 更改数据源连接MySQL需要单独安装 mysql-connector-net 与 mysql-for-visualstudio 修改连接属性 添加连接串 选择框架版本 添加数据库表模型，完成 如果出现闪退、无法编辑数据，尝试修改引用库版本EntityFramework：6.0.0.0EntityFramework.SqlServer：6.0.0.0MySql.Data：6.9.9.0MySql.Data.Entity.EF6：6.9.9.0 增删改查12345678910111213141516//新增officeautomationEntities ef = new officeautomationEntities();user_info user = new user_info();user.UserName = "00006";user.Password = "123456";ef.user_info.Add(user);ef.SaveChanges();//修改var query = ef.user_info.Where(o =&gt; o.UserName.Equals("00006")).FirstOrDefault();query.Password = "mq1i1JC92zal7nnbFZjtPQ==";ef.SaveChanges();//删除ef.user_info.Remove(query);ef.SaveChanges();//查询var v = ef.user_info.Where(o =&gt; o.UserName.Equals("00003")).ToList(); 错误及处理EF创建时崩溃MySql引用库版本修改为6.9.9 报错：Host “”is not allowed to connect to this MySQL server123grant all privileges on *.* to 'root'@'192.168.0.1' identified by '密码';grant all privileges on *.* to 'root'@'%' identified by '密码';flush privileges; 报错：Mysql表 “TableDetails” 中列 “IsPrimaryKey” 的值位 DBNull。123use 库名;SET GLOBAL optimizer_switch='derived_merge=off';SET optimizer_switch='derived_merge=off'; 报错：其他信息: 对一个或多个实体的验证失败。有关详细信息，请参见“EntityValidationErrors”属性。写入数据与表设定不一致SaveChanges();方法前后使用：Configuration.ValidateOnSaveEnabled123ef.Configuration.ValidateOnSaveEnabled = false;ef.SaveChanges();ef.Configuration.ValidateOnSaveEnabled = true;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>mysql</tag>
        <tag>ef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地林伟业科技股份有限公司]]></title>
    <url>%2Fblog%2F2018%2F05%2F28%2Fwork-Forestar%2F</url>
    <content type="text"><![CDATA[基于 ArcGIS 和公司自主平台 Mapzone 进行地理信息系统二次开发个人简介2016年06月28日 - 2018年06月28日 就职于 北京地林伟业科技股份有限公司 软件研发工程师岗位。 公司简介北京地林伟业科技股份有限公司（简称“地林伟业”，股票代码：430416），是“互联网+”林业信息化服务提供商，为用户提供林业信息化全方位解决方案，经过10余年的不懈努力,地林伟业在各项业务上都取得了长足发展，成为林业信息化领域的翘楚。 公司有自主研发的MAPZONE GIS系列产品，包括桌面产品MAPZONE Desktop、移动产品MAPZONE Mobile、服务端产品MAPZONE Server、三维产品MAPZONE Globe以及相应的开发包MAPZONE SDK。 公司在自主技术的基础上，研发了FORESTAR应用平台系列产品，包括FORESTAR GIS应用平台、FORESTAR二三维一体化平台、共享服务平台、综合信息应用服务平台、电子政务平台、FORESTAR OA网络办公平台、林业应用支撑平台，为林业行业提供了从移动端、Web端、桌面端、服务器端的完整解决方案。 公司经过多年的积累，为整个“互联网+”林业信息化提供了一整套解决方案，包括“互联网+”林业资源监管解决方案、“互联网+”生态修复工程解决方案、“互联网+”灾害应急工程解决方案、“互联网+”林业改革创新解决方案、“互联网+”林业产业提升解决方案、“互联网+”公共服务建设解决方案、“互联网+”林业政务服务解决方案、“互联网+”基础能力建设解决方案。 项目介绍（由于签署保密协议，仅介绍大致工作内容）由 C# + WinForm + DevExpress 开发基于 ArcGIS 与公司自主研发 MAPZONE GIS 的地理信息系统。参与过主要的项目有：林地更新、二类调查、农村土地确权。工作主要开发C/S端程序，并且与Android端与B/S端开发人员对接。由于B/S端同事不熟悉 Lambda 表达式 所以在功能迁移的时候使用 JAVA 开发了一段时间 Web API。大量使用 NPOI/DOCX 技术导出报表及合同证书。带领帮助初级开发人员解决问题。]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>mysql</tag>
        <tag>sqlite</tag>
        <tag>winform</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[类库项目中新增 WPF 窗口]]></title>
    <url>%2Fblog%2F2018%2F05%2F27%2Fcsharp-CSProjGUID%2F</url>
    <content type="text"><![CDATA[新创建类库只能添加 WPF 用户控件，无法添加 WPF 窗体 通过修改 .csproj 配置文件使类库可以创建 WPF 窗体 修改方法组合使用 GUID，新增 ProjectTypeGuids 节点描述一个类库为 C# WPF 类型新增节点 ProjectTypeGuids 至 .csproj 配置文件 Project.PropertyGroup 下1&lt;ProjectTypeGuids&gt;&#123;60dc8134-eba5-43b8-bcc9-bb4bc16c2548&#125;;&#123;FAE04EC0-301F-11D3-BF4B-00C04F79EFBC&#125;&lt;/ProjectTypeGuids&gt; 完整的 .csproj 文件中的 GUID 列表及其说明参考资料创建项目后，没有一种简单的方法可以在 Visual Studio 项目中更改项目类型。例如，将C＃类库更改为可移植类库（PCL）。了解这些GUID将允许您编辑项目文件 .csproj，.vbproj 以便在 Visual Studio 不允许使用 GUI 的情况下轻松更改项目类型。 By Description Name Guid ASP.NET 5 {8BB2217D-0F2D-49D1-97BC-3654ED321F3B} ASP.NET MVC 1 {603C0E0B-DB56-11DC-BE95-000D561079B0} ASP.NET MVC 2 {F85E285D-A4E0-4152-9332-AB1D724D3325} ASP.NET MVC 3 {E53F8FEA-EAE0-44A6-8774-FFD645390401} ASP.NET MVC 4 {E3E379DF-F4C6-4180-9B81-6769533ABE47} ASP.NET MVC 5 {349C5851-65DF-11DA-9384-00065B846F21} C# {FAE04EC0-301F-11D3-BF4B-00C04F79EFBC} C++ {8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942} Database {A9ACE9BB-CECE-4E62-9AA4-C7E7C5BD2124} Database (other project types) {4F174C21-8C12-11D0-8340-0000F80270F8} Deployment Cab {3EA9E505-35AC-4774-B492-AD1749C4943A} Deployment Merge Module {06A35CCD-C46D-44D5-987B-CF40FF872267} Deployment Setup {978C614F-708E-4E1A-B201-565925725DBA} Deployment Smart Device Cab {AB322303-2255-48EF-A496-5904EB18DA55} Distributed System {F135691A-BF7E-435D-8960-F99683D2D49C} Dynamics 2012 AX C# in AOT {BF6F8E12-879D-49E7-ADF0-5503146B24B8} F# {F2A71F9B-5D33-465A-A702-920D77279786} J# {E6FDF86B-F3D1-11D4-8576-0002A516ECE8} Legacy (2003) Smart Device (C#) {20D4826A-C6FA-45DB-90F4-C717570B9F32} Legacy (2003) Smart Device (VB.NET) {CB4CE8C6-1BDB-4DC7-A4D3-65A1999772F8} Micro Framework {b69e3092-b931-443c-abe7-7e7b65f2a37f} Model-View-Controller v2 (MVC 2) {F85E285D-A4E0-4152-9332-AB1D724D3325} Model-View-Controller v3 (MVC 3) {E53F8FEA-EAE0-44A6-8774-FFD645390401} Model-View-Controller v4 (MVC 4) {E3E379DF-F4C6-4180-9B81-6769533ABE47} Model-View-Controller v5 (MVC 5) {349C5851-65DF-11DA-9384-00065B846F21} Mono for Android {EFBA0AD7-5A72-4C68-AF49-83D382785DCF} MonoTouch {6BC8ED88-2882-458C-8E55-DFD12B67127B} MonoTouch Binding {F5B4F3BC-B597-4E2B-B552-EF5D8A32436F} Portable Class Library {786C830F-07A1-408B-BD7F-6EE04809D6DB} Project Folders {66A26720-8FB5-11D2-AA7E-00C04F688DDE} SharePoint (C#) {593B0543-81F6-4436-BA1E-4747859CAAE2} SharePoint (VB.NET) {EC05E597-79D4-47f3-ADA0-324C4F7C7484} SharePoint Workflow {F8810EC1-6754-47FC-A15F-DFABD2E3FA90} Silverlight {A1591282-1198-4647-A2B1-27E5FF5F6F3B} Smart Device (C#) {4D628B5B-2FBC-4AA6-8C16-197242AEB884} Smart Device (VB.NET) {68B1623D-7FB9-47D8-8664-7ECEA3297D4F} Solution Folder {2150E333-8FDC-42A3-9474-1A3956D46DE8} Test {3AC096D0-A1C2-E12C-1390-A8335801FDAB} Universal Windows Class Library {A5A43C5B-DE2A-4C0C-9213-0A381AF9435A} VB.NET {F184B08F-C81C-45F6-A57F-5ABD9991F28F} Visual Database Tools {C252FEB5-A946-4202-B1D4-9916A0590387} Visual Studio 2015 Installer Project Extension {54435603-DBB4-11D2-8724-00A0C9A8B90C} Visual Studio Tools for Applications (VSTA) {A860303F-1F3F-4691-B57E-529FC101A107} Visual Studio Tools for Office (VSTO) {BAA0C2D2-18E2-41B9-852F-F413020CAA33} Web Application {349C5851-65DF-11DA-9384-00065B846F21} Web Site {E24C65DC-7377-472B-9ABA-BC803B73C61A} Windows (C#) {FAE04EC0-301F-11D3-BF4B-00C04F79EFBC} Windows (VB.NET) {F184B08F-C81C-45F6-A57F-5ABD9991F28F} Windows (Visual C++) {8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942} Windows Communication Foundation (WCF) {3D9AD99F-2412-4246-B90B-4EAA41C64699} Windows Phone 8/8.1 Blank/Hub/Webview App {76F1466A-8B6D-4E39-A767-685A06062A39} Windows Phone 8/8.1 App (C#) {C089C8C0-30E0-4E22-80C0-CE093F111A43} Windows Phone 8/8.1 App (VB.NET) {DB03555F-0C8B-43BE-9FF9-57896B3C5E56} Windows Presentation Foundation (WPF) {60DC8134-EBA5-43B8-BCC9-BB4BC16C2548} Windows Store (Metro) Apps &amp; Components {BC8A1FFA-BEE3-4634-8014-F334798102B3} Workflow (C#) {14822709-B5A1-4724-98CA-57A101D1B079} Workflow (VB.NET) {D59BE175-2ED0-4C54-BE3D-CDAA9F3214C8} Workflow Foundation {32F31D43-81CC-4C15-9DE6-3FC5453562B6} Xamarin.Android {EFBA0AD7-5A72-4C68-AF49-83D382785DCF} Xamarin.iOS {6BC8ED88-2882-458C-8E55-DFD12B67127B} XNA (Windows) {6D335F3A-9D43-41b4-9D22-F6F17C4BE596} XNA (XBox) {2DF5C3F4-5A5F-47a9-8E94-23B4456F55E2} XNA (Zune) {D399B71A-8929-442a-A9AC-8BEC78BB2433} By GUID Name Guid Deployment Merge Module {06A35CCD-C46D-44D5-987B-CF40FF872267} Workflow (C#) {14822709-B5A1-4724-98CA-57A101D1B079} Legacy (2003) Smart Device (C#) {20D4826A-C6FA-45DB-90F4-C717570B9F32} Solution Folder {2150E333-8FDC-42A3-9474-1A3956D46DE8} XNA (XBox) {2DF5C3F4-5A5F-47a9-8E94-23B4456F55E2} Workflow Foundation {32F31D43-81CC-4C15-9DE6-3FC5453562B6} Web Application (incl. MVC 5) {349C5851-65DF-11DA-9384-00065B846F21} Test {3AC096D0-A1C2-E12C-1390-A8335801FDAB} Windows Communication Foundation (WCF) {3D9AD99F-2412-4246-B90B-4EAA41C64699} Deployment Cab {3EA9E505-35AC-4774-B492-AD1749C4943A} Smart Device (C#) {4D628B5B-2FBC-4AA6-8C16-197242AEB884} Database (other project types) {4F174C21-8C12-11D0-8340-0000F80270F8} Visual Studio 2015 Installer Project Extension {54435603-DBB4-11D2-8724-00A0C9A8B90C} SharePoint (C#) {593B0543-81F6-4436-BA1E-4747859CAAE2} ASP.NET MVC 1.0 {603C0E0B-DB56-11DC-BE95-000D561079B0} Windows Presentation Foundation (WPF) {60DC8134-EBA5-43B8-BCC9-BB4BC16C2548} Smart Device (VB.NET) {68B1623D-7FB9-47D8-8664-7ECEA3297D4F} Project Folders {66A26720-8FB5-11D2-AA7E-00C04F688DDE} MonoTouch {6BC8ED88-2882-458C-8E55-DFD12B67127B} XNA (Windows) {6D335F3A-9D43-41b4-9D22-F6F17C4BE596} Windows Phone 8/8.1 Blank/Hub/Webview App {76F1466A-8B6D-4E39-A767-685A06062A39} Portable Class Library {786C830F-07A1-408B-BD7F-6EE04809D6DB} ASP.NET 5 {8BB2217D-0F2D-49D1-97BC-3654ED321F3B} C++ {8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942} Deployment Setup {978C614F-708E-4E1A-B201-565925725DBA} Silverlight {A1591282-1198-4647-A2B1-27E5FF5F6F3B} Universal Windows Class Library {A5A43C5B-DE2A-4C0C-9213-0A381AF9435A} Visual Studio Tools for Applications (VSTA) {A860303F-1F3F-4691-B57E-529FC101A107} Database {A9ACE9BB-CECE-4E62-9AA4-C7E7C5BD2124} Deployment Smart Device Cab {AB322303-2255-48EF-A496-5904EB18DA55} Micro Frmeworkv {B69E3092-B931-443C-ABE7-7E7B65F2A37F} Visual Studio Tools for Office (VSTO) {BAA0C2D2-18E2-41B9-852F-F413020CAA33} Windows Store Apps (Metro Apps) {BC8A1FFA-BEE3-4634-8014-F334798102B3} C# in Dynamics 2012 AX AOT {BF6F8E12-879D-49E7-ADF0-5503146B24B8} Windows Phone 8/8.1 App (C#) {C089C8C0-30E0-4E22-80C0-CE093F111A43} Visual Database Tools {C252FEB5-A946-4202-B1D4-9916A0590387} Legacy (2003) Smart Device (VB.NET) {CB4CE8C6-1BDB-4DC7-A4D3-65A1999772F8} XNA (Zune) {D399B71A-8929-442a-A9AC-8BEC78BB2433} Workflow (VB.NET) {D59BE175-2ED0-4C54-BE3D-CDAA9F3214C8} Windows Phone 8/8.1 App (VB.NET) {DB03555F-0C8B-43BE-9FF9-57896B3C5E56} Web Site {E24C65DC-7377-472B-9ABA-BC803B73C61A} ASP.NET MVC 4.0 {E3E379DF-F4C6-4180-9B81-6769533ABE47} ASP.NET MVC 3.0 {E53F8FEA-EAE0-44A6-8774-FFD645390401} J# {E6FDF86B-F3D1-11D4-8576-0002A516ECE8} SharePoint (VB.NET) {EC05E597-79D4-47f3-ADA0-324C4F7C7484} Xamarin.Android / Mono for Android {EFBA0AD7-5A72-4C68-AF49-83D382785DCF} Distributed System {F135691A-BF7E-435D-8960-F99683D2D49C} VB.NET {F184B08F-C81C-45F6-A57F-5ABD9991F28F} F# {F2A71F9B-5D33-465A-A702-920D77279786} MonoTouch Binding {F5B4F3BC-B597-4E2B-B552-EF5D8A32436F} ASP.NET MVC 2.0 {F85E285D-A4E0-4152-9332-AB1D724D3325} SharePoint Workflow {F8810EC1-6754-47FC-A15F-DFABD2E3FA90} C# {FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>wpf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密解密帮助类]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2Fcsharp-EncryptionHelper%2F</url>
    <content type="text"><![CDATA[提供几种对称加密与非对称加密算法，以及单项加密与文件夹加密简介工作中需要各种方式的加密（传输文本加密，文件加密，图片Base64编码，文件MD5与SHA1值计算），既有对称式加密与非对称式加密，也有单向加密，应用于各种使用环境。 警告由于2017年5月12日的比特币勒索病毒 WannaCry 爆发，100多个国家和地区超过10万台电脑遭到了勒索病毒攻击、感染。其原理就是加密电脑中的文件，以用秘钥勒索比特币。技术本质并无好坏之分，多行善事。 帮助类、介绍对称式加密对称加密算法 解密使用相同密钥及相同算法的逆算法对密文进行解密。 AESAES 一种区块加密标准，替代原先的DES，对称密钥加密中最流行的算法之一。AESHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/// &lt;summary&gt;/// AES加密/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥&lt;/param&gt;/// &lt;returns&gt;AES密文&lt;/returns&gt;public static string AESEncrypt(string strPlaintext, string strKey)&#123; try &#123; if (string.IsNullOrEmpty(strPlaintext)) &#123; return string.Empty; &#125; strKey = strKey.Length &lt; 32 ? strKey.PadRight(32, '0') : strKey.Substring(0, 32); Byte[] toEncryptArray = Encoding.UTF8.GetBytes(strPlaintext); RijndaelManaged rijndaelManaged = new RijndaelManaged &#123; Key = Encoding.UTF8.GetBytes(strKey), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 &#125;; ICryptoTransform pCryptoTransform = rijndaelManaged.CreateEncryptor(); Byte[] resultArray = pCryptoTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return Convert.ToBase64String(resultArray, 0, resultArray.Length); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// AES解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;AES密文&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥&lt;/param&gt;/// &lt;returns&gt;明文&lt;/returns&gt;public static string AESDecrypt(string strCiphertext, string strKey)&#123; try &#123; if (string.IsNullOrEmpty(strCiphertext)) &#123; return string.Empty; &#125; strKey = strKey.Length &lt; 32 ? strKey.PadRight(32, '0') : strKey.Substring(0, 32); Byte[] toEncryptArray = Convert.FromBase64String(strCiphertext); RijndaelManaged rijndaelManaged = new RijndaelManaged &#123; Key = Encoding.UTF8.GetBytes(strKey), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 &#125;; ICryptoTransform pCryptoTransform = rijndaelManaged.CreateDecryptor(); Byte[] resultArray = pCryptoTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return Encoding.UTF8.GetString(resultArray); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 文件AES加密/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;加密文件目录&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FileAESEncrypt(string strFilePath, string strSaveFilePath, string strKey)&#123; try &#123; //设置Aes秘钥和格式 strKey = strKey.Length &lt; 32 ? strKey.PadRight(32, '0') : strKey.Substring(0, 32); RijndaelManaged rijndaelManaged = new RijndaelManaged &#123; Key = Encoding.UTF8.GetBytes(strKey), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 &#125;; //读取文本加密数据 FileStream fileStream = File.OpenRead(strFilePath); byte[] byteFileStream = new byte[fileStream.Length]; fileStream.Read(byteFileStream, 0, (int)fileStream.Length); fileStream.Close(); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteFileStream, 0, byteFileStream.Length); cryptoStream.FlushFinalBlock(); fileStream = File.OpenWrite(strSaveFilePath); foreach (byte byteMemoryStream in memoryStream.ToArray()) &#123; fileStream.WriteByte(byteMemoryStream); &#125; fileStream.Close(); cryptoStream.Close(); memoryStream.Close(); return true; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件AES解密/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;被加密的文件路径&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;解密文件目录&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FileAESDecrypt(string strFilePath, string strSaveFilePath, string strKey)&#123; try &#123; strKey = strKey.Length &lt; 32 ? strKey.PadRight(32, '0') : strKey.Substring(0, 32); RijndaelManaged rijndaelManaged = new RijndaelManaged &#123; Key = Encoding.UTF8.GetBytes(strKey), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 &#125;; FileStream fileStream = File.OpenRead(strFilePath); byte[] byteFileStream = new byte[fileStream.Length]; fileStream.Read(byteFileStream, 0, (int)fileStream.Length); fileStream.Close(); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteFileStream, 0, byteFileStream.Length); cryptoStream.FlushFinalBlock(); fileStream = File.OpenWrite(strSaveFilePath); foreach (byte byteMemoryStream in memoryStream.ToArray()) &#123; fileStream.WriteByte(byteMemoryStream); &#125; fileStream.Close(); cryptoStream.Close(); memoryStream.Close(); return true; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; DESDES 一种使用密钥加密的块算法,1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用。DESHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/// &lt;summary&gt;/// DES加密/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥(8位)&lt;/param&gt;/// &lt;param name="strIV"&gt;向量(8位)&lt;/param&gt;/// &lt;returns&gt;DES密文&lt;/returns&gt;public static string DESEncrypt(string strPlaintext, string strKey, string strIV)&#123; try &#123; DESCryptoServiceProvider desCrypto = new DESCryptoServiceProvider(); desCrypto.Key = UTF8Encoding.Default.GetBytes(strKey); desCrypto.IV = UTF8Encoding.UTF8.GetBytes(strIV); using (ICryptoTransform cryptoTransform = desCrypto.CreateEncryptor()) &#123; byte[] byteBaseUTF8 = Encoding.UTF8.GetBytes(strPlaintext); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteBaseUTF8, 0, byteBaseUTF8.Length); cryptoStream.FlushFinalBlock(); &#125; return Convert.ToBase64String(memoryStream.ToArray()); &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// DES解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;DES密文&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥(8位)&lt;/param&gt;/// &lt;param name="strIV"&gt;向量(8位)&lt;/param&gt;/// &lt;returns&gt;明文&lt;/returns&gt;public static string DESDecrypt(string strCiphertext, string strKey, string strIV)&#123; try &#123; DESCryptoServiceProvider desCrypto = new DESCryptoServiceProvider(); desCrypto.Key = UTF8Encoding.Default.GetBytes(strKey); desCrypto.IV = UTF8Encoding.UTF8.GetBytes(strIV); using (ICryptoTransform cryptoTransform = desCrypto.CreateDecryptor()) &#123; byte[] byteBase64 = Convert.FromBase64String(strCiphertext); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteBase64, 0, byteBase64.Length); cryptoStream.FlushFinalBlock(); &#125; return Encoding.UTF8.GetString(memoryStream.ToArray()); &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 文件DES加密/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;加密文件目录&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥(8位)&lt;/param&gt;/// &lt;param name="strIV"&gt;向量(8位)&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FileDESEncrypt(string strFilePath, string strSaveFilePath, string strKey, string strIV)&#123; try &#123; DESCryptoServiceProvider desCrypto = new DESCryptoServiceProvider(); desCrypto.Key = UTF8Encoding.Default.GetBytes(strKey); desCrypto.IV = UTF8Encoding.UTF8.GetBytes(strIV); FileStream fileStream = File.OpenRead(strFilePath); byte[] byteFileStream = new byte[fileStream.Length]; fileStream.Read(byteFileStream, 0, (int)fileStream.Length); fileStream.Close(); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, desCrypto.CreateEncryptor(), CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteFileStream, 0, byteFileStream.Length); cryptoStream.FlushFinalBlock(); fileStream = File.OpenWrite(strSaveFilePath); foreach (byte byteMemoryStream in memoryStream.ToArray()) &#123; fileStream.WriteByte(byteMemoryStream); &#125; fileStream.Close(); cryptoStream.Close(); memoryStream.Close(); return true; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件DES解密/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;被加密的文件路径&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;解密文件目录&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥(8位)&lt;/param&gt;/// &lt;param name="strIV"&gt;向量(8位)&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FileDESDecrypt(string strFilePath, string strSaveFilePath, string strKey, string strIV)&#123; try &#123; DESCryptoServiceProvider desCrypto = new DESCryptoServiceProvider(); desCrypto.Key = UTF8Encoding.Default.GetBytes(strKey); desCrypto.IV = UTF8Encoding.UTF8.GetBytes(strIV); FileStream fileStream = File.OpenRead(strFilePath); byte[] byteFileStream = new byte[fileStream.Length]; fileStream.Read(byteFileStream, 0, (int)fileStream.Length); fileStream.Close(); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, desCrypto.CreateDecryptor(), CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteFileStream, 0, byteFileStream.Length); cryptoStream.FlushFinalBlock(); fileStream = File.OpenWrite(strSaveFilePath); foreach (byte byteMemoryStream in memoryStream.ToArray()) &#123; fileStream.WriteByte(byteMemoryStream); &#125; fileStream.Close(); cryptoStream.Close(); memoryStream.Close(); return true; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; 非对称式加密非对称加密算法 需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。 RSARSA 一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSAHelper 只能使用产生出的密钥，且加密更加复杂所以只能加密短文本（测试加密长度上限为58字节）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/// &lt;summary&gt;/// RSA产生秘钥/// &lt;/summary&gt;/// &lt;param name="xmlPublicKey"&gt;公钥&lt;/param&gt;/// &lt;param name="xmlPrivateKey"&gt;私钥&lt;/param&gt;public static void RSAKey(out string xmlPublicKey, out string xmlPrivateKey)&#123; try &#123; RSACryptoServiceProvider rsaCrypto = new RSACryptoServiceProvider(); xmlPublicKey = rsaCrypto.ToXmlString(false); xmlPrivateKey = rsaCrypto.ToXmlString(true); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); xmlPublicKey = string.Empty; xmlPrivateKey = string.Empty; &#125;&#125;/// &lt;summary&gt;/// RSA加密/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;param name="xmlPublicKey"&gt;公钥&lt;/param&gt;/// &lt;returns&gt;RSA密文&lt;/returns&gt;public static string RSAEncrypt(string strPlaintext, string xmlPublicKey)&#123; try &#123; RSACryptoServiceProvider rsaCrypto = new RSACryptoServiceProvider(); rsaCrypto.FromXmlString(xmlPublicKey); UnicodeEncoding unicodeEncoding = new UnicodeEncoding(); byte[] byteBaseUnicode = unicodeEncoding.GetBytes(strPlaintext); byte[] byteBaseEncrypt = rsaCrypto.Encrypt(byteBaseUnicode, false); string strRSAEncrypt = Convert.ToBase64String(byteBaseEncrypt); return strRSAEncrypt; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// RSA解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;RSA密文&lt;/param&gt;/// &lt;param name="xmlPrivateKey"&gt;私钥&lt;/param&gt;/// &lt;returns&gt;明文&lt;/returns&gt;public static string RSADecrypt(string strCiphertext, string xmlPrivateKey)&#123; try &#123; RSACryptoServiceProvider rsaCrypto = new RSACryptoServiceProvider(); rsaCrypto.FromXmlString(xmlPrivateKey); byte[] byteBase64 = Convert.FromBase64String(strCiphertext); byte[] byteBaseDecrypt = rsaCrypto.Decrypt(byteBase64, false); string strRSADecrypt = (new UnicodeEncoding()).GetString(byteBaseDecrypt); return strRSADecrypt; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125; 单项加密密码散列函数 一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的数据是什么。多用于文件效验完整性。 MD5MD5 一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5Helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/// &lt;summary&gt;/// MD5加密(16位小写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;MD5密文(16位小写)&lt;/returns&gt;public static string MD5Encrypt_16Lower(string strPlaintext)&#123; try &#123; MD5CryptoServiceProvider md5Crypto = new MD5CryptoServiceProvider(); string strCiphertext = BitConverter.ToString(md5Crypto.ComputeHash(UTF8Encoding.Default.GetBytes(strPlaintext)), 4, 8); strCiphertext = strCiphertext.Replace("-", ""); strCiphertext = strCiphertext.ToLower(); return strCiphertext; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// MD5加密(16位大写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;MD5密文(16位小写)&lt;/returns&gt;public static string MD5Encrypt_16Upper(string strPlaintext)&#123; try &#123; MD5CryptoServiceProvider md5Crypto = new MD5CryptoServiceProvider(); string strCiphertext = BitConverter.ToString(md5Crypto.ComputeHash(UTF8Encoding.Default.GetBytes(strPlaintext)), 4, 8); strCiphertext = strCiphertext.Replace("-", ""); strCiphertext = strCiphertext.ToUpper(); return strCiphertext; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// MD5加密(32位小写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;MD5密文(32位小写)&lt;/returns&gt;public static string MD5Encrypt_32Lower(string strPlaintext)&#123; try &#123; MD5CryptoServiceProvider md5Crypto = new MD5CryptoServiceProvider(); string strCiphertext = BitConverter.ToString(md5Crypto.ComputeHash(UTF8Encoding.Default.GetBytes(strPlaintext))); strCiphertext = strCiphertext.Replace("-", ""); strCiphertext = strCiphertext.ToLower(); return strCiphertext; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// MD5加密(32位大写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;MD5密文(32位小写)&lt;/returns&gt;public static string MD5Encrypt_32Upper(string strPlaintext)&#123; try &#123; MD5CryptoServiceProvider md5Crypto = new MD5CryptoServiceProvider(); string strCiphertext = BitConverter.ToString(md5Crypto.ComputeHash(UTF8Encoding.Default.GetBytes(strPlaintext))); strCiphertext = strCiphertext.Replace("-", ""); strCiphertext = strCiphertext.ToUpper(); return strCiphertext; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件MD5值(32位小写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件MD5值(32位小写)&lt;/returns&gt;public static string FileMD5Encrypt_32Lower(string strFilePath)&#123; try &#123; FileStream fileStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read); System.Security.Cryptography.MD5 md5 = new System.Security.Cryptography.MD5CryptoServiceProvider(); byte[] byteHash = md5.ComputeHash(fileStream); fileStream.Close(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; byteHash.Length; i++) &#123; stringBuilder.Append(byteHash[i].ToString("x2")); &#125; return stringBuilder.ToString(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件MD5值(32位大写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件MD5值(32位大写)&lt;/returns&gt;public static string FileMD5Encrypt_32Upper(string strFilePath)&#123; try &#123; FileStream fileStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read); System.Security.Cryptography.MD5 md5 = new System.Security.Cryptography.MD5CryptoServiceProvider(); byte[] byteHash = md5.ComputeHash(fileStream); fileStream.Close(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; byteHash.Length; i++) &#123; stringBuilder.Append(byteHash[i].ToString("X2")); &#125; return stringBuilder.ToString(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125; SHA1SHA1 安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准 （Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。SHA1Helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/// &lt;summary&gt;/// SHA1加密(40位小写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;SHA1密文(40位小写)&lt;/returns&gt;public static string SHA1Encrypt_40Lower(string strPlaintext)&#123; try &#123; System.Security.Cryptography.SHA1 sha1Crypto = new SHA1CryptoServiceProvider(); byte[] bytes_sha1_in = UTF8Encoding.Default.GetBytes(strPlaintext); byte[] bytes_sha1_out = sha1Crypto.ComputeHash(bytes_sha1_in); string str_sha1_out = BitConverter.ToString(bytes_sha1_out); str_sha1_out = str_sha1_out.Replace("-", ""); str_sha1_out = str_sha1_out.ToLower(); return str_sha1_out; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// SHA1加密(40位大写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;SHA1密文(40位大写)&lt;/returns&gt;public static string SHA1Encrypt_40Upper(string strPlaintext)&#123; try &#123; System.Security.Cryptography.SHA1 sha1Crypto = new SHA1CryptoServiceProvider(); byte[] bytes_sha1_in = UTF8Encoding.Default.GetBytes(strPlaintext); byte[] bytes_sha1_out = sha1Crypto.ComputeHash(bytes_sha1_in); string str_sha1_out = BitConverter.ToString(bytes_sha1_out); str_sha1_out = str_sha1_out.Replace("-", ""); str_sha1_out = str_sha1_out.ToUpper(); return str_sha1_out; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件SHA1值(40位小写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件SHA1值(40位小写)&lt;/returns&gt;public static string FileSHA1Encrypt_40Lower(string strFilePath)&#123; try &#123; FileStream fileStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read); System.Security.Cryptography.SHA1 sha1 = new SHA1CryptoServiceProvider(); byte[] byteHash = sha1.ComputeHash(fileStream); fileStream.Close(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; byteHash.Length; i++) &#123; stringBuilder.Append(byteHash[i].ToString("x2")); &#125; return stringBuilder.ToString(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件SHA1值(40位大写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件SHA1值(40位大写)&lt;/returns&gt;public static string FileSHA1Encrypt_40Upper(string strFilePath)&#123; try &#123; FileStream fileStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read); System.Security.Cryptography.SHA1 sha1 = new SHA1CryptoServiceProvider(); byte[] byteHash = sha1.ComputeHash(fileStream); fileStream.Close(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; byteHash.Length; i++) &#123; stringBuilder.Append(byteHash[i].ToString("X2")); &#125; return stringBuilder.ToString(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125; CRC32CRC32 循环冗余校验。在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC32Helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267/// &lt;summary&gt;/// CRC32加密(8位小写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;CRC32密文(8位小写)&lt;/returns&gt;public static string CRC32Encrypt_8Lower(string strPlaintext)&#123; try &#123; Crc32 crc32Crypto = new Crc32(); byte[] bytes_crc32_in = UTF8Encoding.Default.GetBytes(strPlaintext); byte[] bytes_crc32_out = crc32Crypto.ComputeHash(bytes_crc32_in); string str_crc32_out = BitConverter.ToString(bytes_crc32_out); str_crc32_out = str_crc32_out.Replace("-", ""); str_crc32_out = str_crc32_out.ToLower(); return str_crc32_out; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// CRC32加密(8位大写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;CRC32密文(8位大写)&lt;/returns&gt;public static string CRC32Encrypt_8Upper(string strPlaintext)&#123; try &#123; Crc32 crc32Crypto = new Crc32(); byte[] bytes_crc32_in = UTF8Encoding.Default.GetBytes(strPlaintext); byte[] bytes_crc32_out = crc32Crypto.ComputeHash(bytes_crc32_in); string str_crc32_out = BitConverter.ToString(bytes_crc32_out); str_crc32_out = str_crc32_out.Replace("-", ""); str_crc32_out = str_crc32_out.ToUpper(); return str_crc32_out; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件CRC32值(8位小写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件CRC32值(8位小写)&lt;/returns&gt;public static string FileCRC32Encrypt_8Lower(string strFilePath)&#123; try &#123; String hashCRC32 = String.Empty; //检查文件是否存在,如果文件存在则进行计算,否则返回空值 if (System.IO.File.Exists(strFilePath)) &#123; using (System.IO.FileStream fileStream = new System.IO.FileStream(strFilePath, System.IO.FileMode.Open, System.IO.FileAccess.Read)) &#123; //计算文件的CSC32值 Crc32 calculator = new Crc32(); Byte[] buffer = calculator.ComputeHash(fileStream); calculator.Clear(); //将字节数组转换成十六进制的字符串形式 StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; buffer.Length; i++) &#123; stringBuilder.Append(buffer[i].ToString("x2")); &#125; hashCRC32 = stringBuilder.ToString(); &#125; &#125; return hashCRC32; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件CRC32值(8位大写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件CRC32值(8位大写)&lt;/returns&gt;public static string FileCRC32Encrypt_8Upper(string strFilePath)&#123; try &#123; String hashCRC32 = String.Empty; //检查文件是否存在,如果文件存在则进行计算,否则返回空值 if (System.IO.File.Exists(strFilePath)) &#123; using (System.IO.FileStream fileStream = new System.IO.FileStream(strFilePath, System.IO.FileMode.Open, System.IO.FileAccess.Read)) &#123; //计算文件的CSC32值 Crc32 calculator = new Crc32(); Byte[] buffer = calculator.ComputeHash(fileStream); calculator.Clear(); //将字节数组转换成十六进制的字符串形式 StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; buffer.Length; i++) &#123; stringBuilder.Append(buffer[i].ToString("X2")); &#125; hashCRC32 = stringBuilder.ToString(); &#125; &#125; return hashCRC32; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 提供 CRC32 算法的实现/// &lt;/summary&gt;public class Crc32 : System.Security.Cryptography.HashAlgorithm&#123; /// &lt;summary&gt; /// Default Polynomial /// &lt;/summary&gt; public const UInt32 DefaultPolynomial = 0xedb88320; /// &lt;summary&gt; /// Default Seed /// &lt;/summary&gt; public const UInt32 DefaultSeed = 0xffffffff; private UInt32 hash; private UInt32 seed; private UInt32[] table; private static UInt32[] defaultTable; /// &lt;summary&gt; /// Crc32 /// &lt;/summary&gt; public Crc32() &#123; table = InitializeTable(DefaultPolynomial); seed = DefaultSeed; Initialize(); &#125; /// &lt;summary&gt; /// Crc32 /// &lt;/summary&gt; /// &lt;param name="polynomial"&gt;&lt;/param&gt; /// &lt;param name="seed"&gt;&lt;/param&gt; public Crc32(UInt32 polynomial, UInt32 seed) &#123; table = InitializeTable(polynomial); this.seed = seed; Initialize(); &#125; /// &lt;summary&gt; /// 初始化 /// &lt;/summary&gt; public override void Initialize() &#123; hash = seed; &#125; /// &lt;summary&gt; /// Hash Core /// &lt;/summary&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;param name="start"&gt;&lt;/param&gt; /// &lt;param name="length"&gt;&lt;/param&gt; protected override void HashCore(byte[] buffer, int start, int length) &#123; hash = CalculateHash(table, hash, buffer, start, length); &#125; /// &lt;summary&gt; /// Hash Final /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; protected override byte[] HashFinal() &#123; byte[] hashBuffer = UInt32ToBigEndianBytes(~hash); this.HashValue = hashBuffer; return hashBuffer; &#125; /// &lt;summary&gt; /// Compute /// &lt;/summary&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static UInt32 Compute(byte[] buffer) &#123; return ~CalculateHash(InitializeTable(DefaultPolynomial), DefaultSeed, buffer, 0, buffer.Length); &#125; /// &lt;summary&gt; /// Compute /// &lt;/summary&gt; /// &lt;param name="seed"&gt;&lt;/param&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static UInt32 Compute(UInt32 seed, byte[] buffer) &#123; return ~CalculateHash(InitializeTable(DefaultPolynomial), seed, buffer, 0, buffer.Length); &#125; /// &lt;summary&gt; /// Compute /// &lt;/summary&gt; /// &lt;param name="polynomial"&gt;&lt;/param&gt; /// &lt;param name="seed"&gt;&lt;/param&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static UInt32 Compute(UInt32 polynomial, UInt32 seed, byte[] buffer) &#123; return ~CalculateHash(InitializeTable(polynomial), seed, buffer, 0, buffer.Length); &#125; private static UInt32[] InitializeTable(UInt32 polynomial) &#123; if (polynomial == DefaultPolynomial &amp;&amp; defaultTable != null) &#123; return defaultTable; &#125; UInt32[] createTable = new UInt32[256]; for (int i = 0; i &lt; 256; i++) &#123; UInt32 entry = (UInt32)i; for (int j = 0; j &lt; 8; j++) &#123; if ((entry &amp; 1) == 1) entry = (entry &gt;&gt; 1) ^ polynomial; else entry = entry &gt;&gt; 1; &#125; createTable[i] = entry; &#125; if (polynomial == DefaultPolynomial) &#123; defaultTable = createTable; &#125; return createTable; &#125; private static UInt32 CalculateHash(UInt32[] table, UInt32 seed, byte[] buffer, int start, int size) &#123; UInt32 crc = seed; for (int i = start; i &lt; size; i++) &#123; unchecked &#123; crc = (crc &gt;&gt; 8) ^ table[buffer[i] ^ crc &amp; 0xff]; &#125; &#125; return crc; &#125; private byte[] UInt32ToBigEndianBytes(UInt32 x) &#123; return new byte[] &#123; (byte)((x &gt;&gt; 24) &amp; 0xff), (byte)((x &gt;&gt; 16) &amp; 0xff), (byte)((x &gt;&gt; 8) &amp; 0xff), (byte)(x &amp; 0xff) &#125;; &#125;&#125; 其它方式（Base64）Base64Base64 网络上最常见的用于传输8Bit字节码的编码方式之一，准确的来说Base64不属于加密范围，仅是一种基于64个可打印字符来表示二进制数据的方法。多用于图片传输使用。Base64Helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/// &lt;summary&gt;/// Base64加密/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;Base64密文&lt;/returns&gt;public static string Base64Encrypt(string strPlaintext)&#123; try &#123; byte[] bytes = Encoding.UTF8.GetBytes(strPlaintext); return Convert.ToBase64String(bytes); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// Base64解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;Base64密文&lt;/param&gt;/// &lt;returns&gt;明文&lt;/returns&gt;public static string Base64Decrypt(string strCiphertext)&#123; try &#123; byte[] bytes = Convert.FromBase64String(strCiphertext); return Encoding.UTF8.GetString(bytes); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 图片Base64加密/// &lt;/summary&gt;/// &lt;param name="strImagePath"&gt;图片路径&lt;/param&gt;/// &lt;param name="imageFormat"&gt;指定图像格式&lt;/param&gt;/// &lt;returns&gt;Base64密文&lt;/returns&gt;public static string ImageBase64Encrypt(string strImagePath, ImageFormat imageFormat)&#123; try &#123; MemoryStream memoryStream = new MemoryStream(); Bitmap bitmap = new Bitmap(strImagePath); if (imageFormat == null) &#123; imageFormat = GetImageFormatFromPath(strImagePath); &#125; bitmap.Save(memoryStream, imageFormat); byte[] bytes = memoryStream.GetBuffer(); return Convert.ToBase64String(bytes); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 图片Base64解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;Base64密文&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;解密图片目录&lt;/param&gt;/// &lt;param name="imageFormat"&gt;指定图像格式&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool ImageBase64Decrypt(string strCiphertext, string strSaveFilePath, ImageFormat imageFormat)&#123; try &#123; byte[] bytes = Convert.FromBase64String(strCiphertext); MemoryStream memoryStream = new MemoryStream(bytes); Bitmap bitmap = new Bitmap(memoryStream); if (imageFormat == null) &#123; imageFormat = GetImageFormatFromPath(strSaveFilePath); &#125; bitmap.Save(strSaveFilePath, imageFormat); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 根据图片路径获得图片格式(缺少MemoryBmp)/// &lt;/summary&gt;/// &lt;param name="strImagePath"&gt;图片路径&lt;/param&gt;/// &lt;returns&gt;图片格式&lt;/returns&gt;public static ImageFormat GetImageFormatFromPath(string strImagePath)&#123; try &#123; string strImageExtension = Path.GetExtension(strImagePath).ToLower(); if (string.IsNullOrEmpty(strImageExtension)) &#123; return null; &#125; else &#123; if (strImageExtension.Equals(".bmp") || strImageExtension.Equals(".rle") || strImageExtension.Equals(".dlb")) &#123; return ImageFormat.Bmp; &#125; else if (strImageExtension.Equals(".emf")) &#123; return ImageFormat.Emf; &#125; else if (strImageExtension.Equals(".exif")) &#123; return ImageFormat.Exif; &#125; else if (strImageExtension.Equals(".gif")) &#123; return ImageFormat.Gif; &#125; else if (strImageExtension.Equals(".ico")) &#123; return ImageFormat.Icon; &#125; else if (strImageExtension.Equals(".jpg") || strImageExtension.Equals(".jpeg") || strImageExtension.Equals(".jpe")) &#123; return ImageFormat.Jpeg; &#125; else if (strImageExtension.Equals(".png") || strImageExtension.Equals(".pns")) &#123; return ImageFormat.Png; &#125; else if (strImageExtension.Equals(".tif") || strImageExtension.Equals(".tiff")) &#123; return ImageFormat.Tiff; &#125; else if (strImageExtension.Equals(".wmf")) &#123; return ImageFormat.Wmf; &#125; else &#123; return null; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125; 文件夹加密起因是一个女性朋友提出的需求，大概是说不想自己电脑的文件夹被其他人打开，但是又不想加密文件，因为耗时会很久，只想加密文件夹。查过各种资料后没有找到更好的方法，暂且使用一种修改文件夹后缀名达到让电脑识别为控制面板或回收站等图标的方式，然后修改恢复文件夹的时候预设匹对一个设定好的密码文件，就可以达到加密解密文件夹的效果，但是理解原理的人是可以直接破解的，但是我相信理解这项技术的不多，并且不会对每一个系统图标虎视眈眈的。FolderHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/// &lt;summary&gt;/// 加密文件/// &lt;/summary&gt;public static string Lock = ".&#123;2559a1f2-21d7-11d4-bdaf-00c04f60b9f0&#125;";/// &lt;summary&gt;/// 控制面板/// &lt;/summary&gt;public static string Control = ".&#123;21EC2020-3AEA-1069-A2DD-08002B30309D&#125;";/// &lt;summary&gt;/// RunIE/// &lt;/summary&gt;public static string RunIE = ".&#123;2559a1f4-21d7-11d4-bdaf-00c04f60b9f0&#125;";/// &lt;summary&gt;/// 回收站/// &lt;/summary&gt;public static string Recycle = ".&#123;645FF040-5081-101B-9F08-00AA002F954E&#125;";/// &lt;summary&gt;/// Help/// &lt;/summary&gt;public static string Help = ".&#123;2559a1f1-21d7-11d4-bdaf-00c04f60b9f0&#125;";/// &lt;summary&gt;/// NetWork/// &lt;/summary&gt;public static string NetWork = ".&#123;7007ACC7-3202-11D1-AAD2-00805FC1270E&#125;";/// &lt;summary&gt;/// 文件夹加密(可破解)/// &lt;/summary&gt;/// &lt;param name="strFolderPath"&gt;文件夹路径&lt;/param&gt;/// &lt;param name="strClsid"&gt;Clsid类型&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FolderEncrypt(string strFolderPath, string strClsid)&#123; try &#123; DirectoryInfo directoryInfo = new DirectoryInfo(strFolderPath); directoryInfo.MoveTo(directoryInfo.Parent.FullName + "\\" + directoryInfo.Name + strClsid); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件夹解密/// 理论上可以解密所有该方法加密的文件夹/// &lt;/summary&gt;/// &lt;param name="strFolderPath"&gt;文件夹路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FolderDecrypt(string strFolderPath)&#123; try &#123; DirectoryInfo directoryInfo = new DirectoryInfo(strFolderPath); directoryInfo.MoveTo(strFolderPath.Substring(0, strFolderPath.LastIndexOf("."))); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件夹加密(带密码)(可破解)/// &lt;/summary&gt;/// &lt;param name="strFolderPath"&gt;文件夹路径&lt;/param&gt;/// &lt;param name="strClsid"&gt;Clsid类型&lt;/param&gt;/// &lt;param name="strPassword"&gt;加密密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FolderEncrypt(string strFolderPath, string strClsid, string strPassword)&#123; try &#123; DirectoryInfo directoryInfo = new DirectoryInfo(strFolderPath); XmlDocument xmlDocument = new XmlDocument(); XmlNode xmlNode = xmlDocument.CreateNode(XmlNodeType.XmlDeclaration, "", ""); xmlDocument.AppendChild(xmlNode); XmlElement xmlElement = xmlDocument.CreateElement("", "ROOT", ""); XmlText xmlText = xmlDocument.CreateTextNode(strPassword); xmlElement.AppendChild(xmlText); xmlDocument.AppendChild(xmlElement); xmlDocument.Save(strFolderPath + "\\Lock.xml"); directoryInfo.MoveTo(directoryInfo.Parent.FullName + "\\" + directoryInfo.Name + strClsid); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件夹解密(带密码)/// &lt;/summary&gt;/// &lt;param name="strFolderPath"&gt;文件夹路径&lt;/param&gt;/// &lt;param name="strPassword"&gt;加密密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FolderDecrypt(string strFolderPath, string strPassword)&#123; try &#123; DirectoryInfo directoryInfo = new DirectoryInfo(strFolderPath); bool bIsPassword = false; XmlTextReader xmlTextReader = new XmlTextReader(strFolderPath + "\\Lock.xml"); while (xmlTextReader.Read()) &#123; if (xmlTextReader.NodeType == XmlNodeType.Text) &#123; if (xmlTextReader.Value == strPassword) &#123; bIsPassword = true; break; &#125; &#125; &#125; xmlTextReader.Close(); if (bIsPassword) &#123; File.Delete(strFolderPath + "\\Lock.xml"); directoryInfo.MoveTo(strFolderPath.Substring(0, strFolderPath.LastIndexOf("."))); return true; &#125; else &#123; return false; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>aes</tag>
        <tag>base64</tag>
        <tag>crc32</tag>
        <tag>des</tag>
        <tag>folder</tag>
        <tag>md5</tag>
        <tag>rsa</tag>
        <tag>sha1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows任务计划帮助类]]></title>
    <url>%2Fblog%2F2017%2F09%2F18%2Fcsharp-TaskschdHelper%2F</url>
    <content type="text"><![CDATA[基于 TaskScheduler 库操作Windows任务计划帮助类 简介任务计划 可以将任何脚本、程序或文档安排在某个最方便的时间运行。常见于系统开机自启动程序，或定期运行自动更新程序或守护程序。 帮助类TaskschdHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/// &lt;summary&gt;/// 创建任务计划/// &lt;/summary&gt;/// &lt;param name="strCreator"&gt;作者&lt;/param&gt;/// &lt;param name="strTaskName"&gt;任务名称&lt;/param&gt;/// &lt;param name="strPath"&gt;任务计划路径&lt;/param&gt;/// &lt;param name="strInterval"&gt;任务触发时间(PT1M:1分钟,PT1H30M:90分钟)&lt;/param&gt;/// &lt;param name="strStartBoundary"&gt;任务开始时间(yyyy-MM-ddTHH:mm:ss)&lt;/param&gt;/// &lt;param name="strDescription"&gt;任务描述&lt;/param&gt;/// &lt;returns&gt;任务状态&lt;/returns&gt;public static bool CreateTaskschd(string strCreator, string strTaskName, string strPath, string strInterval, string strStartBoundary, string strDescription)&#123; try &#123; if (IsExists(strTaskName)) &#123; DeleteTaskschd(strTaskName); &#125; //new scheduler TaskSchedulerClass scheduler = new TaskSchedulerClass(); //pc-name/ip,username,domain,password scheduler.Connect(null, null, null, null); //get scheduler folder ITaskFolder folder = scheduler.GetFolder("\\"); //set base attr ITaskDefinition task = scheduler.NewTask(0); task.RegistrationInfo.Author = strCreator;//creator task.RegistrationInfo.Description = strDescription;//description //set trigger (IDailyTrigger ITimeTrigger) ITimeTrigger tt = (ITimeTrigger)task.Triggers.Create(_TASK_TRIGGER_TYPE2.TASK_TRIGGER_TIME); tt.Repetition.Interval = strInterval;// format PT1H1M==1小时1分钟 设置的值最终都会转成分钟加入到触发器 tt.StartBoundary = strStartBoundary;//start time //set action IExecAction action = (IExecAction)task.Actions.Create(_TASK_ACTION_TYPE.TASK_ACTION_EXEC); action.Path = strPath;//计划任务调用的程序路径 task.Settings.ExecutionTimeLimit = "PT0S"; //运行任务时间超时停止任务吗? PTOS 不开启超时 task.Settings.DisallowStartIfOnBatteries = false;//只有在交流电源下才执行 task.Settings.RunOnlyIfIdle = false;//仅当计算机空闲下才执行 IRegisteredTask regTask = folder.RegisterTaskDefinition(strTaskName, task, (int)_TASK_CREATION.TASK_CREATE, null, //user null, //password _TASK_LOGON_TYPE.TASK_LOGON_INTERACTIVE_TOKEN, ""); IRunningTask runTask = regTask.Run(null); //return runTask.State; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); //return _TASK_STATE.TASK_STATE_UNKNOWN; return false; &#125;&#125;/// &lt;summary&gt;/// 删除任务计划/// &lt;/summary&gt;/// &lt;param name="strTaskName"&gt;任务计划名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteTaskschd(string strTaskName)&#123; try &#123; TaskSchedulerClass taskScheduler = new TaskSchedulerClass(); taskScheduler.Connect(null, null, null, null); ITaskFolder taskFolder = taskScheduler.GetFolder("\\"); taskFolder.DeleteTask(strTaskName, 0); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 获得所有任务计划/// &lt;/summary&gt;/// &lt;returns&gt;所有任务计划&lt;/returns&gt;public static IRegisteredTaskCollection GetAllTaskschd()&#123; try &#123; TaskSchedulerClass taskScheduler = new TaskSchedulerClass(); taskScheduler.Connect(null, null, null, null); ITaskFolder taskFolder = taskScheduler.GetFolder("\\"); IRegisteredTaskCollection tasks_exists = taskFolder.GetTasks(1); return tasks_exists; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 任务计划是否存在/// &lt;/summary&gt;/// &lt;param name="strTaskName"&gt;任务计划名称&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static bool IsExists(string strTaskName)&#123; try &#123; bool isExists = false; IRegisteredTaskCollection tasks_exists = GetAllTaskschd(); for (int i = 1; i &lt;= tasks_exists.Count; i++) &#123; IRegisteredTask registeredTask = tasks_exists[i]; if (registeredTask.Name.Equals(strTaskName)) &#123; isExists = true; break; &#125; &#125; return isExists; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
        <tag>taskschd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VisualSVN 使用介绍]]></title>
    <url>%2Fblog%2F2017%2F08%2F20%2Fsoftware-VisualSVN%2F</url>
    <content type="text"><![CDATA[使用 SVN 作为版本管理工具简介SVN 是一个开放源代码的版本控制系统，现大部分公司还是使用SVN作为代码托管服务，我曾经提议公司将版本控制替换为 GIT，但是项目经理有考虑员工学习成本，最后没有使用。 部署服务端（VisualSVN Server）VisualSVN Server 使Subversion服务器在Windows上安装和管理变得简单方便。下载地址 安装即可。 设置创建成员 创建项目库 设置项目名 设置项目结构 设置项目访问权限 设置项目成员 客户端连接TortoiseSVN 是一个Apache ™ Subversion（SVN）&reg;客户端，实现为Windows外壳扩展。它直观且易于使用，因为它不需要Subversion命令行客户端运行。下载地址 安装即可。右键 SVN Checkout… 连接项目库]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html 中嵌入 Office 文件]]></title>
    <url>%2Fblog%2F2017%2F08%2F05%2Fhtml-HtmlEmbed%2F</url>
    <content type="text"><![CDATA[Html 静态网页中嵌入 Word、Excel、PPT、PDF 文件 简介整理了两篇博客文章，想要把两个 Excel 文件嵌入到网页中显示，遇到了一点小麻烦。由于博客文件比较精简，尽量避开项目中调用大量脚本。数据分析-手机号数据分析-身份证号码 Office Web Apps Viewer使用微软提供的 Office Online 实现 Office 文档的在线查看 使用方法1http://view.officeapps.live.com/op/view.aspx?src=[OFFICE_FILE_URL] 嵌入方法1&lt;iframe src="http://view.officeapps.live.com/op/view.aspx?src=[OFFICE_FILE_URL]" style="width:100%; height:1500px;" frameborder="0"&gt;&lt;/iframe&gt; 存在问题Microsoft 限制文件大小 Worder、PPT 文件上限为 10MB，Excel 文件上限为 5MB。由于我保存的 Excel 文件由 MySQL 数据库导出纯文本，没有压缩的空间。解决：Excel 文件另存为 .xlsb 后缀(二进制工作簿要比正常格式大小小得多) Google Docs Viewer使用方法1https://docs.google.com/viewer?url=[OFFICE_FILE_URL] 嵌入方法1&lt;iframe src="https://docs.google.com/viewer?url=[OFFICE_FILE_URL]" style="width:100%; height:1500px;" frameborder="0"&gt;&lt;/iframe&gt; 存在问题国内对于 Google 并不太友好，有时访问可能需要个梯子]]></content>
      <categories>
        <category>Html</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>office</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析-身份证号码]]></title>
    <url>%2Fblog%2F2017%2F08%2F01%2Fdata-IdNumber%2F</url>
    <content type="text"><![CDATA[简介 table { width: 490px; } XX XX XX XXXX XX XX XXX X 省 市 区(县) 出生年 月 日 顺序码 校验码 *现身份证由 GB 11643-1999 标准规定的 18 位数字或字母(仅结尾X)组成。1.前六位表示为常驻户口所在地的行政区划代码，由 GB/T 2260-2007 标准执行。2.第七位至第十四位为出生年、月、日。3.第十五位至第十七位为顺序码(其中包含派出所代码，第十七位也用来表示性别:奇数表示男性，偶数表示女性)4.第18位数字是校检码：用来检验身份证的正确性。校检码可以是0~10的数字，10用X表示。 空白正反面 正则表达式校验12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394/// &lt;summary&gt;/// 效验身份证号码/// &lt;/summary&gt;/// &lt;param name="strIDNumber"&gt;身份证号码&lt;/param&gt;/// &lt;returns&gt;效验通过返回true,失败返回false&lt;/returns&gt;public static bool CheckIDNumber(string strIDNumber)&#123; try &#123; if (strIDNumber.Length == 15 &amp;&amp; CheckIDCard15(strIDNumber)) &#123; return true; &#125; else if (strIDNumber.Length == 18 &amp;&amp; CheckIDCard18(strIDNumber)) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (Exception ex) &#123; return false; &#125;&#125;/// &lt;summary&gt;/// 15位身份证号验证/// &lt;/summary&gt;/// &lt;param name="idNumber"&gt;身份证号&lt;/param&gt;/// &lt;returns&gt;效验通过返回true,失败返回false&lt;/returns&gt;private static bool CheckIDCard15(string idNumber)&#123; long n = 0; if (long.TryParse(idNumber, out n) == false || n &lt; Math.Pow(10, 14)) &#123; return false;//数字验证 &#125; string address = "11x22x35x44x53x12x23x36x45x54x13x31x37x46x61x14x32x41x50x62x15x33x42x51x63x21x34x43x52x64x65x71x81x82x91"; if (address.IndexOf(idNumber.Remove(2)) == -1) &#123; return false;//省份验证 &#125; string birth = idNumber.Substring(6, 6).Insert(4, "-").Insert(2, "-"); DateTime time = new DateTime(); if (DateTime.TryParse(birth, out time) == false) &#123; return false;//生日验证 &#125; return true;//符合15位身份证标准 &#125;/// &lt;summary&gt; /// 18位身份证号码验证 /// &lt;/summary&gt; /// &lt;param name="idNumber"&gt;身份证号&lt;/param&gt; /// &lt;returns&gt;效验通过返回true,失败返回false&lt;/returns&gt; private static bool CheckIDCard18(string idNumber)&#123; long n = 0; if (long.TryParse(idNumber.Remove(17), out n) == false || n &lt; Math.Pow(10, 16) || long.TryParse(idNumber.Replace('x', '0').Replace('X', '0'), out n) == false) &#123; return false;//数字验证 &#125; string address = "11x22x35x44x53x12x23x36x45x54x13x31x37x46x61x14x32x41x50x62x15x33x42x51x63x21x34x43x52x64x65x71x81x82x91"; if (address.IndexOf(idNumber.Remove(2)) == -1) &#123; return false;//省份验证 &#125; string birth = idNumber.Substring(6, 8).Insert(6, "-").Insert(4, "-"); DateTime time = new DateTime(); if (DateTime.TryParse(birth, out time) == false) &#123; return false;//生日验证 &#125; string[] arrVarifyCode = ("1,0,x,9,8,7,6,5,4,3,2").Split(','); string[] Wi = ("7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2").Split(','); char[] Ai = idNumber.Remove(17).ToCharArray(); int sum = 0; for (int i = 0; i &lt; 17; i++) &#123; sum += int.Parse(Wi[i]) * int.Parse(Ai[i].ToString()); &#125; int y = -1; Math.DivRem(sum, 11, out y); Console.WriteLine("Y的理论值: " + y); if (arrVarifyCode[y] != idNumber.Substring(17, 1).ToLower()) &#123; return false;//校验码验证 &#125; return true;//符合GB11643-1999标准 &#125; 行政区划查询下载：areacodebase.xlsb]]></content>
      <categories>
        <category>Data</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>idnumber</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析-手机号]]></title>
    <url>%2Fblog%2F2017%2F08%2F01%2Fdata-PhoneNumber%2F</url>
    <content type="text"><![CDATA[简介 table { width: 300px; } +86 XXX - XXXX XXXX 中国 运营商及归属地 随机号码 正则表达式校验1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt;/// 效验中国大陆手机号码/// &lt;/summary&gt;/// &lt;param name="strPhoneNumber"&gt;中国大陆手机号码&lt;/param&gt;/// &lt;returns&gt;效验通过返回true,失败返回false&lt;/returns&gt;public static bool CheckPhoneNumber(string strPhoneNumber)&#123; try &#123; //+86替换成空(只考虑中国大陆手机号) if (strPhoneNumber.Length == 14) &#123; strPhoneNumber.Replace("+86", string.Empty); &#125; //中国电信正则表达式匹配 string strRegexChinaTelecom = @"^1[3578][01379]\d&#123;8&#125;$"; Regex regexChinaTelecom = new Regex(strRegexChinaTelecom); //中国移动正则表达式匹配 string strRegexChinaMobile = @"^(134[012345678]\d&#123;7&#125;|1[34578][012356789]\d&#123;8&#125;)$"; Regex regexChinaMobile = new Regex(strRegexChinaMobile); //中国联通正则表达式匹配 string strRegexChinaUnicom = @"^1[34578][01256]\d&#123;8&#125;$"; Regex regexChinaUnicom = new Regex(strRegexChinaUnicom); //验证手机号 if (regexChinaTelecom.IsMatch(strPhoneNumber) || regexChinaMobile.IsMatch(strPhoneNumber) || regexChinaUnicom.IsMatch(strPhoneNumber)) &#123; return true; &#125; else &#123; return false; &#125; &#125; catch (Exception ex) &#123; return false; &#125;&#125; 归属地查询下载：mobile.xlsb]]></content>
      <categories>
        <category>Data</category>
      </categories>
      <tags>
        <tag>data</tag>
        <tag>phonenumber</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 无法删除 IE 桌面图标]]></title>
    <url>%2Fblog%2F2017%2F07%2F22%2Fsystem-IECannotDelete%2F</url>
    <content type="text"><![CDATA[通过编辑注册表以删除默认的顽固图标 简介有一些旧版本 Win10 安装后 IE 图标顽固无法删除，现微软应该已经修复。 解决方法编辑以下文本保存为 .reg 后缀双击运行即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace]&quot;MonitorRegistry&quot;=dword:00000001[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\DelegateFolders][HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\DelegateFolders\&#123;F5FB2C77-0E2F-4A16-A381-3E560C68BC83&#125;]@=&quot;Removable Drives&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;031E4825-7B94-4dc3-B131-E946B44C8DD5&#125;]@=&quot;UsersLibraries&quot;&quot;Removal Message&quot;=&quot;@shell32.dll,-9047&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;04731B67-D933-450a-90E6-4ACD2E9408FE&#125;]@=&quot;CLSID_SearchFolder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;11016101-E366-4D22-BC06-4ADA335C892B&#125;]@=&quot;IE History and Feeds Shell Data Source for Windows Search&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;138508bc-1e03-49ea-9c8f-ea9e1d05d65d&#125;]@=&quot;MAPI Shell Folder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;26EE0668-A00A-44D7-9371-BEB064C98683&#125;]@=&quot;ControlPanelHome&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;2F6CE85C-F9EE-43CA-90C7-8A9BD53A2467&#125;]@=&quot;File History Data Source&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;4336a54d-038b-4685-ab02-99bb52d3fb8b&#125;]@=&quot;Public folder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;450D8FBA-AD25-11D0-98A8-0800361B1103&#125;]@=&quot;Documents&quot;&quot;Removal Message&quot;=&quot;@mydocs.dll,-900&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;5399E694-6CE5-4D6C-8FCE-1D8870FDCBA0&#125;]@=&quot;ControlPanelStartupPage&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;59031a47-3f72-44a7-89c5-5595fe6b30ee&#125;]@=&quot;UsersFiles&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;5b934b42-522b-4c34-bbfe-37a3ef7b9c90&#125;]@=&quot;This Device Folder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;645FF040-5081-101B-9F08-00AA002F954E&#125;]@=&quot;Recycle Bin&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;64693913-1c21-4f30-a98f-4e52906d3b56&#125;]@=&quot;AppInstanceFolder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;89D83576-6BD1-4c86-9454-BEB04E94C819&#125;]@=&quot;MAPI Folder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;8FD8B88D-30E1-4F25-AC2B-553D3D65F0EA&#125;]@=&quot;DXP&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;9343812e-1c37-4a49-a12e-4b2d810d956b&#125;]@=&quot;Search Home&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;98F275B4-4FFF-11E0-89E2-7B86DFD72085&#125;]@=&quot;CLSID_StartMenuLauncherProviderFolder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;a00ee528-ebd9-48b8-944a-8942113d46ac&#125;]@=&quot;CLSID_StartMenuCommandingProviderFolder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;B4FB3F98-C1EA-428d-A78A-D1F5659CBA93&#125;]@=&quot;Other Users&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;B5EAD1DB-7C18-4954-8820-01733BC08C82&#125;]@=&quot;Internet Explorer&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;BD7A2E7B-21CB-41b2-A086-B309680C6B7E&#125;]@=&quot;CSC Folder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;daf95313-e44d-46af-be1b-cbacea2c3065&#125;]@=&quot;CLSID_StartMenuProviderFolder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;DB19096C-5365-4164-A246-59FEFF9D8062&#125;]@=&quot;Nameext&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;e345f35f-9397-435c-8f95-4e922c26259e&#125;]@=&quot;CLSID_StartMenuPathCompleteProviderFolder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;ED228FDF-9EA8-4870-83b1-96b02CFE0D52&#125;]&quot;Removal Message&quot;=&quot;@gameux.dll,-10038&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;EDC978D6-4D53-4b2f-A265-5805674BE568&#125;]@=&quot;StreamBackedFolder&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;F02C1A0D-BE21-4350-88B0-7367FC96EF3C&#125;]@=&quot;Computers and Devices&quot;[HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Desktop\NameSpace\&#123;f8278c54-a712-415b-b593-b77a2be0dda9&#125;]@=&quot;This Device Folder&quot;]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows注册表帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F22%2Fcsharp-RegistryHelper%2F</url>
    <content type="text"><![CDATA[基于 Microsoft.Win32 库操作Windows注册表帮助类 简介注册表（Registry） 作为Windows操作系统中的一个核心数据库，用于存储系统和应用程序的设置信息。修改常见的功能有：软件启动项、系统级菜单、文件默认启动程序及默认图标。常见的修改方式有Windows自带的命令regedit进入图形界面修改，或者熟悉批处理脚本（.bat）的朋友可以更方便的修改。 帮助类RegistryHelper 引用 Microsoft.Win32 库。 设置软件启动项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#region Registry Startup Items/// &lt;summary&gt;/// 创建注册表启动项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动项软件路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateStartupItems(string strName, string strSoftwarePath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.CurrentUser.CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"); &#125; registryKey.SetValue(strName, strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表启动项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteStartupItems(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteValue(strName, false); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 获得注册表中所有启动项/// &lt;/summary&gt;/// &lt;returns&gt;注册表中启动项(键值,启动路径)&lt;/returns&gt;public static Dictionary&lt;string, string&gt; GetAllStartupItems()&#123; try &#123; Dictionary&lt;string, string&gt; dicAllStartupItems = new Dictionary&lt;string, string&gt;(); RegistryKey registryKey = null; //获取HKEY_CURRENT_USER中的启动项 registryKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true); if (registryKey != null) &#123; foreach (string strValeName in registryKey.GetValueNames()) &#123; if (!dicAllStartupItems.ContainsKey(strValeName)) &#123; dicAllStartupItems.Add(strValeName, registryKey.GetValue(strValeName).ToString()); &#125; &#125; &#125; //获取HKEY_LOCAL_MACHINE中的启动项 registryKey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true); if (registryKey != null) &#123; foreach (string strValeName in registryKey.GetValueNames()) &#123; if (!dicAllStartupItems.ContainsKey(strValeName)) &#123; dicAllStartupItems.Add(strValeName, registryKey.GetValue(strValeName).ToString()); &#125; &#125; &#125; return dicAllStartupItems; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;#endregion 设置系统右键菜单桌面右键菜单项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#region 注册表桌面右键菜单项/// &lt;summary&gt;/// 创建注册表桌面右键菜单项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateDesktopRightClickMenu(string strName, string strDisplayName, string strSoftwarePath, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Directory\Background\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Directory\Background\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Directory\Background\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Directory\Background\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 创建注册表桌面右键菜单项(二级菜单)(WIN7-X64下测试通过)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;一级菜单键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;一级菜单右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;一级菜单右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;param name="listSecondaryMenu"&gt;二级菜单配置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateDesktopRightClickMenu2(string strName, string strDisplayName, string strIcoPath, List&lt;SecondaryMenuModel&gt; listSecondaryMenu)&#123; try &#123; if (string.IsNullOrEmpty(strName) || listSecondaryMenu.Count &lt; 1) &#123; return false; &#125; //创建一级菜单 RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Directory\Background\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Directory\Background\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; //创建二级菜单 foreach (SecondaryMenuModel vSecondaryMenu in listSecondaryMenu) &#123; string strName2 = vSecondaryMenu.strSecondaryMenuName; string strDisplayName2 = vSecondaryMenu.strDisplayName; string strSoftwarePath2 = vSecondaryMenu.strSoftwarePath; string strIcoPath2 = vSecondaryMenu.strIcoPath; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2, true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2); &#125; if (!string.IsNullOrEmpty(strDisplayName2)) &#123; registryKey.SetValue("", strDisplayName2); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath2)) &#123; registryKey.SetValue("icon", strIcoPath2); &#125; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command", true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath2); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表桌面右键菜单项(二级菜单只删除一级菜单)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteDesktopRightClickMenu(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Directory\Background\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 文件夹右键菜单项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#region 注册表文件夹右键菜单项/// &lt;summary&gt;/// 创建注册表文件夹右键菜单项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateFolderRightClickMenu(string strName, string strDisplayName, string strSoftwarePath, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Folder\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Folder\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Folder\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Folder\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 创建注册表文件夹右键菜单项(二级菜单)(WIN7-X64下测试通过)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;一级菜单键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;一级菜单右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;一级菜单右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;param name="listSecondaryMenu"&gt;二级菜单配置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateFolderRightClickMenu2(string strName, string strDisplayName, string strIcoPath, List&lt;SecondaryMenuModel&gt; listSecondaryMenu)&#123; try &#123; if (string.IsNullOrEmpty(strName) || listSecondaryMenu.Count &lt; 1) &#123; return false; &#125; //创建一级菜单 RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Folder\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Folder\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; //创建二级菜单 foreach (SecondaryMenuModel vSecondaryMenu in listSecondaryMenu) &#123; string strName2 = vSecondaryMenu.strSecondaryMenuName; string strDisplayName2 = vSecondaryMenu.strDisplayName; string strSoftwarePath2 = vSecondaryMenu.strSoftwarePath; string strIcoPath2 = vSecondaryMenu.strIcoPath; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2, true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2); &#125; if (!string.IsNullOrEmpty(strDisplayName2)) &#123; registryKey.SetValue("", strDisplayName2); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath2)) &#123; registryKey.SetValue("icon", strIcoPath2); &#125; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command", true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath2); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表文件夹右键菜单项(二级菜单只删除一级菜单)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteFolderRightClickMenu(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Folder\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 文件右键菜单项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#region 注册表文件右键菜单项/// &lt;summary&gt;/// 创建注册表文件右键菜单项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateFileRightClickMenu(string strName, string strDisplayName, string strSoftwarePath, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"*\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"*\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"*\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"*\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 创建注册表文件右键菜单项(二级菜单)(WIN7-X64下测试通过)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;一级菜单键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;一级菜单右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;一级菜单右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;param name="listSecondaryMenu"&gt;二级菜单配置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateFileRightClickMenu2(string strName, string strDisplayName, string strIcoPath, List&lt;SecondaryMenuModel&gt; listSecondaryMenu)&#123; try &#123; if (string.IsNullOrEmpty(strName) || listSecondaryMenu.Count &lt; 1) &#123; return false; &#125; //创建一级菜单 RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"*\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"*\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; //创建二级菜单 foreach (SecondaryMenuModel vSecondaryMenu in listSecondaryMenu) &#123; string strName2 = vSecondaryMenu.strSecondaryMenuName; string strDisplayName2 = vSecondaryMenu.strDisplayName; string strSoftwarePath2 = vSecondaryMenu.strSoftwarePath; string strIcoPath2 = vSecondaryMenu.strIcoPath; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2, true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2); &#125; if (!string.IsNullOrEmpty(strDisplayName2)) &#123; registryKey.SetValue("", strDisplayName2); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath2)) &#123; registryKey.SetValue("icon", strIcoPath2); &#125; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command", true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath2); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表文件右键菜单项(二级菜单只删除一级菜单)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteFileRightClickMenu(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"*\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 特定文件右键菜单项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#region 注册表特定文件右键菜单项/// &lt;summary&gt;/// 创建注册表特定文件右键菜单项/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateSpecificFileRightClickMenu(string strFileType, string strName, string strDisplayName, string strSoftwarePath, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType); &#125; //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 创建注册表特定文件右键菜单项(二级菜单)(WIN7-X64下测试通过)/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strName"&gt;一级菜单键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;一级菜单右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;一级菜单右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;param name="listSecondaryMenu"&gt;二级菜单配置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateSpecificFileRightClickMenu2(string strFileType, string strName, string strDisplayName, string strIcoPath, List&lt;SecondaryMenuModel&gt; listSecondaryMenu)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strName) || listSecondaryMenu.Count &lt; 1) &#123; return false; &#125; //创建一级菜单 RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType); &#125; //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\shell\\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\shell\\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; &#125; //创建二级菜单 foreach (SecondaryMenuModel vSecondaryMenu in listSecondaryMenu) &#123; string strName2 = vSecondaryMenu.strSecondaryMenuName; string strDisplayName2 = vSecondaryMenu.strDisplayName; string strSoftwarePath2 = vSecondaryMenu.strSoftwarePath; string strIcoPath2 = vSecondaryMenu.strIcoPath; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2, true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2); &#125; if (!string.IsNullOrEmpty(strDisplayName2)) &#123; registryKey.SetValue("", strDisplayName2); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath2)) &#123; registryKey.SetValue("icon", strIcoPath2); &#125; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command", true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath2); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表特定文件右键菜单项(二级菜单只删除一级菜单)/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteSpecificFileRightClickMenu(string strFileType, string strName)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 设置系统特定文件后缀默认图标12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#region Registry Default Icon/// &lt;summary&gt;/// 修改特定后缀文件默认图标(需重启电脑)/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;替换图片路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool ModifyDefaultIcon(string strFileType, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strIcoPath) || !File.Exists(strIcoPath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType); &#125; //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\DefaultIcon\", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\DefaultIcon\"); &#125; if (!string.IsNullOrEmpty(strIcoPath)) &#123; registryKey.SetValue("", strIcoPath); &#125; &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\DefaultIcon\", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\DefaultIcon\"); &#125; if (!string.IsNullOrEmpty(strIcoPath)) &#123; registryKey.SetValue("", strIcoPath); &#125; &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 设置系统特定后缀文件默认程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#region Registry Default Programs/// &lt;summary&gt;/// 修改特定后缀文件默认程序/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;替换程序路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool ModifyDefaultPrograms(string strFileType, string strSoftwarePath)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType); &#125; //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\open\command\", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\shell\open\command\"); &#125; if (!string.IsNullOrEmpty(strSoftwarePath)) &#123; registryKey.SetValue("", strSoftwarePath); &#125; &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\open\command\", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\shell\open\command\"); &#125; if (!string.IsNullOrEmpty(strSoftwarePath)) &#123; registryKey.SetValue("", strSoftwarePath); &#125; &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 创建 URL Protocol 协议,通过网页打开本地应用由于公司业务需求，制作单点登录功能，该方法作为比较常见的一种，安装C/S端软件时写入注册表，B/S程序通过A标签即可打开C/S端程序并且自动登录B/S的用户名密码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#region Registry URL Protocol/// &lt;summary&gt;/// 创建 URL Protocol 协议,通过网页打开本地应用/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateURLProtocol(string strName, string strSoftwarePath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; //Web端调用方法:&lt;a href="strName://"%1"参数&gt;URL Protocol&lt;/a&gt; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strName + @"\shell\open\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strName + @"\shell\open\command"); &#125; registryKey.SetValue("", strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除 URL Protocol 协议/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteURLProtocol(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strName, true); if (registryKey == null) &#123; return false; &#125; else &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot; registryKey.DeleteSubKeyTree(strName); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSV文件帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F21%2Fcsharp-CSVHelper%2F</url>
    <content type="text"><![CDATA[操作 CSV 文件帮助类 简介工作中用户提供 CSV 文件作为参考数据使用，需要读取到系统中进行相关计算CSV（逗号分隔值文件格式）其文件以纯文本形式存储表格数据，分隔字符也可以不是逗号，可用Excel编辑的表格文件。CSVHelper 帮助类主要提供内存表格DataTable互相转换，以正则表达式与截取拼接。 CSV文件操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/// &lt;summary&gt;/// DataTable转换为CSV/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;CSV文件路径&lt;/param&gt;/// &lt;param name="dtSourceData"&gt;DataTable数据&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DataTableConversionCSV(string strSource, DataTable dtSourceData)&#123; try &#123; if (string.IsNullOrEmpty(strSource) || dtSourceData.Rows.Count &lt; 1) &#123; return false; &#125; FileStream fileStream = new FileStream(Path.ChangeExtension(strSource, "csv"), FileMode.Create); StreamWriter streamWriter = new StreamWriter(fileStream); //记录当前读取到的一行数据 string strRowOfData = string.Empty; //循环保存列名 for (int iColumnsName = 0; iColumnsName &lt; dtSourceData.Columns.Count; iColumnsName++) &#123; strRowOfData += string.Format("&#123;0&#125;&#123;1&#125;&#123;0&#125;", "\"", dtSourceData.Columns[iColumnsName].ColumnName.ToString()); if (iColumnsName &lt; dtSourceData.Columns.Count - 1) &#123; strRowOfData += ","; &#125; &#125; streamWriter.WriteLine(strRowOfData); //循环保存数据 for (int iRow = 0; iRow &lt; dtSourceData.Rows.Count; iRow++) &#123; strRowOfData = string.Empty; for (int iColumns = 0; iColumns &lt; dtSourceData.Columns.Count; iColumns++) &#123; strRowOfData += string.Format("&#123;0&#125;&#123;1&#125;&#123;0&#125;", "\"", dtSourceData.Rows[iRow][iColumns].ToString()); if (iColumns &lt; dtSourceData.Columns.Count - 1) &#123; strRowOfData += ","; &#125; &#125; streamWriter.WriteLine(strRowOfData); &#125; streamWriter.Close(); fileStream.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// CSV转换为DataTable(默认 UTF8 编码)/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;CSV文件路径&lt;/param&gt;/// &lt;returns&gt;成功返回CSV的DataTable,失败返回NULL&lt;/returns&gt;public static DataTable CSVConversionDataTable(string strSource)&#123; try &#123; if (string.IsNullOrEmpty(strSource) || !File.Exists(strSource)) &#123; return null; &#125; DataTable dtTargetData = new DataTable(); //初始化 System.IO.FileStream 类的新实例 FileStream fileStreamOpen = new FileStream(strSource, FileMode.Open, FileAccess.Read); //从当前流中读取一行字符并将数据作为字符串返回 StreamReader streamReader = new StreamReader(fileStreamOpen, Encoding.UTF8); //记录当前读取到的一行数据 string strRowOfData; //记录当前是否为标题行 bool boolIsFirst = true; //循环获得CSV文件数据 while ((strRowOfData = streamReader.ReadLine()) != null) &#123; //从当前 System.String 对象中移除所有前导和尾随空白字符 strRowOfData.Trim(); //替换两遍连续两个 ,, 为 ,"",(希望数据里不存在两个逗号相连的情况) strRowOfData = strRowOfData.Replace(",,", ",\"\","); strRowOfData = strRowOfData.Replace(",,", ",\"\","); //如果截取第一个字符是 ',' 则在最前面加双引号 if (strRowOfData.Substring(0, 1) == ",") &#123; strRowOfData = string.Format("\"\"&#123;0&#125;", strRowOfData); &#125; //根据CSV规则分割字符串 string strRegexCSV = string.Format("[^\",]+|\"(?:[^\"]|\"\")*\""); Regex regexCSV = new Regex(strRegexCSV); MatchCollection matchCollection = regexCSV.Matches(strRowOfData); //判断是否为标题行 if (boolIsFirst) &#123; foreach (Match mColumnValue in matchCollection) &#123; dtTargetData.Columns.Add(InterceptionQuotes(mColumnValue.Value)); &#125; boolIsFirst = false; &#125; else &#123; DataRow drTargetData = dtTargetData.NewRow(); for (int iColumn = 0; iColumn &lt; dtTargetData.Columns.Count &amp;&amp; iColumn &lt; matchCollection.Count; iColumn++) &#123; drTargetData[iColumn] = InterceptionQuotes(matchCollection[iColumn].Value); &#125; dtTargetData.Rows.Add(drTargetData); &#125; &#125; streamReader.Close(); fileStreamOpen.Close(); return dtTargetData; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// CSV转换为DataTable/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;CSV文件路径&lt;/param&gt;/// &lt;param name="encoding"&gt;The character encoding to use.&lt;/param&gt;/// &lt;returns&gt;成功返回CSV的DataTable,失败返回NULL&lt;/returns&gt;public static DataTable CSVConversionDataTable(string strSource, Encoding encoding)&#123; try &#123; if (string.IsNullOrEmpty(strSource) || !File.Exists(strSource)) &#123; return null; &#125; DataTable dtTargetData = new DataTable(); //初始化 System.IO.FileStream 类的新实例 FileStream fileStreamOpen = new FileStream(strSource, FileMode.Open, FileAccess.Read); //从当前流中读取一行字符并将数据作为字符串返回 StreamReader streamReader = new StreamReader(fileStreamOpen, encoding); //记录当前读取到的一行数据 string strRowOfData; //记录当前是否为标题行 bool boolIsFirst = true; //循环获得CSV文件数据 while ((strRowOfData = streamReader.ReadLine()) != null) &#123; //从当前 System.String 对象中移除所有前导和尾随空白字符 strRowOfData.Trim(); //替换两遍连续两个 ,, 为 ,"",(希望数据里不存在两个逗号相连的情况) strRowOfData = strRowOfData.Replace(",,", ",\"\","); strRowOfData = strRowOfData.Replace(",,", ",\"\","); //如果截取第一个字符是 ',' 则在最前面加双引号 if (strRowOfData.Substring(0, 1) == ",") &#123; strRowOfData = string.Format("\"\"&#123;0&#125;", strRowOfData); &#125; //根据CSV规则分割字符串 string strRegexCSV = string.Format("[^\",]+|\"(?:[^\"]|\"\")*\""); Regex regexCSV = new Regex(strRegexCSV); MatchCollection matchCollection = regexCSV.Matches(strRowOfData); //判断是否为标题行 if (boolIsFirst) &#123; foreach (Match mColumnValue in matchCollection) &#123; dtTargetData.Columns.Add(InterceptionQuotes(mColumnValue.Value)); &#125; boolIsFirst = false; &#125; else &#123; DataRow drTargetData = dtTargetData.NewRow(); for (int iColumn = 0; iColumn &lt; dtTargetData.Columns.Count &amp;&amp; iColumn &lt; matchCollection.Count; iColumn++) &#123; drTargetData[iColumn] = InterceptionQuotes(matchCollection[iColumn].Value); &#125; dtTargetData.Rows.Add(drTargetData); &#125; &#125; streamReader.Close(); fileStreamOpen.Close(); return dtTargetData; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 截取字符串前后双引号/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;源字符串&lt;/param&gt;/// &lt;returns&gt;截取后字符串&lt;/returns&gt;private static string InterceptionQuotes(string strSource)&#123; try &#123; if (strSource[0] == '\"' &amp;&amp; strSource[strSource.Length - 1] == '\"') &#123; return strSource.Substring(1, strSource.Length - 2); &#125; else &#123; return strSource; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows屏幕截图帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F21%2Fcsharp-ScreenshotHelper%2F</url>
    <content type="text"><![CDATA[截取Windows屏幕全屏或指定区域帮助类 简介平时习惯于用QQ截图，但是公司一台电脑没有外网链接，登录不了QQ截图就很麻烦，通常是按PrtSc键截取全屏幕，然后在粘贴在Windows自带的画图应用中截取区域。原本计划自己实现一个仿制QQ截图（画笔、框选、编辑文字、提取颜色）的功能，但是一直也没有付诸行动，但是需要用到的技术栈都已经整理。屏幕录像的原理也是按照固定的FPS写入视频流，但是实际测试截取速度比较慢，无法稳定在30FPS以上。 帮助类ScreenshotHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/// &lt;summary&gt;/// 全屏幕截图/// &lt;/summary&gt;/// &lt;returns&gt;截图Bitmap&lt;/returns&gt;public static Bitmap ScreenshotFullScreen()&#123; try &#123; //得到屏幕整体宽度 double dPrimaryScreenWidth = SystemParameters.PrimaryScreenWidth; //得到屏幕整体高度 double dPrimaryScreenHeight = SystemParameters.PrimaryScreenHeight; //初始化使用指定的大小(屏幕大小)的 System.Drawing.Bitmap 类的新实例. Bitmap bitmapScreenshot = new Bitmap((int)dPrimaryScreenWidth, (int)dPrimaryScreenHeight); //从指定的载入原创建新的 System.Drawing.Graphics. Graphics graphicsScreenshot = Graphics.FromImage(bitmapScreenshot); //获取或设置绘制到此 System.Drawing.Graphics 的渲染质量:高质量 低速度合成. graphicsScreenshot.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality; //截取电脑屏幕:从屏幕到 System.Drawing.Graphics 的绘图图面. graphicsScreenshot.CopyFromScreen((int)0, (int)0, (int)0, (int)0, new System.Drawing.Size((int)dPrimaryScreenWidth, (int)dPrimaryScreenHeight)); return bitmapScreenshot; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 截取指定位置截图/// &lt;/summary&gt;/// &lt;param name="iStartX"&gt;截取起始坐标X&lt;/param&gt;/// &lt;param name="iStartY"&gt;截取起始坐标Y&lt;/param&gt;/// &lt;param name="iInterceptWidth"&gt;截取宽度&lt;/param&gt;/// &lt;param name="iInterceptHeight"&gt;截取高度&lt;/param&gt;/// &lt;returns&gt;截图Bitmap&lt;/returns&gt;public static Bitmap ScreenshotsSpecifyLocation(int iStartX, int iStartY, int iInterceptWidth, int iInterceptHeight)&#123; try &#123; //初始化使用指定的大小(屏幕大小)的 System.Drawing.Bitmap 类的新实例. Bitmap bitmapScreenshot = new Bitmap((int)iInterceptWidth, (int)iInterceptHeight); //从指定的载入原创建新的 System.Drawing.Graphics. Graphics graphicsScreenshot = Graphics.FromImage(bitmapScreenshot); //获取或设置绘制到此 System.Drawing.Graphics 的渲染质量:高质量 低速度合成. graphicsScreenshot.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality; //截取电脑屏幕:从屏幕到 System.Drawing.Graphics 的绘图图面. graphicsScreenshot.CopyFromScreen(iStartX, iStartY, (int)0, (int)0, new System.Drawing.Size((int)iInterceptWidth, (int)iInterceptHeight)); return bitmapScreenshot; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维码帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F06%2Fcsharp-QRCodeHelper%2F</url>
    <content type="text"><![CDATA[基于 ZXing.QrCode 库制作的横条码/二维码生成识别工具简介二维码（QR Code码） 在现在生活中十分常见，扫一扫即可付款。原本想要学习一下二维码原理自己造轮子，后来还是决定站在巨人的肩膀上使用Google的开源库ZXing来生成和识别二维码/横条码。 帮助类QRCodeHelper 帮助类提供二维码生成，带LOGO二维码，以及图像识别功能。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211/// &lt;summary&gt;/// 注销对象方法API/// &lt;/summary&gt;[DllImport("gdi32")]private static extern int DeleteObject(IntPtr o);/// &lt;summary&gt;/// 生成二维码/// &lt;/summary&gt;/// &lt;param name="strContent"&gt;二维码文本&lt;/param&gt;/// &lt;param name="iWidth"&gt;二维码宽度&lt;/param&gt;/// &lt;param name="iHeigth"&gt;二维码高度&lt;/param&gt;/// &lt;returns&gt;二维码位图&lt;/returns&gt;public static Bitmap GetQRCode(string strContent, int iWidth, int iHeigth)&#123; try &#123; //构造二维码写码器 MultiFormatWriter writer = new MultiFormatWriter(); Dictionary&lt;EncodeHintType, object&gt; hint = new Dictionary&lt;EncodeHintType, object&gt;(); hint.Add(EncodeHintType.CHARACTER_SET, "UTF-8"); hint.Add(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); hint.Add(EncodeHintType.MARGIN, 1); //生成二维码 BitMatrix bitMatrix = writer.encode(strContent, BarcodeFormat.QR_CODE, iWidth, iHeigth, hint); BarcodeWriter barcodeWriter = new BarcodeWriter(); Bitmap bitmapQRCode = barcodeWriter.Write(bitMatrix); //获取二维码实际尺寸(去掉二维码两边空白后的实际尺寸) int[] rectangle = bitMatrix.getEnclosingRectangle(); //将img转换成bmp格式，否则后面无法创建Graphics对象 Bitmap bitmapQRCodeBMP = new Bitmap(bitmapQRCode.Width, bitmapQRCode.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb); using (Graphics g = Graphics.FromImage(bitmapQRCodeBMP)) &#123; g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic; g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality; g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality; g.DrawImage(bitmapQRCode, 0, 0); &#125; return bitmapQRCodeBMP; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 生成二维码(带LOGO)/// &lt;/summary&gt;/// &lt;param name="strContent"&gt;二维码文本&lt;/param&gt;/// &lt;param name="iWidth"&gt;二维码宽度&lt;/param&gt;/// &lt;param name="iHeigth"&gt;二维码高度&lt;/param&gt;/// &lt;param name="strLogoPath"&gt;LOGO图片路径&lt;/param&gt;/// &lt;returns&gt;二维码位图&lt;/returns&gt;public static Bitmap GetQRCode_logo(string strContent, int iWidth, int iHeigth, string strLogoPath)&#123; try &#123; //构造二维码写码器 MultiFormatWriter writer = new MultiFormatWriter(); Dictionary&lt;EncodeHintType, object&gt; hint = new Dictionary&lt;EncodeHintType, object&gt;(); hint.Add(EncodeHintType.CHARACTER_SET, "UTF-8"); hint.Add(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); hint.Add(EncodeHintType.MARGIN, 1); //生成二维码 BitMatrix bitMatrix = writer.encode(strContent, BarcodeFormat.QR_CODE, iWidth, iHeigth, hint); BarcodeWriter barcodeWriter = new BarcodeWriter(); Bitmap bitmapQRCode = barcodeWriter.Write(bitMatrix); //获取二维码实际尺寸(去掉二维码两边空白后的实际尺寸) int[] rectangle = bitMatrix.getEnclosingRectangle(); //将img转换成bmp格式，否则后面无法创建Graphics对象 Bitmap bitmapQRCodeBMP = new Bitmap(bitmapQRCode.Width, bitmapQRCode.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb); using (Graphics g = Graphics.FromImage(bitmapQRCodeBMP)) &#123; g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic; g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality; g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality; g.DrawImage(bitmapQRCode, 0, 0); &#125; //获得LOGO位图并计算插入图片的大小和位置 Bitmap bitmapLogo = new Bitmap(strLogoPath); int middleW = Math.Min((int)(rectangle[2] / 3.5), bitmapLogo.Width); int middleH = Math.Min((int)(rectangle[3] / 3.5), bitmapLogo.Height); int middleL = (bitmapQRCode.Width - middleW) / 2; int middleT = (bitmapQRCode.Height - middleH) / 2; //将二维码插入图片(白底) Graphics myGraphic = Graphics.FromImage(bitmapQRCodeBMP); myGraphic.DrawImage(bitmapLogo, middleL, middleT, middleW, middleH); return bitmapQRCodeBMP; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 从位图获取图像源/// &lt;/summary&gt;/// &lt;param name="bitmapQRCode"&gt;位图二维码&lt;/param&gt;/// &lt;returns&gt;图像源(用以显示在控件上)&lt;/returns&gt;public static ImageSource GetImageSourceFromBitmap(Bitmap bitmapQRCode)&#123; try &#123; IntPtr ipQRCode = bitmapQRCode.GetHbitmap(); BitmapSource bitmapSource = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(ipQRCode, IntPtr.Zero, Int32Rect.Empty, System.Windows.Media.Imaging.BitmapSizeOptions.FromEmptyOptions()); DeleteObject(ipQRCode); return bitmapSource; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 识别二维码和条形码/// &lt;/summary&gt;/// &lt;param name="bitmapQRCode"&gt;二维码和条形码位图&lt;/param&gt;/// &lt;returns&gt;成功返回二维码和条形码内容,失败返回NULL或Empty&lt;/returns&gt;public static string BarcodeReader(Bitmap bitmapQRCode)&#123; try &#123; BarcodeReader barcodeReader = new BarcodeReader(); barcodeReader.Options.CharacterSet = "UTF-8"; Result resultQRCode = barcodeReader.Decode(bitmapQRCode); if (resultQRCode == null) &#123; return string.Empty; &#125; else &#123; return resultQRCode.Text; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 识别二维码和条形码/// &lt;/summary&gt;/// &lt;param name="strQRCodePath"&gt;二维码和条形码文件路径&lt;/param&gt;/// &lt;returns&gt;成功返回二维码和条形码内容,失败返回NULL或Empty&lt;/returns&gt;public static string BarcodeReader(string strQRCodePath)&#123; try &#123; BarcodeReader barcodeReader = new BarcodeReader(); barcodeReader.Options.CharacterSet = "UTF-8"; Bitmap bitmapQRCode = new Bitmap(strQRCodePath); Result resultQRCode = barcodeReader.Decode(bitmapQRCode); if (resultQRCode == null) &#123; return string.Empty; &#125; else &#123; return resultQRCode.Text; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 保存二维码和条形码位图到指定位置/// &lt;/summary&gt;/// &lt;param name="strSavePath"&gt;文件保存位置&lt;/param&gt;/// &lt;param name="bitmapQRCode"&gt;二维码和条形码位图&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool SaveBitmap(string strSavePath, Bitmap bitmapQRCode)&#123; try &#123; ImageFormat imageFormat; switch (System.IO.Path.GetExtension(strSavePath)) &#123; case ".bmp": imageFormat = ImageFormat.Bmp; break; case ".emf": imageFormat = ImageFormat.Emf; break; case ".exif": imageFormat = ImageFormat.Exif; break; case ".gif": imageFormat = ImageFormat.Gif; break; case ".icon": imageFormat = ImageFormat.Icon; break; case ".jpeg": imageFormat = ImageFormat.Jpeg; break; case ".jpg": imageFormat = ImageFormat.Jpeg; break; case ".memorybmp": imageFormat = ImageFormat.MemoryBmp; break; case ".png": imageFormat = ImageFormat.Png; break; case ".tiff": imageFormat = ImageFormat.Tiff; break; case ".wmf": imageFormat = ImageFormat.Wmf; break; default: imageFormat = ImageFormat.Png; break; &#125; bitmapQRCode.Save(strSavePath, imageFormat); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>qrcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows关机帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F06%2Fcsharp-ShutdownHelper%2F</url>
    <content type="text"><![CDATA[关闭Windows计算机帮助类…鬼知道为什么我关电脑也能整理出一篇文章。简介起初在刚接触C#时制作 Desktop Lock 时有设置自动关机的功能，使用的是执行 CMD 的 shutdown 命令，但是极容易出现被杀毒软件误报毒或误被取消关机。然后又通过调用 Win32 API 的方式关闭计算机。 帮助类ShutdownHelper CMD Shutdown123456789101112public void shutdown()&#123; Process myProcess = new Process(); myProcess.StartInfo.FileName = "cmd.exe"; myProcess.StartInfo.UseShellExecute = false; myProcess.StartInfo.RedirectStandardInput = true; myProcess.StartInfo.RedirectStandardOutput = true; myProcess.StartInfo.RedirectStandardError = true; myProcess.StartInfo.CreateNoWindow = true; myProcess.Start(); myProcess.StandardInput.WriteLine("shutdown -s -f -t 0");&#125; Win32 API12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485[StructLayout(LayoutKind.Sequential, Pack = 1)]internal struct TokPriv1Luid&#123; public int Count; public long Luid; public int Attr;&#125;[DllImport("kernel32.dll", ExactSpelling = true)]internal static extern IntPtr GetCurrentProcess();[DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]internal static extern bool OpenProcessToken(IntPtr h, int acc, ref IntPtr phtok);[DllImport("advapi32.dll", SetLastError = true)]internal static extern bool LookupPrivilegeValue(string host, string name, ref long pluid);[DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]internal static extern bool AdjustTokenPrivileges(IntPtr htok, bool disall, ref TokPriv1Luid newst, int len, IntPtr prev, IntPtr relen);[DllImport("user32.dll", ExactSpelling = true, SetLastError = true)]internal static extern bool ExitWindowsEx(int flg, int rea);internal const int SE_PRIVILEGE_ENABLED = 0x00000002;internal const int TOKEN_QUERY = 0x00000008;internal const int TOKEN_ADJUST_PRIVILEGES = 0x00000020;internal const string SE_SHUTDOWN_NAME = "SeShutdownPrivilege";internal const int EWX_LOGOFF = 0x00000000;internal const int EWX_SHUTDOWN = 0x00000001;internal const int EWX_REBOOT = 0x00000002;internal const int EWX_FORCE = 0x00000004;internal const int EWX_POWEROFF = 0x00000008;internal const int EWX_FORCEIFHUNG = 0x00000010;/// &lt;summary&gt;/// 关闭Windows/// &lt;/summary&gt;/// &lt;param name="flg"&gt;&lt;/param&gt;private static void DoExitWin(int flg)&#123; bool ok; TokPriv1Luid tp; IntPtr hproc = GetCurrentProcess(); IntPtr htok = IntPtr.Zero; ok = OpenProcessToken(hproc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ref htok); tp.Count = 1; tp.Luid = 0; tp.Attr = SE_PRIVILEGE_ENABLED; ok = LookupPrivilegeValue(null, SE_SHUTDOWN_NAME, ref tp.Luid); ok = AdjustTokenPrivileges(htok, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero); ok = ExitWindowsEx(flg, 0);&#125;/// &lt;summary&gt;/// 关闭计算机/// &lt;/summary&gt;public static void Shutdown()&#123; try &#123; DoExitWin(EWX_SHUTDOWN); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;/// &lt;summary&gt;/// 注销计算机/// &lt;/summary&gt;public static void Logoff()&#123; try &#123; DoExitWin(EWX_LOGOFF); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;/// &lt;summary&gt;/// 重启计算机/// &lt;/summary&gt;public static void Reboot()&#123; try &#123; DoExitWin(EWX_REBOOT); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
        <tag>shutdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑硬件信息帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F06%2Fcsharp-PCInformationHelper%2F</url>
    <content type="text"><![CDATA[获取电脑硬件基础信息，用于开发时作为唯一标示或注册激活使用帮助类及说明PCInformationHelper 获取的信息有：网卡MAC地址、CPU-ID、硬盘序列号、内存序列号、主板序列号、BIOS序列号、显卡信息。可拼接加密生成唯一序列号，可用于软件激活使用或作为其他唯一标识。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/// &lt;summary&gt;/// 读取网卡MAC地址/// &lt;/summary&gt;/// &lt;returns&gt;成功返回网卡MAC地址,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; MAC()&#123; try &#123; List&lt;string&gt; listMAC = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_NetworkAdapterConfiguration"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; if ((bool)mo["IPEnabled"]) &#123; strMac = mo["MacAddress"].ToString(); listMAC.Add(strMac); &#125; &#125; return listMAC; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取CPU-ID/// &lt;/summary&gt;/// &lt;returns&gt;成功返回CPU-ID,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; CPU()&#123; try &#123; List&lt;string&gt; listCPU = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_Processor"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Manufacturer = 处理器制造商 //Name = 处理器名字 //Processorid = CPU-ID strMac = mo["Processorid"].ToString(); listCPU.Add(strMac); &#125; return listCPU; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取硬盘序列号/// &lt;/summary&gt;/// &lt;returns&gt;成功返回硬盘序列号,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; DESK()&#123; try &#123; List&lt;string&gt; listDESK = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("win32_DiskDrive"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Model = 硬盘信息 //SerialNumber = 硬盘序列号 strMac = mo["SerialNumber"].ToString(); listDESK.Add(strMac); &#125; return listDESK; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取内存序列号/// &lt;/summary&gt;/// &lt;returns&gt;成功返回内存序列号,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; Memory()&#123; try &#123; List&lt;string&gt; listMemory = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_PhysicalMemory"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Manufacturer = 内存生产商 //SerialNumber = 序列号 strMac = mo["SerialNumber"].ToString(); listMemory.Add(strMac); &#125; return listMemory; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取主板序列号/// &lt;/summary&gt;/// &lt;returns&gt;成功返回主板序列号,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; Motherboard()&#123; try &#123; List&lt;string&gt; listMotherboard = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("WIN32_BaseBoard"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Manufacturer = 主板制造商 //Product = 主板型号 //SerialNumber = 序列号 strMac = mo["SerialNumber"].ToString(); listMotherboard.Add(strMac); &#125; return listMotherboard; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取BIOS序列号/// &lt;/summary&gt;/// &lt;returns&gt;成功返回BIOS序列号,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; BIOS()&#123; try &#123; List&lt;string&gt; listBIOS = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_BIOS"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Manufacturer = BIOS制造商名称 //SerialNumber = BIOS序列号 //ReleaseDate = 出厂日期 //Version = 版本号 strMac = mo["SerialNumber"].ToString(); listBIOS.Add(strMac); &#125; return listBIOS; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取显卡信息/// &lt;/summary&gt;/// &lt;returns&gt;成功返回显卡信息,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; Video()&#123; try &#123; List&lt;string&gt; listVideo = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_VideoController"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Name = 显卡信息 //DriverVersion = 驱动程序版本 strMac = mo["Name"].ToString(); listVideo.Add(strMac); &#125; return listVideo; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPOI/DOCX 帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F27%2Fcsharp-NPOIHelper%2F</url>
    <content type="text"><![CDATA[使用 NPOI/DocX 二次封装Office（Word、Excel）帮助类 简介工作中需要大量生成导出报表或合同证书文件，原理为使用Excel或Word模板，批量替换标签以达到效果。 设计由于原类库都属于基础方法，二次封装后具有更简易的使用方式，可直接传入生成的数据集或标签替换集合。 引用库介绍由于微软默认推荐的类库 Microsoft.Office.Interop.Word 与 Microsoft.Office.Interop.Excel 需要电脑安装 Microsoft Office 并引用COM组件才可以使用（已知调用打印机需引用COM组件），所以选用类库可独立于Office组件，在任意一台电脑也可以运行。NPOI：POI Java项目的.NET版本。可以非常轻松地读/写Office 2003/2007文件。DocX：DocX是一个.NET库，允许开发人员以简单直观的方式操作Word文件。 Excel文件操作ExcelHelper提供创建文件（2003/2007）及Sheet分页创建编辑，读取Excel文件至内存DataSet及反向DataSet保存至Excel文件。仅显示最外层引用方法，详细调用请在帮助类种查看！12345678910111213141516171819202122232425262728293031323334/// &lt;summary&gt;/// Excel所有分页转换为DataSet/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Excel文件路径&lt;/param&gt;/// &lt;returns&gt;成功返回Excel的DataSet,失败返回NULL&lt;/returns&gt;public static DataSet ExcelConversionDataSet(string strDataSourcePath)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || !File.Exists(strDataSourcePath)) &#123; return null; &#125; DataSet dsTargetData = new DataSet(); Dictionary&lt;int, string&gt; dicAllSheet = GetExcelAllSheet(strDataSourcePath); foreach (var vAllSheet in dicAllSheet) &#123; DataTable dtTargetData = new DataTable(); dtTargetData.TableName = vAllSheet.Value; dtTargetData = ExcelConversionDataTable(strDataSourcePath, vAllSheet.Value); if (dtTargetData == null) &#123; continue; &#125; dsTargetData.Tables.Add(dtTargetData); &#125; return dsTargetData; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt;/// DataSet转换为Excel/// 存在文件则新建DataTableName的分页(如果分页名冲突则或为空则使用默认名称)/// 不存在文件则新建(Excel,名称为DataTableName,如果没有则使用默认名称)/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Excel文件路径&lt;/param&gt;/// &lt;param name="dsSourceData"&gt;DataTable数据&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DataSetConversionExcel(string strDataSourcePath, DataSet dsSourceData)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || dsSourceData.Tables.Count &lt; 1) &#123; return false; &#125; foreach (DataTable dtSourceData in dsSourceData.Tables) &#123; Dictionary&lt;int, string&gt; dicAllSheet = GetExcelAllSheet(strDataSourcePath); string strTableName = string.IsNullOrEmpty(dtSourceData.TableName) ? string.Format("Sheet&#123;0&#125;", dicAllSheet.Count + 1) : dtSourceData.TableName; if (dicAllSheet.ContainsValue(dtSourceData.TableName)) &#123; RemoveExcelSheet(strDataSourcePath, dtSourceData.TableName); &#125; if (!FillDataTable(strDataSourcePath, strTableName, dtSourceData, true, 0, 0)) &#123; return false; &#125; &#125; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; 根据公司项目需要，把多个Excel的Sheet页的内容及样式合并为一个文件，Microsoft.Office.Interop.Excel提供拷贝分页方法，但是需要安装Microsoft Office，所以用NPOI类库实现了一个拷贝方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/// &lt;summary&gt;/// 拷贝Sheet页到另一个Sheet页/// &lt;/summary&gt;/// &lt;param name="strSourceExcelPath"&gt;源Excel路径&lt;/param&gt;/// &lt;param name="strFromSheetName"&gt;源Excel拷贝Sheet&lt;/param&gt;/// &lt;param name="strTargetExcelPath"&gt;目标Excel路径&lt;/param&gt;/// &lt;param name="strToSheetName"&gt;目标Excel拷贝Sheet&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CopySheet(string strSourceExcelPath, string strFromSheetName, string strTargetExcelPath, string strToSheetName)&#123; try &#123; if (string.IsNullOrEmpty(strSourceExcelPath) || string.IsNullOrEmpty(strTargetExcelPath) || !File.Exists(strSourceExcelPath)) &#123; TXTHelper.Logs(string.Format("源数据和目标数据参数为空或文件不存在!")); return false; &#125; if (string.IsNullOrEmpty(strFromSheetName) || string.IsNullOrEmpty(strToSheetName)) &#123; TXTHelper.Logs(string.Format("源Sheet页和目标Sheet页参数为空!")); return false; &#125; //获得源数据和目标数据的Sheet页 IWorkbook iSourceWorkbook = null; ISheet iSourceSheet = GetExcelSheetAt(strSourceExcelPath, strFromSheetName, out iSourceWorkbook); IWorkbook iTargetWorkbook = null; ISheet iTargetSheet = null; if (iSourceSheet == null) &#123; TXTHelper.Logs(string.Format("指定源数据Sheet页为空!")); return false; &#125; if (!File.Exists(strTargetExcelPath)) &#123; //如果文件不存在则创建Excel if (System.IO.Path.GetExtension(strTargetExcelPath) == ".xls") &#123; bool bCreare = CreateExcel_Office2003(strTargetExcelPath, strToSheetName); &#125; else if (System.IO.Path.GetExtension(strTargetExcelPath) == ".xlsx") &#123; bool bCreare = CreateExcel_Office2007(strTargetExcelPath, strToSheetName); &#125; else &#123; TXTHelper.Logs(string.Format("指定目标Excel文件路径格式错误!")); return false; &#125; iTargetSheet = GetExcelSheetAt(strTargetExcelPath, strToSheetName, out iTargetWorkbook); &#125; else &#123; //如果文件存在则判断是否存在执行Sheet Dictionary&lt;int, string&gt; dicAllSheet = GetExcelAllSheet(strTargetExcelPath); if (dicAllSheet.ContainsValue(strToSheetName)) &#123; iTargetSheet = GetExcelSheetAt(strTargetExcelPath, strToSheetName, out iTargetWorkbook); &#125; else &#123; iTargetSheet = CreateExcelSheetAt(strTargetExcelPath, strToSheetName, out iTargetWorkbook); &#125; &#125; //调用Sheet拷贝Sheet方法 bool bCopySheet = CopySheetAt(iSourceWorkbook, iSourceSheet, iTargetWorkbook, iTargetSheet); if (bCopySheet) &#123; if (System.IO.Path.GetExtension(strTargetExcelPath) == ".xls") &#123; FileStream fileStream2003 = new FileStream(Path.ChangeExtension(strTargetExcelPath, "xls"), FileMode.Create); iTargetWorkbook.Write(fileStream2003); fileStream2003.Close(); iTargetWorkbook.Close(); &#125; else if (System.IO.Path.GetExtension(strTargetExcelPath) == ".xlsx") &#123; FileStream fileStream2007 = new FileStream(Path.ChangeExtension(strTargetExcelPath, "xlsx"), FileMode.Create); iTargetWorkbook.Write(fileStream2007); fileStream2007.Close(); iTargetWorkbook.Close(); &#125; return true; &#125; else &#123; TXTHelper.Logs(string.Format("拷贝失败!")); return false; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// &lt;summary&gt;/// 拷贝Sheet页到另一个Sheet页(浅拷贝,不提供保存方法)/// Office2003单Sheet页仅支持4000个样式/// &lt;/summary&gt;/// &lt;param name="iSourceWorkbook"&gt;源Excel工作簿&lt;/param&gt;/// &lt;param name="iFromSheet"&gt;源Sheet页&lt;/param&gt;/// &lt;param name="iTargetWorkbook"&gt;目标Excel工作簿&lt;/param&gt;/// &lt;param name="iToSheet"&gt;目标Sheet页&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CopySheetAt(IWorkbook iSourceWorkbook, ISheet iFromSheet, IWorkbook iTargetWorkbook, ISheet iToSheet)&#123; try &#123; //拷贝数据 DataTable dtExcelFromData = GetDataTable(iFromSheet, false, 0, 0, 0, 0); iToSheet = FillDataTable(iToSheet, dtExcelFromData, false, 0, 0); //拷贝单元格合并 for (int iMergedRegions = 0; iMergedRegions &lt; iFromSheet.NumMergedRegions; iMergedRegions++) &#123; iToSheet.AddMergedRegion(iFromSheet.GetMergedRegion(iMergedRegions)); &#125; //拷贝样式(遍历Sheet页行) List&lt;ICellStyle&gt; listCellStyle = new List&lt;ICellStyle&gt;(); for (int iRowNum = 0; iRowNum &lt;= iFromSheet.LastRowNum; iRowNum++) &#123; IRow iFromRowData = iFromSheet.GetRow(iRowNum); IRow iToRowData = iToSheet.GetRow(iRowNum); if (iFromRowData == null || iToRowData == null) &#123; continue; &#125; //设置行高 short sFromHeight = iFromRowData.Height; iToRowData.Height = sFromHeight; //遍历Sheet页列 for (int iRowCell = 0; iRowCell &lt;= iFromRowData.LastCellNum; iRowCell++) &#123; //设置列宽 int iFromColumnWidth = iFromSheet.GetColumnWidth(iRowNum) / 256; iToSheet.SetColumnWidth(iRowNum, iFromColumnWidth * 256); //复制数据 ICell iFromCell = iFromRowData.GetCell(iRowCell); if (iFromCell != null) &#123; //获得源Sheet页的样式 ICellStyle iFromCellStyle = iFromCell.CellStyle; //获得目标Excel指定Cell ICell iToCell = iToRowData.GetCell(iRowCell); if (iToCell == null) continue; #region 复制单元格样式 //指定Cell创新目标Excel工作簿新样式 ICellStyle iToNewCellStyle = null; foreach (ICellStyle vCellStyle in listCellStyle) &#123; IFont iVToFont = vCellStyle.GetFont(iTargetWorkbook); IFont iFromFont = iFromCellStyle.GetFont(iSourceWorkbook); if (vCellStyle.Alignment == iFromCellStyle.Alignment &amp;&amp; vCellStyle.BorderBottom == iFromCellStyle.BorderBottom &amp;&amp; vCellStyle.BorderLeft == iFromCellStyle.BorderLeft &amp;&amp; vCellStyle.BorderRight == iFromCellStyle.BorderRight &amp;&amp; vCellStyle.BorderTop == iFromCellStyle.BorderTop &amp;&amp; vCellStyle.BottomBorderColor == iFromCellStyle.BottomBorderColor &amp;&amp; vCellStyle.DataFormat == iFromCellStyle.DataFormat &amp;&amp; vCellStyle.FillBackgroundColor == iFromCellStyle.FillBackgroundColor &amp;&amp; vCellStyle.FillForegroundColor == iFromCellStyle.FillForegroundColor &amp;&amp; vCellStyle.FillPattern == iFromCellStyle.FillPattern &amp;&amp; vCellStyle.Indention == iFromCellStyle.Indention &amp;&amp; vCellStyle.IsHidden == iFromCellStyle.IsHidden &amp;&amp; vCellStyle.IsLocked == iFromCellStyle.IsLocked &amp;&amp; vCellStyle.LeftBorderColor == iFromCellStyle.LeftBorderColor &amp;&amp; vCellStyle.RightBorderColor == iFromCellStyle.RightBorderColor &amp;&amp; vCellStyle.Rotation == iFromCellStyle.Rotation &amp;&amp; vCellStyle.TopBorderColor == iFromCellStyle.TopBorderColor &amp;&amp; vCellStyle.VerticalAlignment == iFromCellStyle.VerticalAlignment &amp;&amp; vCellStyle.WrapText == iFromCellStyle.WrapText &amp;&amp; //字体比对 iVToFont.Color == iFromFont.Color &amp;&amp; iVToFont.FontHeightInPoints == iFromFont.FontHeightInPoints &amp;&amp; iVToFont.FontName == iFromFont.FontName &amp;&amp; iVToFont.IsBold == iFromFont.IsBold &amp;&amp; iVToFont.IsItalic == iFromFont.IsItalic &amp;&amp; iVToFont.IsStrikeout == iFromFont.IsStrikeout &amp;&amp; iVToFont.Underline == iFromFont.Underline) &#123; iToNewCellStyle = vCellStyle; break; &#125; &#125; if (iToNewCellStyle == null) &#123; //创建新样式 iToNewCellStyle = iTargetWorkbook.CreateCellStyle(); //复制样式 iToNewCellStyle.Alignment = iFromCellStyle.Alignment;//对齐 iToNewCellStyle.BorderBottom = iFromCellStyle.BorderBottom;//下边框 iToNewCellStyle.BorderLeft = iFromCellStyle.BorderLeft;//左边框 iToNewCellStyle.BorderRight = iFromCellStyle.BorderRight;//右边框 iToNewCellStyle.BorderTop = iFromCellStyle.BorderTop;//上边框 iToNewCellStyle.BottomBorderColor = iFromCellStyle.BottomBorderColor;//下边框颜色 iToNewCellStyle.DataFormat = iFromCellStyle.DataFormat;//数据格式 iToNewCellStyle.FillBackgroundColor = iFromCellStyle.FillBackgroundColor;//填充背景色 iToNewCellStyle.FillForegroundColor = iFromCellStyle.FillForegroundColor;//填充前景色 iToNewCellStyle.FillPattern = iFromCellStyle.FillPattern;//填充图案 iToNewCellStyle.Indention = iFromCellStyle.Indention;//压痕 iToNewCellStyle.IsHidden = iFromCellStyle.IsHidden;//隐藏 iToNewCellStyle.IsLocked = iFromCellStyle.IsLocked;//锁定 iToNewCellStyle.LeftBorderColor = iFromCellStyle.LeftBorderColor;//左边框颜色 iToNewCellStyle.RightBorderColor = iFromCellStyle.RightBorderColor;//右边框颜色 iToNewCellStyle.Rotation = iFromCellStyle.Rotation;//旋转 iToNewCellStyle.TopBorderColor = iFromCellStyle.TopBorderColor;//上边框颜色 iToNewCellStyle.VerticalAlignment = iFromCellStyle.VerticalAlignment;//垂直对齐 iToNewCellStyle.WrapText = iFromCellStyle.WrapText;//文字换行 //复制字体 IFont iFromFont = iFromCellStyle.GetFont(iSourceWorkbook); IFont iToFont = iTargetWorkbook.CreateFont(); iToFont.Color = iFromFont.Color;//颜色 iToFont.FontHeightInPoints = iFromFont.FontHeightInPoints;//字号 iToFont.FontName = iFromFont.FontName;//字体 iToFont.IsBold = iFromFont.IsBold;//加粗 iToFont.IsItalic = iFromFont.IsItalic;//斜体 iToFont.IsStrikeout = iFromFont.IsStrikeout;//删除线 iToFont.Underline = iFromFont.Underline;//下划线 iToNewCellStyle.SetFont(iToFont); //保存到缓存集合中 listCellStyle.Add(iToNewCellStyle); &#125; //复制样式到指定表格中 iToCell.CellStyle = iToNewCellStyle; #endregion &#125; &#125; &#125; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; Word文件操作WordHelper提供创建文件（2003/2007）及替换段落表格标签（匹配替换’{标签}’,’#标签#’），替换图片功能。仅显示最外层引用方法，详细调用请在帮助类种查看！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/// &lt;summary&gt;/// 替换文本标签/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Word文件路径&lt;/param&gt;/// &lt;param name="strLabelName"&gt;标签名称(带标签符号)&lt;/param&gt;/// &lt;param name="strReplaceLabel"&gt;替换标签文本&lt;/param&gt;/// &lt;returns&gt;成功返回替换数量,失败返回-1&lt;/returns&gt;public static int ReplaceTextLabel(string strDataSourcePath, string strLabelName, string strReplaceLabel)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || !File.Exists(strDataSourcePath) || string.IsNullOrEmpty(strLabelName) || string.IsNullOrEmpty(strReplaceLabel)) &#123; return -1; &#125; int iNumber = 0; FileStream fileStreamOpen = new FileStream(strDataSourcePath, FileMode.Open, FileAccess.Read); XWPFDocument wordDocument = new XWPFDocument(fileStreamOpen); foreach (XWPFParagraph wordParagraph in wordDocument.Paragraphs) &#123; if (wordParagraph.ParagraphText.IndexOf(strLabelName) &gt;= 0) &#123; string strReplaceTextLabel = wordParagraph.ParagraphText.Replace(strLabelName, strReplaceLabel); foreach (XWPFRun wordRun in wordParagraph.Runs) &#123; wordRun.SetText(string.Empty, 0); &#125; wordParagraph.CreateRun().SetText(strReplaceTextLabel, 0); iNumber++; &#125; &#125; foreach (XWPFTable wordTable in wordDocument.Tables) &#123; foreach (XWPFTableRow wordTableRow in wordTable.Rows) &#123; foreach (XWPFTableCell wordTableCell in wordTableRow.GetTableCells()) &#123; foreach (XWPFParagraph wordParagraph in wordTableCell.Paragraphs) &#123; if (wordParagraph.ParagraphText.IndexOf(strLabelName) &gt;= 0) &#123; string strReplaceTextLabel = wordParagraph.ParagraphText.Replace(strLabelName, strReplaceLabel); foreach (XWPFRun wordRun in wordParagraph.Runs) &#123; wordRun.SetText(string.Empty, 0); &#125; wordParagraph.CreateRun().SetText(strReplaceTextLabel, 0); iNumber++; &#125; &#125; &#125; &#125; &#125; FileStream fileStreamSave = new FileStream(strDataSourcePath, FileMode.Create); wordDocument.Write(fileStreamSave); fileStreamSave.Close(); wordDocument.Close(); return iNumber; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return -1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/// &lt;summary&gt;/// 替换表格标签(DataTable替换)/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Word文件路径&lt;/param&gt;/// &lt;param name="strLabelName"&gt;标签名称(带标签符号)&lt;/param&gt;/// &lt;param name="dtReplaceLabel"&gt;替换标签DataTable&lt;/param&gt;/// &lt;returns&gt;成功返回1,失败返回-1&lt;/returns&gt;public static int ReplaceDataTableLabel(string strDataSourcePath, string strLabelName, DataTable dtReplaceLabel)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || !File.Exists(strDataSourcePath) || string.IsNullOrEmpty(strLabelName) || dtReplaceLabel == null || dtReplaceLabel.Rows.Count &lt; 1) &#123; return -1; &#125; FileStream fileStreamOpen = new FileStream(strDataSourcePath, FileMode.Open, FileAccess.Read); XWPFDocument wordDocument = new XWPFDocument(fileStreamOpen); int iLableRowPosition = -1; int iLableCellPosition = -1; foreach (XWPFTable wordTable in wordDocument.Tables) &#123; for (int iTableRow = 0; iTableRow &lt; wordTable.Rows.Count; iTableRow++) &#123; for (int iTableCell = 0; iTableCell &lt; wordTable.Rows[iTableRow].GetTableCells().Count; iTableCell++) &#123; foreach (XWPFParagraph wordParagraph in wordTable.Rows[iTableRow].GetTableCells()[iTableCell].Paragraphs) &#123; if (wordParagraph.ParagraphText.IndexOf(strLabelName) &gt;= 0) &#123; if (iLableRowPosition &lt; 0 &amp;&amp; iLableCellPosition &lt; 0) &#123; iLableRowPosition = iTableRow; iLableCellPosition = iTableCell; &#125; &#125; if (iLableRowPosition &gt;= 0 &amp;&amp; iLableCellPosition &gt;= 0) &#123; int iCurrentRow = iTableRow - iLableRowPosition; int iCurrentCell = iTableCell - iLableCellPosition; if ((iCurrentRow &lt; dtReplaceLabel.Rows.Count &amp;&amp; iCurrentRow &gt;= 0) &amp;&amp; (iCurrentCell &lt; dtReplaceLabel.Columns.Count &amp;&amp; iCurrentCell &gt;= 0)) &#123; foreach (XWPFRun wordRun in wordParagraph.Runs) &#123; wordRun.SetText(string.Empty, 0); &#125; wordParagraph.CreateRun().SetText(dtReplaceLabel.Rows[iCurrentRow][iCurrentCell].ToString(), 0); &#125; &#125; &#125; &#125; &#125; &#125; FileStream fileStreamSave = new FileStream(strDataSourcePath, FileMode.Create); wordDocument.Write(fileStreamSave); fileStreamSave.Close(); wordDocument.Close(); return 1; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return -1; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// &lt;summary&gt;/// 替换图片标签(使用DocX.dll类库,调用这个方法后NPOI无法读取文档)/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Word文件路径&lt;/param&gt;/// &lt;param name="strLabelName"&gt;标签名称(带标签符号)&lt;/param&gt;/// &lt;param name="strImagePath"&gt;替换的图片路径&lt;/param&gt;/// &lt;param name="iImageWidth"&gt;替换的图片宽度(小于0则显示原图宽度)&lt;/param&gt;/// &lt;param name="iImageHeight"&gt;替换的图片高度(小于0则显示原图高度)&lt;/param&gt;/// &lt;returns&gt;成功返回替换数量,失败返回-1&lt;/returns&gt;public static int ReplaceImageLabel(string strDataSourcePath, string strLabelName, string strImagePath, int iImageWidth, int iImageHeight)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || !File.Exists(strDataSourcePath) || string.IsNullOrEmpty(strLabelName) || string.IsNullOrEmpty(strImagePath) || !File.Exists(strImagePath)) &#123; return -1; &#125; int iNumber = 0; //使用DocX.dll类库 DocX mDocX = DocX.Load(strDataSourcePath); //遍历段落 foreach (Paragraph wordParagraph in mDocX.Paragraphs) &#123; if (wordParagraph.Text.IndexOf(strLabelName) &gt;= 0) &#123; //添加图片 Novacode.Image pImag = mDocX.AddImage(strImagePath); Picture pPicture = pImag.CreatePicture(); //如果传入宽度小于0,则以原始大小插入 if (iImageWidth &gt;= 0) &#123; pPicture.Width = iImageWidth; &#125; //如果传入高度小于0,则以原始大小插入 if (iImageHeight &gt;= 0) &#123; pPicture.Height = iImageHeight; &#125; //将图像插入到段落后面 wordParagraph.InsertPicture(pPicture); //清空文本(清空放在前面会导致替换失败文字消失) wordParagraph.ReplaceText(strLabelName, string.Empty); iNumber++; &#125; &#125; mDocX.SaveAs(strDataSourcePath); return iNumber; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return -1; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>npoi</tag>
        <tag>docx</tag>
        <tag>excel</tag>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZIP压缩文件帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F25%2Fcsharp-ZIPHelper%2F</url>
    <content type="text"><![CDATA[操作 ZIP/7z 压缩文件帮助类，以及压缩数据文本的 GZIP 帮助类 简介工作中会有需求把数据集打包成压缩文件，封装一个帮助以方便调用。ZIP 通用且最为常见的压缩格式。7-ZIP 自由开源的压缩格式，压缩效果要比普通的ZIP效果要好。GZIP 用于压缩数据流或文本。 帮助类代码及引用ZIP：ZIPHelper 引用 ICSharpCode.SharpZipLib.Zip 库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197/// &lt;summary&gt;/// 压缩ZIP文件/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="listFolderOrFilePath"&gt;需要压缩的文件夹或文件&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CompressionZip(string strZipPath, List&lt;string&gt; listFolderOrFilePath)&#123; return CompressionZip(strZipPath, listFolderOrFilePath, string.Empty);&#125;/// &lt;summary&gt;/// 压缩ZIP文件(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="listFolderOrFilePath"&gt;需要压缩的文件夹或文件&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CompressionZip(string strZipPath, List&lt;string&gt; listFolderOrFilePath, string strPassword)&#123; try &#123; ZipOutputStream ComStream = new ZipOutputStream(File.Create(strZipPath)); //压缩等级(0-9) ComStream.SetLevel(9); //压缩文件加密 if (!string.IsNullOrEmpty(strPassword)) &#123; ComStream.Password = strPassword; &#125; foreach (string strFolderOrFilePath in listFolderOrFilePath) &#123; if (Directory.Exists(strFolderOrFilePath)) &#123; //如果路径是文件目录 CompressionZipDirectory(strFolderOrFilePath, ComStream, string.Empty); &#125; else if (File.Exists(strFolderOrFilePath)) &#123; //如果路径是文件路径 FileStream fileStream = File.OpenRead(strFolderOrFilePath); byte[] btsLength = new byte[fileStream.Length]; fileStream.Read(btsLength, 0, btsLength.Length); ZipEntry zipEntry = new ZipEntry(new FileInfo(strFolderOrFilePath).Name); ComStream.PutNextEntry(zipEntry); ComStream.Write(btsLength, 0, btsLength.Length); &#125; &#125; ComStream.Finish(); ComStream.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 压缩ZIP文件夹/// &lt;/summary&gt;/// &lt;param name="strRootPath"&gt;根目录路径&lt;/param&gt;/// &lt;param name="ComStream"&gt;ZIP文件输出流&lt;/param&gt;/// &lt;param name="strSubPath"&gt;子目录路径&lt;/param&gt;private static void CompressionZipDirectory(string strRootPath, ZipOutputStream ComStream, string strSubPath)&#123; try &#123; //创建当前文件夹 ZipEntry zipEntry = new ZipEntry(Path.Combine(strSubPath, Path.GetFileName(strRootPath) + "/")); ComStream.PutNextEntry(zipEntry); ComStream.Flush(); //遍历压缩目录 foreach (string strFolder in Directory.GetDirectories(strRootPath)) &#123; CompressionZipDirectory(strFolder, ComStream, Path.Combine(strSubPath, Path.GetFileName(strRootPath))); &#125; //遍历压缩文件 foreach (string strFileName in Directory.GetFiles(strRootPath)) &#123; FileStream fileStream = File.OpenRead(strFileName); byte[] btsLength = new byte[fileStream.Length]; fileStream.Read(btsLength, 0, btsLength.Length); zipEntry = new ZipEntry(Path.Combine(strSubPath, Path.GetFileName(strRootPath) + "/" + Path.GetFileName(strFileName))); ComStream.PutNextEntry(zipEntry); ComStream.Write(btsLength, 0, btsLength.Length); if (fileStream != null) &#123; fileStream.Close(); fileStream.Dispose(); &#125; &#125; if (zipEntry != null) &#123; zipEntry = null; &#125; GC.Collect(); GC.Collect(1); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;/// &lt;summary&gt;/// 解压缩ZIP文件/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strDeCompressionPath"&gt;需要解压到的指定位置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeCompressionZip(string strZipPath, string strDeCompressionPath)&#123; return DeCompressionZip(strZipPath, strDeCompressionPath, string.Empty);&#125;/// &lt;summary&gt;/// 解压缩ZIP文件(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strDeCompressionPath"&gt;需要解压到的指定位置&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeCompressionZip(string strZipPath, string strDeCompressionPath, string strPassword)&#123; try &#123; if (string.IsNullOrEmpty(strZipPath) || !File.Exists(strZipPath)) &#123; return false; &#125; ZipInputStream inputStream = new ZipInputStream(File.OpenRead(strZipPath)); //压缩文件解密 if (!string.IsNullOrEmpty(strPassword)) &#123; inputStream.Password = strPassword; &#125; ZipEntry zipEntry = null; while ((zipEntry = inputStream.GetNextEntry()) != null) &#123; if (!string.IsNullOrEmpty(zipEntry.Name)) &#123; string strFileName = Path.Combine(strDeCompressionPath, zipEntry.Name); strFileName = strFileName.Replace('/', '\\'); if (strFileName.EndsWith("\\")) &#123; Directory.CreateDirectory(strFileName); &#125; else &#123; FileStream fileStream = null; int intSize = 2048; byte[] btsData = new byte[intSize]; while (true) &#123; intSize = inputStream.Read(btsData, 0, btsData.Length); if (fileStream == null) &#123; fileStream = File.Create(strFileName); &#125; if (intSize &gt; 0) &#123; fileStream.Write(btsData, 0, btsData.Length); &#125; else &#123; break; &#125; &#125; if (fileStream != null) &#123; fileStream.Close(); fileStream.Dispose(); &#125; &#125; &#125; &#125; if (zipEntry != null) &#123; zipEntry = null; &#125; if (inputStream != null) &#123; inputStream.Close(); inputStream.Dispose(); &#125; GC.Collect(); GC.Collect(1); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; 7-ZIP：ZIP7Helper 动态引用 7z.dll 库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284/// &lt;summary&gt;/// 获得当前系统X86架构7ZIP类库路径/// &lt;/summary&gt;public static string strX86_DllPath&#123; get &#123; return string.Format(@"&#123;0&#125;\x86\7z.dll", System.Environment.CurrentDirectory); &#125;&#125;/// &lt;summary&gt;/// 获得当前系统X64架构7ZIP类库路径/// &lt;/summary&gt;public static string strX64_DllPath&#123; get &#123; return string.Format(@"&#123;0&#125;\x64\7z.dll", System.Environment.CurrentDirectory); &#125;&#125;/// &lt;summary&gt;/// 动态链接7ZIP类库/// &lt;/summary&gt;private static void SetLibraryPath7z()&#123; //动态链接7ZIP类库 if (IntPtr.Size == 8) &#123; SevenZipExtractor.SetLibraryPath(strX64_DllPath); &#125; else &#123; SevenZipExtractor.SetLibraryPath(strX86_DllPath); &#125;&#125;/// &lt;summary&gt;/// 压缩7-ZIP文件/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="fileFullNames"&gt;需要压缩的文件&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool Compression7Zip(string strZipPath, params string[] fileFullNames)&#123; try &#123; //动态链接7ZIP类库 SetLibraryPath7z(); //默认格式为(*.7z) strZipPath = Path.ChangeExtension(strZipPath, "7z"); //压缩7-ZIP文件 SevenZipCompressor sevenZipCompressor = new SevenZipCompressor(); //压缩等级(默认正常值) sevenZipCompressor.CompressionLevel = CompressionLevel.Normal; //压缩格式(默认7z压缩) sevenZipCompressor.ArchiveFormat = OutArchiveFormat.SevenZip; //是否保持目录结构(默认为true) sevenZipCompressor.DirectoryStructure = true; //是否包含空目录(默认true) sevenZipCompressor.IncludeEmptyDirectories = true; //压缩目录时是否使用顶层目录(默认false) sevenZipCompressor.PreserveDirectoryRoot = false; //加密7z头(默认false) sevenZipCompressor.EncryptHeaders = false; //文件加密算法 sevenZipCompressor.ZipEncryptionMethod = ZipEncryptionMethod.ZipCrypto; //尽快压缩(不会触发*Started事件,仅触发*Finished事件) sevenZipCompressor.FastCompression = false; //压缩文件 sevenZipCompressor.CompressFiles(strZipPath, fileFullNames); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 压缩7-ZIP文件(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;param name="fileFullNames"&gt;需要压缩的文件&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool Compression7Zip(string strZipPath, string strPassword, params string[] fileFullNames)&#123; try &#123; //动态链接7ZIP类库 SetLibraryPath7z(); //默认格式为(*.7z) strZipPath = Path.ChangeExtension(strZipPath, "7z"); //压缩7-ZIP文件 SevenZipCompressor sevenZipCompressor = new SevenZipCompressor(); //压缩等级(默认正常值) sevenZipCompressor.CompressionLevel = CompressionLevel.Normal; //压缩格式(默认7z压缩) sevenZipCompressor.ArchiveFormat = OutArchiveFormat.SevenZip; //是否保持目录结构(默认为true) sevenZipCompressor.DirectoryStructure = true; //是否包含空目录(默认true) sevenZipCompressor.IncludeEmptyDirectories = true; //压缩目录时是否使用顶层目录(默认false) sevenZipCompressor.PreserveDirectoryRoot = false; //加密7z头(默认false) sevenZipCompressor.EncryptHeaders = true; //文件加密算法 sevenZipCompressor.ZipEncryptionMethod = ZipEncryptionMethod.ZipCrypto; //尽快压缩(不会触发*Started事件,仅触发*Finished事件) sevenZipCompressor.FastCompression = false; //压缩文件 sevenZipCompressor.CompressFilesEncrypted(strZipPath, strPassword, fileFullNames); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 压缩7-ZIP文件夹/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件夹&lt;/param&gt;/// &lt;param name="strDirectory"&gt;需要压缩的文件夹&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool Compression7ZipDirectory(string strZipPath, string strDirectory)&#123; try &#123; //动态链接7ZIP类库 SetLibraryPath7z(); //默认格式为(*.7z) strZipPath = Path.ChangeExtension(strZipPath, "7z"); //压缩7-ZIP文件 SevenZipCompressor sevenZipCompressor = new SevenZipCompressor(); //压缩等级(默认正常值) sevenZipCompressor.CompressionLevel = CompressionLevel.Normal; //压缩格式(默认7z压缩) sevenZipCompressor.ArchiveFormat = OutArchiveFormat.SevenZip; //是否保持目录结构(默认为true) sevenZipCompressor.DirectoryStructure = true; //是否包含空目录(默认true) sevenZipCompressor.IncludeEmptyDirectories = true; //压缩目录时是否使用顶层目录(默认false) sevenZipCompressor.PreserveDirectoryRoot = false; //加密7z头(默认false) sevenZipCompressor.EncryptHeaders = false; //文件加密算法 sevenZipCompressor.ZipEncryptionMethod = ZipEncryptionMethod.ZipCrypto; //尽快压缩(不会触发*Started事件,仅触发*Finished事件) sevenZipCompressor.FastCompression = false; //压缩文件 sevenZipCompressor.CompressDirectory(strDirectory, strZipPath); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 压缩7-ZIP文件夹(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件夹&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;param name="strDirectory"&gt;需要压缩的文件夹&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool Compression7ZipDirectory(string strZipPath, string strPassword, string strDirectory)&#123; try &#123; //动态链接7ZIP类库 SetLibraryPath7z(); //默认格式为(*.7z) strZipPath = Path.ChangeExtension(strZipPath, "7z"); //压缩7-ZIP文件 SevenZipCompressor sevenZipCompressor = new SevenZipCompressor(); //压缩等级(默认正常值) sevenZipCompressor.CompressionLevel = CompressionLevel.Normal; //压缩格式(默认7z压缩) sevenZipCompressor.ArchiveFormat = OutArchiveFormat.SevenZip; //是否保持目录结构(默认为true) sevenZipCompressor.DirectoryStructure = true; //是否包含空目录(默认true) sevenZipCompressor.IncludeEmptyDirectories = true; //压缩目录时是否使用顶层目录(默认false) sevenZipCompressor.PreserveDirectoryRoot = false; //加密7z头(默认false) sevenZipCompressor.EncryptHeaders = true; //文件加密算法 sevenZipCompressor.ZipEncryptionMethod = ZipEncryptionMethod.ZipCrypto; //尽快压缩(不会触发*Started事件,仅触发*Finished事件) sevenZipCompressor.FastCompression = false; //压缩文件 sevenZipCompressor.CompressDirectory(strDirectory, strZipPath, strPassword); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 解压缩7-ZIP文件/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strDeCompressionPath"&gt;需要解压到的指定位置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeCompression7Zip(string strZipPath, string strDeCompressionPath)&#123; try &#123; if (string.IsNullOrEmpty(strZipPath) || !File.Exists(strZipPath)) &#123; return false; &#125; //动态链接7ZIP类库 SetLibraryPath7z(); //创建目录 if (!Directory.Exists(strDeCompressionPath)) &#123; Directory.CreateDirectory(strDeCompressionPath); &#125; //解压数据 SevenZipExtractor sevenZipExtractor = new SevenZipExtractor(strZipPath); foreach (ArchiveFileInfo itemArchiveFileInfo in sevenZipExtractor.ArchiveFileData) &#123; sevenZipExtractor.ExtractFiles(strDeCompressionPath, itemArchiveFileInfo.Index); &#125; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 解压缩7-ZIP文件(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strDeCompressionPath"&gt;需要解压到的指定位置&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeCompression7Zip(string strZipPath, string strDeCompressionPath, string strPassword)&#123; try &#123; if (string.IsNullOrEmpty(strZipPath) || !File.Exists(strZipPath)) &#123; return false; &#125; //动态链接7ZIP类库 SetLibraryPath7z(); //创建目录 if (!Directory.Exists(strDeCompressionPath)) &#123; Directory.CreateDirectory(strDeCompressionPath); &#125; //解压数据 SevenZipExtractor sevenZipExtractor = new SevenZipExtractor(strZipPath, strPassword); foreach (ArchiveFileInfo itemArchiveFileInfo in sevenZipExtractor.ArchiveFileData) &#123; sevenZipExtractor.ExtractFiles(strDeCompressionPath, itemArchiveFileInfo.Index); &#125; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; GZIP：GZIPHelper 引用 System.IO.Compression.GZipStream 库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/// &lt;summary&gt;/// 压缩GZIP数据/// &lt;/summary&gt;/// &lt;param name="bytesSourceData"&gt;源数据&lt;/param&gt;/// &lt;returns&gt;压缩数据&lt;/returns&gt;public static byte[] CompressionGZIP(byte[] bytesSourceData)&#123; try &#123; MemoryStream memoryStream = new MemoryStream(); GZipStream compressedzipStream = new GZipStream(memoryStream, CompressionMode.Compress, true); compressedzipStream.Write(bytesSourceData, 0, bytesSourceData.Length); compressedzipStream.Close(); return memoryStream.ToArray(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 解压缩GZIP数据/// &lt;/summary&gt;/// &lt;param name="bytesSourceData"&gt;源数据&lt;/param&gt;/// &lt;returns&gt;解压缩数据&lt;/returns&gt;public static byte[] DeCompressionGZIP(byte[] bytesSourceData)&#123; try &#123; MemoryStream memoryStream = new MemoryStream(bytesSourceData); GZipStream compressedzipStream = new GZipStream(memoryStream, CompressionMode.Decompress); MemoryStream outBuffer = new MemoryStream(); byte[] block = new byte[1024]; while (true) &#123; int bytesRead = compressedzipStream.Read(block, 0, block.Length); if (bytesRead &lt;= 0) break; else outBuffer.Write(block, 0, bytesRead); &#125; compressedzipStream.Close(); return outBuffer.ToArray(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 压缩String类型GZIP数据/// &lt;/summary&gt;/// &lt;param name="strSourceData"&gt;源数据&lt;/param&gt;/// &lt;returns&gt;压缩数据(Base64)&lt;/returns&gt;public static string CompressionStringGZIP(string strSourceData)&#123; try &#123; if (!string.IsNullOrEmpty(strSourceData)) &#123; byte[] rawData = Encoding.UTF8.GetBytes(strSourceData); byte[] zippedData = CompressionGZIP(rawData); return Convert.ToBase64String(zippedData); &#125; else &#123; return string.Empty; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 解压缩String类型GZIP数据/// &lt;/summary&gt;/// &lt;param name="strSourceData"&gt;源数据(Base64)&lt;/param&gt;/// &lt;returns&gt;解压缩数据&lt;/returns&gt;public static string DeCompressionStringGZIP(string strSourceData)&#123; try &#123; if (!string.IsNullOrEmpty(strSourceData)) &#123; byte[] zippedData = Convert.FromBase64String(strSourceData.ToString()); return Encoding.UTF8.GetString(DeCompressionGZIP(zippedData)); &#125; else &#123; return string.Empty; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>zip</tag>
        <tag>7z</tag>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP 共享帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F24%2Fcsharp-FTPSharingHelper%2F</url>
    <content type="text"><![CDATA[基于 Serv-U 搭建的 FTP 帮助类 简介Serv-U 是一种被广泛运用的FTP服务器端软件。现FTP服务器还是公司企业普遍运用的文件储存方式，编写帮助类用于自动上传下载管理服务。 核心代码FTPSharingHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354/// &lt;summary&gt;/// FTP服务器URL(统一资源定位符)/// &lt;/summary&gt;public static string strFTPServerURL &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器IP地址/// &lt;/summary&gt;public static string strFTPServerIP &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器端口号/// &lt;/summary&gt;public static string strFTPServerPort &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器路径/// &lt;/summary&gt;public static string strFTPServerPath &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器用户名/// &lt;/summary&gt;public static string strFTPServerUserID &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器用户密码/// &lt;/summary&gt;public static string strFTPServerPassword &#123; get; set; &#125;/// &lt;summary&gt; /// 实现了文件传输协议(FTP)客户端/// &lt;/summary&gt; FtpWebRequest Request = null;/// &lt;summary&gt;/// FTP连接URL/// &lt;/summary&gt;/// &lt;param name="FTPServerURL"&gt;FTP服务器URL(统一资源定位符)&lt;/param&gt;/// &lt;param name="FTPServerUserID"&gt;FTP服务器用户名&lt;/param&gt;/// &lt;param name="FTPServerPassword"&gt;FTP服务器用户密码&lt;/param&gt;public void FTPConnectionURL(string FTPServerURL, string FTPServerUserID, string FTPServerPassword)&#123; strFTPServerURL = FTPServerURL; strFTPServerUserID = FTPServerUserID; strFTPServerPassword = FTPServerPassword;&#125;/// &lt;summary&gt;/// FTP连接URL/// &lt;/summary&gt;/// &lt;param name="FTPServerIP"&gt;FTP服务器IP地址&lt;/param&gt;/// &lt;param name="FTPServerPort"&gt;FTP服务器端口号&lt;/param&gt;/// &lt;param name="FTPServerPath"&gt;FTP服务器路径&lt;/param&gt;/// &lt;param name="FTPServerUserID"&gt;FTP服务器用户名&lt;/param&gt;/// &lt;param name="FTPServerPassword"&gt;FTP服务器用户密码&lt;/param&gt;public void FTPConnectionURL(string FTPServerIP, string FTPServerPort, string FTPServerPath, string FTPServerUserID, string FTPServerPassword)&#123; strFTPServerIP = FTPServerIP; strFTPServerPort = FTPServerPort; strFTPServerPath = FTPServerPath; strFTPServerUserID = FTPServerUserID; strFTPServerPassword = FTPServerPassword; strFTPServerURL = "ftp://" + strFTPServerIP + ":" + strFTPServerPort + "/" + strFTPServerPath + "/";&#125;/// &lt;summary&gt;/// 获得URL路径下文件列表/// &lt;/summary&gt;/// &lt;returns&gt;文件列表List&lt;/returns&gt;public List&lt;string&gt; GetFilesDetailList()&#123; try &#123; List&lt;string&gt; listAllFiles = new List&lt;string&gt;(); Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.ListDirectoryDetails; WebResponse Response = Request.GetResponse(); StreamReader Reader = new StreamReader(Response.GetResponseStream()); string strLine = Reader.ReadLine(); while (strLine != null) &#123; if (AnalysisLISTCommand(strLine).FileType == "-") &#123; listAllFiles.Add(AnalysisLISTCommand(strLine).FileName); &#125; strLine = Reader.ReadLine(); &#125; Reader.Close(); Response.Close(); return listAllFiles; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 获得URL路径下文件夹列表/// &lt;/summary&gt;/// &lt;returns&gt;文件列表List&lt;/returns&gt;public List&lt;string&gt; GetFoldersDetailList()&#123; try &#123; List&lt;string&gt; listAllFiles = new List&lt;string&gt;(); Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.ListDirectoryDetails; WebResponse Response = Request.GetResponse(); StreamReader Reader = new StreamReader(Response.GetResponseStream()); string strLine = Reader.ReadLine(); while (strLine != null) &#123; if (AnalysisLISTCommand(strLine).FileType == "d") &#123; listAllFiles.Add(AnalysisLISTCommand(strLine).FileName); &#125; strLine = Reader.ReadLine(); &#125; Reader.Close(); Response.Close(); return listAllFiles; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 获得指定URL路径下指定文件属性/// &lt;/summary&gt;/// &lt;param name="strFileName"&gt;URL中指定文件名&lt;/param&gt;/// &lt;returns&gt;FTP-FTP-LIST命令返回参数数据模型,失败返回NULL&lt;/returns&gt;public FTPListTypeModel GetFolderOrFileType(string strFileName)&#123; try &#123; FtpWebRequest fRequest = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFileName)); fRequest.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); fRequest.Method = WebRequestMethods.Ftp.ListDirectoryDetails; FtpWebResponse Response = (FtpWebResponse)fRequest.GetResponse(); Stream ftpStream = Response.GetResponseStream(); StreamReader Reader = new StreamReader(ftpStream); string strLine = Reader.ReadLine(); Reader.Close(); Response.Close(); return AnalysisLISTCommand(strLine); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 新建URL路径下文件夹/// &lt;/summary&gt;/// &lt;param name="strFolderName"&gt;文件夹名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool CreateFolder(string strFolderName)&#123; try &#123; Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFolderName)); Request.Method = WebRequestMethods.Ftp.MakeDirectory; Request.UseBinary = true; Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); FtpWebResponse response = (FtpWebResponse)Request.GetResponse(); Stream ftpStream = response.GetResponseStream(); ftpStream.Close(); response.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除URL路径下指定文件/// &lt;/summary&gt;/// &lt;param name="strFileName"&gt;URL中指定文件名&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool DeleteFile(string strFileName)&#123; try &#123; Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFileName)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.DeleteFile; Request.KeepAlive = false; FtpWebResponse Response = (FtpWebResponse)Request.GetResponse(); Stream ftpStream = Response.GetResponseStream(); ftpStream.Close(); Response.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除URL路径下指定文件夹/// &lt;/summary&gt;/// &lt;param name="strFolderName"&gt;文件夹名&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool DeleteFolder(string strFolderName)&#123; try &#123; Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFolderName)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.RemoveDirectory; Request.KeepAlive = false; FtpWebResponse Response = (FtpWebResponse)Request.GetResponse(); Stream ftpStream = Response.GetResponseStream(); ftpStream.Close(); Response.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 上传文件到指定URL路径/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;需要上传的文件路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool UploadFile(string strFilePath)&#123; try &#123; FileInfo fileInfo = new FileInfo(strFilePath); Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + fileInfo.Name)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.UploadFile; Request.KeepAlive = false; Request.UseBinary = true; Request.ContentLength = fileInfo.Length; int buffLength = 2048; byte[] buff = new byte[buffLength]; int contentLen; FileStream fileFtpStream = fileInfo.OpenRead(); Stream ftpStream = Request.GetRequestStream(); contentLen = fileFtpStream.Read(buff, 0, buffLength); while (contentLen != 0) &#123; ftpStream.Write(buff, 0, contentLen); contentLen = fileFtpStream.Read(buff, 0, buffLength); &#125; ftpStream.Close(); fileFtpStream.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 下载指定URL中的文件到指定路径/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件下载到的路径&lt;/param&gt;/// &lt;param name="strFileName"&gt;URL中指定文件名&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool DownloadFile(string strFilePath, string strFileName)&#123; try &#123; if (!Directory.Exists(strFilePath)) &#123; Directory.CreateDirectory(strFilePath); &#125; FileStream fileStream = new FileStream(strFilePath + "\\" + strFileName, FileMode.Create); Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFileName)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.DownloadFile; Request.UseBinary = true; FtpWebResponse response = (FtpWebResponse)Request.GetResponse(); Stream ftpStream = response.GetResponseStream(); int bufferSize = 2048; int readCount; byte[] buffer = new byte[bufferSize]; readCount = ftpStream.Read(buffer, 0, bufferSize); while (readCount &gt; 0) &#123; fileStream.Write(buffer, 0, readCount); readCount = ftpStream.Read(buffer, 0, bufferSize); &#125; ftpStream.Close(); fileStream.Close(); response.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 解析FTP-LIST命令/// &lt;/summary&gt;/// &lt;param name="strListCommand"&gt;FTP-LIST命令&lt;/param&gt;private FTPListTypeModel AnalysisLISTCommand(string strListCommand)&#123; FTPListTypeModel ListType = new FTPListTypeModel(); //根据空格拆分成 9 部分 string[] strListCommandSplit = strListCommand.Split(new char[] &#123; ' ', '\t' &#125;, StringSplitOptions.RemoveEmptyEntries); //文件类型 位数(1) ListType.FileType = strListCommandSplit[0].Substring(0, 1); //文件属主拥有权限 位数(2-4) ListType.UserOwnership = strListCommandSplit[0].Substring(1, 3); //文件属主同一组用户拥有权限 位数(5-7) ListType.GroupUserOwnership = strListCommandSplit[0].Substring(4, 3); //其他用户拥有权限 位数(8-10) ListType.OtherUserOwnership = strListCommandSplit[0].Substring(7, 3); //未知参数1 (1) ListType.UnknownParameter1 = strListCommandSplit[1]; //未知参数2 (user) ListType.UnknownParameter2 = strListCommandSplit[2]; //未知参数3 (group) ListType.UnknownParameter3 = strListCommandSplit[3]; //文件大小(文件夹为0) ListType.FileSize = strListCommandSplit[4]; //文件月份 ListType.FileMonth = strListCommandSplit[5]; //文件日期 ListType.FileDay = strListCommandSplit[6]; //文件年份或时间 ListType.FileYearOrTime = strListCommandSplit[7]; //文件名称 ListType.FileName = strListCommandSplit[8]; return ListType;&#125; 应用一个同学的需求：公司是做三维模型模具的，领导要求每个人每次修改上传至FTP，然后领导每天会定时完整下载（虽然我也不理解为什么他们不用SVN或者GIT，需求是什么样的就做成什么样嘛！）。功能需求是制作一个控制台程序，通过任务计划中每天下班定时执行即可。FTP参数调用本地INI配置文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void Main(string[] args)&#123; string strPath = System.AppDomain.CurrentDomain.SetupInformation.ApplicationBase + "Config.ini"; string strFTP = INIHelper.INIGetStringValue(strPath, "System", "FTP", ""); string strUser = INIHelper.INIGetStringValue(strPath, "System", "User", ""); string strPassword = INIHelper.INIGetStringValue(strPath, "System", "Password", ""); string strSavePath = INIHelper.INIGetStringValue(strPath, "System", "SavePath", ""); FTPSharingHelper ftp = new FTPSharingHelper(); ftp.FTPConnectionURL(strFTP, strUser, strPassword); DownloadFile(ftp, strFTP, strUser, strPassword, strSavePath);&#125;/// &lt;summary&gt;/// 下载目录所有文件/// &lt;/summary&gt;/// &lt;param name="ftp"&gt;FTP链接&lt;/param&gt;/// &lt;param name="strFTP"&gt;链接地址&lt;/param&gt;/// &lt;param name="strUser"&gt;用户名&lt;/param&gt;/// &lt;param name="strPassword"&gt;密码&lt;/param&gt;/// &lt;param name="strSavePath"&gt;保存路径&lt;/param&gt;public static void DownloadFile(FTPSharingHelper ftp, string strFTP, string strUser, string strPassword, string strSavePath)&#123; try &#123; ftp.FTPConnectionURL(strFTP, strUser, strPassword); //下载当前目录文件 List&lt;string&gt; list1 = ftp.GetFilesDetailList(); if (list1 != null) &#123; foreach (var item in list1) &#123; ftp.DownloadFile(strSavePath, item); &#125; &#125; //下载文件夹文件 List&lt;string&gt; list2 = ftp.GetFoldersDetailList(); if (list2 != null) &#123; foreach (var item in list2) &#123; if (item.Substring(0, 1).Equals(".")) &#123; continue; &#125; string strNewFTP = strFTP + item + "/"; string strNewSavePath = strSavePath + "\\" + item; if (!Directory.Exists(strNewSavePath)) &#123; Directory.CreateDirectory(strNewSavePath); &#125; DownloadFile(ftp, strNewFTP, strUser, strPassword, strNewSavePath); &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件共享帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F23%2Fcsharp-FileSharingHelper%2F</url>
    <content type="text"><![CDATA[基于 Win32 API 与 CMD 命令制作可视化文件共享工具简介不论是工作使用或是平时经常会出现两台电脑网线直连拷贝文件的情况（通过外网传输速度会受带宽限制，飞秋这种局域网聊天软件需要两台电脑同时安装，硬件存储设备需要拷贝两次，Ftp需要搭建环境，所以大部分情况下文件共享还是最好的解决方案），但是就像我这种对系统比较熟悉的人，每次操作也要找一会，与其记住命令不如做出一个可视化界面。 核心代码FileSharingHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/// &lt;summary&gt;/// 读取共享文件信息/// &lt;/summary&gt;/// &lt;returns&gt;共享信息DataTable('name':'共享文件名称','path':'共享文件路径','permissions':'访问控制权限','type':'共享文件属性')&lt;/returns&gt;public static DataTable InquireShareFile()&#123; try &#123; ManagementObjectSearcher searcher = new ManagementObjectSearcher("select * from win32_share"); DataTable ShareFile = new DataTable(); ShareFile.Columns.Add("name"); ShareFile.Columns.Add("path"); ShareFile.Columns.Add("permissions"); ShareFile.Columns.Add("type"); foreach (ManagementObject share in searcher.Get()) &#123; try &#123; //获取共享文件信息 string name = share["Name"].ToString(); string path = share["Path"].ToString(); string type = share["Type"].ToString(); if (type == "0") &#123; type = "磁盘驱动器"; &#125; else if (type == "1") &#123; type = "打印队列"; &#125; else if (type == "2") &#123; type = "设备"; &#125; else if (type == "3") &#123; type = "IPC"; &#125; else if (type == "2147483648") &#123; type = "磁盘驱动器管理"; &#125; else if (type == "2147483649") &#123; type = "打印队列管理"; &#125; else if (type == "2147483650") &#123; type = "设备管理"; &#125; else if (type == "2147483651") &#123; type = "IPC 管理员"; &#125; //获得共享文件访问权限(通过cmd搜索) string Permissions = ""; string cmd = string.Format("net share &#123;0&#125;", name); string strOutput = ImplementationCMD(cmd); if (strOutput.IndexOf("FULL") &gt; -1) &#123; Permissions = "完全控制"; &#125; else if (strOutput.IndexOf("READ") &gt; -1) &#123; Permissions = "只读"; &#125; else if (strOutput.IndexOf("CHANGE") &gt; -1) &#123; Permissions = "读取/写入"; &#125; //数据写入DataTable DataRow dr = ShareFile.NewRow(); dr["name"] = name; dr["path"] = path; dr["permissions"] = Permissions; dr["type"] = type; ShareFile.Rows.Add(dr); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125; &#125; return ShareFile; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 新增共享/// &lt;/summary&gt;/// &lt;param name="FolderPath"&gt;共享文件路径&lt;/param&gt;/// &lt;param name="ShareName"&gt;共享文件名称&lt;/param&gt;/// &lt;param name="Permissions"&gt;访问控制权限('完全控制':'FULL','只读':'READ','读取/写入':'CHANGE')&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool AddShareFolder(string FolderPath, string ShareName, string Permissions)&#123; try &#123; //输入命令NET SHARE sharename=drive:path [/GRANT:user,[READ | CHANGE | FULL] string cmd = string.Format(@"net share &#123;0&#125;=&#123;1&#125; /grant:&#123;2&#125;,&#123;3&#125;", ShareName, FolderPath, System.Environment.UserName, Permissions); string strOutput = ImplementationCMD(cmd); return strOutput.IndexOf("共享成功") &gt; -1 ? true : false; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 新增共享/// &lt;/summary&gt;/// &lt;param name="FolderPath"&gt;共享文件路径&lt;/param&gt;/// &lt;param name="ShareName"&gt;共享文件名称&lt;/param&gt;/// &lt;param name="PermissionsType"&gt;访问控制权限(枚举)&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool AddShareFolder(string FolderPath, string ShareName, SharingPermissions.PermissionsType PermissionsType)&#123; try &#123; //输入命令NET SHARE sharename=drive:path [/GRANT:user,[READ | CHANGE | FULL] string cmd = string.Format(@"net share &#123;0&#125;=&#123;1&#125; /grant:&#123;2&#125;,&#123;3&#125;", ShareName, FolderPath, System.Environment.UserName, PermissionsType); string strOutput = ImplementationCMD(cmd); return strOutput.IndexOf("共享成功") &gt; -1 ? true : false; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除共享/// &lt;/summary&gt;/// &lt;param name="FolderPath"&gt;共享文件夹路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteShareFolder(string FolderPath)&#123; try &#123; //输入命令NET SHARE sharename \\computername /DELETE string cmd = string.Format(@"net share &#123;0&#125; /delete /y", FolderPath); string strOutput = ImplementationCMD(cmd); return strOutput.IndexOf("已经删除") &gt; -1 ? true : false; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 执行CMD命令/// &lt;/summary&gt;/// &lt;param name="cmd"&gt;cmd命令&lt;/param&gt;/// &lt;returns&gt;cmd窗口的输出信息&lt;/returns&gt;private static string ImplementationCMD(string cmd)&#123; try &#123; //使用cmd命令对文件共享进行操作 System.Diagnostics.Process p = new System.Diagnostics.Process(); p.StartInfo.FileName = "cmd.exe"; //是否使用操作系统shell启动 p.StartInfo.UseShellExecute = false; //接受来自调用程序的输入信息 p.StartInfo.RedirectStandardInput = true; //由调用程序获取输出信息 p.StartInfo.RedirectStandardOutput = true; //重定向标准错误输出 p.StartInfo.RedirectStandardError = true; //不显示程序窗口 p.StartInfo.CreateNoWindow = true; //启动程序 p.Start(); //执行CMD命令 p.StandardInput.WriteLine(cmd); p.StandardInput.AutoFlush = true; p.StandardInput.WriteLine("exit"); //获取cmd窗口的输出信息 string strOutput = p.StandardOutput.ReadToEnd(); p.WaitForExit();//等待程序执行完退出进程 p.Close(); return strOutput; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
        <tag>filesharing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[INI文件帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F10%2Fcsharp-INIHelper%2F</url>
    <content type="text"><![CDATA[操作 INI 文件帮助类 简介INI 即初始化文件，是windows的系统配置文件所采用的存储格式。也是现在软件开发最常见的配置文件。INIHelper 帮助类主要提供INI配置文件创建，节点增删改。 INI文件操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284#region INI 文本帮助类 API 声明/// &lt;summary&gt;/// 获取所有节点名称(Section)/// &lt;/summary&gt;/// &lt;param name="lpszReturnBuffer"&gt;存放节点名称的内存地址,每个节点之间用\0分隔&lt;/param&gt;/// &lt;param name="nSize"&gt;内存大小(characters)&lt;/param&gt;/// &lt;param name="lpFileName"&gt;Ini文件&lt;/param&gt;/// &lt;returns&gt;内容的实际长度,为0表示没有内容,为nSize-2表示内存大小不够&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileSectionNames(IntPtr lpszReturnBuffer, uint nSize, string lpFileName);/// &lt;summary&gt;/// 获取某个指定节点(Section)中所有KEY和Value/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称&lt;/param&gt;/// &lt;param name="lpReturnedString"&gt;返回值的内存地址,每个之间用\0分隔&lt;/param&gt;/// &lt;param name="nSize"&gt;内存大小(characters)&lt;/param&gt;/// &lt;param name="lpFileName"&gt;Ini文件&lt;/param&gt;/// &lt;returns&gt;内容的实际长度,为0表示没有内容,为nSize-2表示内存大小不够&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileSection(string lpAppName, IntPtr lpReturnedString, uint nSize, string lpFileName);/// &lt;summary&gt;/// 读取INI文件中指定的Key的值/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称.如果为null,则读取INI中所有节点名称,每个节点名称之间用\0分隔&lt;/param&gt;/// &lt;param name="lpKeyName"&gt;Key名称.如果为null,则读取INI中指定节点中的所有KEY,每个KEY之间用\0分隔&lt;/param&gt;/// &lt;param name="lpDefault"&gt;读取失败时的默认值&lt;/param&gt;/// &lt;param name="lpReturnedString"&gt;读取的内容缓冲区,读取之后,多余的地方使用\0填充&lt;/param&gt;/// &lt;param name="nSize"&gt;内容缓冲区的长度&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件名&lt;/param&gt;/// &lt;returns&gt;实际读取到的长度&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, [In, Out] char[] lpReturnedString, uint nSize, string lpFileName);/// &lt;summary&gt;/// 另一种声明方式,使用 StringBuilder 作为缓冲区类型的缺点是不能接受\0字符,会将\0及其后的字符截断,所以对于lpAppName或lpKeyName为null的情况就不适用/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称.如果为null,则读取INI中所有节点名称,每个节点名称之间用\0分隔&lt;/param&gt;/// &lt;param name="lpKeyName"&gt;Key名称.如果为null,则读取INI中指定节点中的所有KEY,每个KEY之间用\0分隔&lt;/param&gt;/// &lt;param name="lpDefault"&gt;读取失败时的默认值&lt;/param&gt;/// &lt;param name="lpReturnedString"&gt;读取的内容缓冲区,读取之后,多余的地方使用\0填充&lt;/param&gt;/// &lt;param name="nSize"&gt;内容缓冲区的长度&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件名&lt;/param&gt;/// &lt;returns&gt;实际读取到的长度&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, StringBuilder lpReturnedString, uint nSize, string lpFileName);/// &lt;summary&gt;/// 再一种声明,使用string作为缓冲区的类型同char[]/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称.如果为null,则读取INI中所有节点名称,每个节点名称之间用\0分隔&lt;/param&gt;/// &lt;param name="lpKeyName"&gt;Key名称.如果为null,则读取INI中指定节点中的所有KEY,每个KEY之间用\0分隔&lt;/param&gt;/// &lt;param name="lpDefault"&gt;读取失败时的默认值&lt;/param&gt;/// &lt;param name="lpReturnedString"&gt;读取的内容缓冲区,读取之后,多余的地方使用\0填充&lt;/param&gt;/// &lt;param name="nSize"&gt;内容缓冲区的长度&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件名&lt;/param&gt;/// &lt;returns&gt;实际读取到的长度&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, string lpReturnedString, uint nSize, string lpFileName);/// &lt;summary&gt;/// 将指定的键值对写到指定的节点,如果已经存在则替换./// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点,如果不存在此节点,则创建此节点&lt;/param&gt;/// &lt;param name="lpString"&gt;Item键值对,多个用\0分隔,形如key1=value1\0key2=value2;如果为string.Empty,则删除指定节点下的所有内容,保留节点;如果为null,则删除指定节点下的所有内容,并且删除该节点&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件&lt;/param&gt;/// &lt;returns&gt;是否成功写入&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern bool WritePrivateProfileSection(string lpAppName, string lpString, string lpFileName);/// &lt;summary&gt;/// 将指定的键和值写到指定的节点，如果已经存在则替换/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称&lt;/param&gt;/// &lt;param name="lpKeyName"&gt;键名称。如果为null，则删除指定的节点及其所有的项目&lt;/param&gt;/// &lt;param name="lpString"&gt;值内容。如果为null，则删除指定节点中指定的键。&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)][return: MarshalAs(UnmanagedType.Bool)]private static extern bool WritePrivateProfileString(string lpAppName, string lpKeyName, string lpString, string lpFileName);#endregion#region INI 文本帮助类 封装方法/// &lt;summary&gt;/// 读取INI文件中指定INI文件中的所有节点名称(Section)/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;Ini文件&lt;/param&gt;/// &lt;returns&gt;所有节点,没有内容返回string[0]&lt;/returns&gt;public static string[] INIGetAllSectionNames(string iniFile)&#123; //默认为32767 uint MAX_BUFFER = 32767; //返回值 string[] sections = new string[0]; //申请内存 IntPtr pReturnedString = Marshal.AllocCoTaskMem((int)MAX_BUFFER * sizeof(char)); uint bytesReturned = GetPrivateProfileSectionNames(pReturnedString, MAX_BUFFER, iniFile); if (bytesReturned != 0) &#123; //读取指定内存的内容 string local = Marshal.PtrToStringAuto(pReturnedString, (int)bytesReturned).ToString(); //每个节点之间用\0分隔,末尾有一个\0 sections = local.Split(new char[] &#123; '\0' &#125;, StringSplitOptions.RemoveEmptyEntries); &#125; //释放内存 Marshal.FreeCoTaskMem(pReturnedString); return sections;&#125;/// &lt;summary&gt;/// 获取INI文件中指定节点(Section)中的所有条目(key=value形式)/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;Ini文件&lt;/param&gt;/// &lt;param name="section"&gt;节点名称&lt;/param&gt;/// &lt;returns&gt;指定节点中的所有项目,没有内容返回string[0]&lt;/returns&gt;public static string[] INIGetAllItems(string iniFile, string section)&#123; //返回值形式为 key=value,例如 Color=Red; uint MAX_BUFFER = 32767; string[] items = new string[0]; //分配内存 IntPtr pReturnedString = Marshal.AllocCoTaskMem((int)MAX_BUFFER * sizeof(char)); uint bytesReturned = GetPrivateProfileSection(section, pReturnedString, MAX_BUFFER, iniFile); if (!(bytesReturned == MAX_BUFFER - 2) || (bytesReturned == 0)) &#123; string returnedString = Marshal.PtrToStringAuto(pReturnedString, (int)bytesReturned); items = returnedString.Split(new char[] &#123; '\0' &#125;, StringSplitOptions.RemoveEmptyEntries); &#125; //释放内存 Marshal.FreeCoTaskMem(pReturnedString); return items;&#125;/// &lt;summary&gt;/// 获取INI文件中指定节点(Section)中的所有条目的Key列表/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;Ini文件&lt;/param&gt;/// &lt;param name="section"&gt;节点名称&lt;/param&gt;/// &lt;returns&gt;如果没有内容,反回string[0]&lt;/returns&gt;public static string[] INIGetAllItemKeys(string iniFile, string section)&#123; string[] value = new string[0]; const int SIZE = 1024 * 10; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; char[] chars = new char[SIZE]; uint bytesReturned = GetPrivateProfileString(section, null, null, chars, SIZE, iniFile); if (bytesReturned != 0) &#123; value = new string(chars).Split(new char[] &#123; '\0' &#125;, StringSplitOptions.RemoveEmptyEntries); &#125; chars = null; return value;&#125;/// &lt;summary&gt;/// 读取INI文件中指定KEY的字符串型值/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;Ini文件&lt;/param&gt;/// &lt;param name="section"&gt;节点名称&lt;/param&gt;/// &lt;param name="key"&gt;键名称&lt;/param&gt;/// &lt;param name="defaultValue"&gt;如果没此KEY所使用的默认值&lt;/param&gt;/// &lt;returns&gt;读取到的值&lt;/returns&gt;public static string INIGetStringValue(string iniFile, string section, string key, string defaultValue)&#123; string value = defaultValue; const int SIZE = 1024 * 10; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; if (string.IsNullOrEmpty(key)) &#123; throw new ArgumentException("必须指定键名称(key)", "key"); &#125; StringBuilder sb = new StringBuilder(SIZE); uint bytesReturned = GetPrivateProfileString(section, key, defaultValue, sb, SIZE, iniFile); if (bytesReturned != 0) &#123; value = sb.ToString(); &#125; sb = null; return value;&#125;/// &lt;summary&gt;/// 在INI文件中,将指定的键值对写到指定的节点,如果已经存在则替换/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点,如果不存在此节点,则创建此节点&lt;/param&gt;/// &lt;param name="items"&gt;键值对,多个用\0分隔,形如key1=value1\0key2=value2&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static bool INIWriteItems(string iniFile, string section, string items)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; if (string.IsNullOrEmpty(items)) &#123; throw new ArgumentException("必须指定键值对", "items"); &#125; return WritePrivateProfileSection(section, items, iniFile);&#125;/// &lt;summary&gt;/// 在INI文件中,指定节点写入指定的键及值.如果已经存在,则替换.如果没有则创建./// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点&lt;/param&gt;/// &lt;param name="key"&gt;键&lt;/param&gt;/// &lt;param name="value"&gt;值&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;public static bool INIWriteValue(string iniFile, string section, string key, string value)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; if (string.IsNullOrEmpty(key)) &#123; throw new ArgumentException("必须指定键名称", "key"); &#125; if (value == null) &#123; throw new ArgumentException("值不能为null", "value"); &#125; return WritePrivateProfileString(section, key, value, iniFile);&#125;/// &lt;summary&gt;/// 在INI文件中,删除指定节点中的指定的键./// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点&lt;/param&gt;/// &lt;param name="key"&gt;键&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;public static bool INIDeleteKey(string iniFile, string section, string key)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; if (string.IsNullOrEmpty(key)) &#123; throw new ArgumentException("必须指定键名称", "key"); &#125; return WritePrivateProfileString(section, key, null, iniFile);&#125;/// &lt;summary&gt;/// 在INI文件中,删除指定的节点./// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;public static bool INIDeleteSection(string iniFile, string section)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; return WritePrivateProfileString(section, null, null, iniFile);&#125;/// &lt;summary&gt;/// 在INI文件中,删除指定节点中的所有内容./// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;public static bool INIEmptySection(string iniFile, string section)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; return WritePrivateProfileSection(section, string.Empty, iniFile);&#125;#endregion]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>ini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 在此处打开命令窗口]]></title>
    <url>%2Fblog%2F2017%2F01%2F26%2Fsystem-OpenCMDHere%2F</url>
    <content type="text"><![CDATA[Win10 鼠标右键在此处打开CMD窗口 简介Windows 10 一直想使用 Power Shell 代替原有的 CMD，功能更加强大的同时也伴随很多弊病，例如：内存占用（测试CMD占用10.9MB内存，PowerShell占用37.2MB内存）、启动和执行速度较慢（高配电脑打扰了）、蓝色的底也看起来并不怎么舒服（虽然都能改）、多按两下Backspace还滴滴滴滴滴。 解决方案主要修改地址在Win10的文件夹处Shift+鼠标右键原有的”在此处打开命令窗口(M)”被修改为”在此处打开 Powershell 窗口(S)”，通过修改注册表的方式在鼠标右键添加CMD的打开方式（当前目录）。复制以下内容到文本中存为 reg文件，双击运行添加到注册表中即可。1234567Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCMDHere]&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCMDHere\command]@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot; 更简单的方案2020年3月1日更新：在学习 .Net Core EF 时查阅 MSDN 才发现了一个更简单的方式。教程：使用迁移功能 - ASP.NET MVC 和 EF Core直接在文件夹中地址栏输入：“cmd” 或 “powershell” 即可。]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>windows</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADO.NET 帮助类]]></title>
    <url>%2Fblog%2F2016%2F12%2F21%2Fcsharp-ADOHelper%2F</url>
    <content type="text"><![CDATA[使用 ADO.NET 二次封装ORM框架的数据库操作帮助类简介工作中大量需要多种不同数据格式互相转换，通过ADO.NET实现可视化数据转换工具，目前支持关系型数据库SqlServer、Oracle、MySql、Access、SQLite。 设计简易的ORM框架，多种数据库操作封装为一套帮助类中，后期使用不需要过多考虑数据库类型，以及减少在代码中拼写SQL语句。近乎通用的连接方式以及增删改查，支持事务处理。 帮助类、官方文档及其调用方式SQLServer：SqlServerHelper 引用 System.Data.SqlClient 库调用方式：1234SqlServerHelper sqlHelper = new SqlServerHelper();sqlHelper.SqlServerConnectionString(string server, string database, string uid, string pwd);sqlHelper.Open();sqlHelper.Close(); Oracle：OracleHelper 引用 System.Data.OracleClient 库调用方式：1234OracleHelper sqlHelper = new OracleHelper();sqlHelper.OracleConnectionString(string Source, string Id, string Password);sqlHelper.Open();sqlHelper.Close(); MySQL：MySqlHelper 引用 MySql.Data.MySqlClient 库调用方式：1234MySqlHelper sqlHelper = new MySqlHelper();sqlHelper.MySqlConnectionString(string server, string id, string password, string database);sqlHelper.Open();sqlHelper.Close(); Access：AccessHelper 引用 System.Data.OleDb 库调用方式：12345AccessHelper sqlHelper = new AccessHelper();sqlHelper.AccessConnectionPath_Office2003(string source);sqlHelper.AccessConnectionPath_Office2007(string source);sqlHelper.Open();sqlHelper.Close(); SQLite：SQLiteHelper 引用 System.Data.SQLite 库调用方式：1234SQLiteHelper sqlHelper = new SQLiteHelper();sqlHelper.SQLiteConnectionPath(string source);sqlHelper.Open();sqlHelper.Close(); 数据转换帮助类由于每种数据库的字段类型、字符格式长度等不一致，所以专门写了一个用于互相兼容的帮助类，用于自动识别源数据库与目标数据库差异，自动修改。数据转换帮助类 删除DataTable中的空行数据源以C#基础类型DataTable传递，在实际使用中存在空行导致异常12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt;/// 删除DataTable中的空行/// 弱引用,可直接修改参数/// &lt;/summary&gt;/// &lt;param name="dtDataSource"&gt;源数据(DataTable)&lt;/param&gt;/// &lt;returns&gt;删除空行后的DataTable&lt;/returns&gt;public static DataTable RemoveEmpty(DataTable dtDataSource)&#123; try &#123; List&lt;DataRow&gt; listRemove = new List&lt;DataRow&gt;(); for (int i = 0; i &lt; dtDataSource.Rows.Count; i++) &#123; bool IsNull = true; for (int j = 0; j &lt; dtDataSource.Columns.Count; j++) &#123; if (!string.IsNullOrEmpty(dtDataSource.Rows[i][j].ToString().Trim())) &#123; IsNull = false; &#125; &#125; if (IsNull) &#123; listRemove.Add(dtDataSource.Rows[i]); &#125; &#125; for (int i = 0; i &lt; listRemove.Count; i++) &#123; dtDataSource.Rows.Remove(listRemove[i]); &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125; return dtDataSource;&#125; DataTable与List互相转换实际使用中List比DataTable更方便使用，提供互相转换方法方便开发123456789101112131415161718192021222324252627282930313233343536373839404142/// &lt;summary&gt;/// DataTable转换为List&lt;T&gt;/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;数据模型&lt;/typeparam&gt;/// &lt;param name="dtDataSource"&gt;源数据(DataTable)&lt;/param&gt;/// &lt;returns&gt;成功返回List&lt;T&gt;,失败返回null&lt;/returns&gt;public static List&lt;T&gt; ConvertToList&lt;T&gt;(DataTable dtDataSource) where T : class,new()&#123; try &#123; List&lt;T&gt; listT = new List&lt;T&gt;(); foreach (DataRow drDataSource in dtDataSource.Rows) &#123; T t = new T(); PropertyInfo[] propertyInfos = t.GetType().GetProperties(); foreach (PropertyInfo propertyInfo in propertyInfos) &#123; string tempName = propertyInfo.Name; if (dtDataSource.Columns.Contains(tempName)) &#123; if (!propertyInfo.CanWrite) continue; object value = drDataSource[tempName]; if (value != DBNull.Value) &#123; if (propertyInfo.GetMethod.ReturnParameter.ParameterType.Name == "Int32") &#123; value = Convert.ToInt32(value); &#125; propertyInfo.SetValue(t, value, null); &#125; &#125; &#125; listT.Add(t); &#125; return listT; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125; return null;&#125; 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// List&lt;T&gt;转换为DataTable/// &lt;/summary&gt;/// &lt;param name="listDataSource"&gt;源数据&lt;/param&gt;/// &lt;returns&gt;成功返回DataTable,失败返回null&lt;/returns&gt;public static DataTable ConvertDataTable(IList listDataSource)&#123; try &#123; DataTable dataTable = new DataTable(); if (listDataSource.Count &gt; 0) &#123; PropertyInfo[] propertyInfos = listDataSource[0].GetType().GetProperties(); foreach (PropertyInfo propertyInfo in propertyInfos) &#123; dataTable.Columns.Add(propertyInfo.Name, propertyInfo.PropertyType); &#125; foreach (var vDataSource in listDataSource) &#123; ArrayList arrayList = new ArrayList(); foreach (PropertyInfo propertyInfo in propertyInfos) &#123; arrayList.Add(propertyInfo.GetValue(vDataSource, null)); &#125; dataTable.LoadDataRow(arrayList.ToArray(), true); &#125; &#125; return dataTable; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125; return null;&#125; String转Unicode,并去除’\ufeff’非法字符个别数据中存在有非法字符，避免异常，转换时批量处理1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt;/// 去除非法字符'\\ufeff'/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;数据源&lt;/param&gt;/// &lt;returns&gt;修正后的字符&lt;/returns&gt;public static string RemoveIllegal(string strSource)&#123; return UnicodeToString(StringToUnicode(strSource));&#125;/// &lt;summary&gt;/// String转Unicode,并去除'\\ufeff'非法字符/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;数据源&lt;/param&gt;/// &lt;returns&gt;Unicode编码字符&lt;/returns&gt;public static string StringToUnicode(string strSource)&#123; StringBuilder stringBuilder = new StringBuilder(); //先把字符串转换成 UTF-16 的Btye数组 byte[] bytes = Encoding.Unicode.GetBytes(strSource); for (int i = 0; i &lt; bytes.Length; i += 2) &#123; //根据Unicode规则，每两个byte表示一个汉字，并且后前顺序，英文前面补00 stringBuilder.AppendFormat("\\u&#123;0&#125;&#123;1&#125;", bytes[i + 1].ToString("x").PadLeft(2, '0'), bytes[i].ToString("x").PadLeft(2, '0')); &#125; //去掉'?'的Unicode码,?=003f,Unicode以\u开头,\\为转义\ return stringBuilder.Replace("\\ufeff", string.Empty).ToString();&#125;/// &lt;summary&gt;/// Unicode转String/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;数据源&lt;/param&gt;/// &lt;returns&gt;String类型编码字符&lt;/returns&gt;public static string UnicodeToString(string strSource)&#123; return new Regex(@"\\u([0-9A-F]&#123;4&#125;)", RegexOptions.IgnoreCase | RegexOptions.Compiled).Replace(strSource, x =&gt; string.Empty + Convert.ToChar(Convert.ToUInt16(x.Result("$1"), 16)));&#125; 字段类型转换由于每种数据库字段类型及字段长度和主键不一致，根据每种目标数据库做单独修改代码过长，请查阅目录下方法 TypeProcessing]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>ado.net</tag>
        <tag>sql server</tag>
        <tag>oracle</tag>
        <tag>mysql</tag>
        <tag>access</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/S端开发基础框架]]></title>
    <url>%2Fblog%2F2016%2F12%2F20%2Fcsharp-DevFramework%2F</url>
    <content type="text"><![CDATA[基于 Wpf + Prism + DevExpress 制作的插件式开发基础框架工作已经临近半年了，日常在工作中有所积累，打算写一套自己的帮助类，后逐步发展为一个桌面端快速开发的框架。使用 Wpf + Prism + DevExpress 作为基础，Ribbon样式的插件式开发方式。同时又基于帮助类实现了几个简单的功能，后续再博客中会逐步记录帮助类。 注册工具获取计算机硬件信息（网卡MAC地址、CPU-ID、硬盘序列号、内存序列号、主板序列号、BIOS序列号、显卡信息），拼接加密生成唯一序列号，可用于软件激活使用。详细请查阅：电脑硬件信息帮助类 生成二维码基于 ZXing.QrCode 库制作的横条码、二维码生成工具，可添加LOGO，也可动态识别横条码、二维码。详细请查阅：二维码帮助类 加密解密工具提供几种对称密钥加密与非对称加密算法，以及哈希算法，也可以加密文件夹。详细请查阅：加密解密帮助类 文件共享通过调用Windows API接口实现文件共享可视化操作（需管理员权限）。详细请查阅：文件共享帮助类 数据库转换工具工作中大量需要多种不同数据格式互相转换，通过ADO.NET实现可视化数据转换工具，目前支持关系型数据库SqlServer、Oracle、MySql、Access、SQLite。详细请查阅：ADO.NET 帮助类]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>wpf</tag>
        <tag>devexpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# Reflection(反射)]]></title>
    <url>%2Fblog%2F2016%2F12%2F10%2Fcsharp-Reflection%2F</url>
    <content type="text"><![CDATA[通过反射动态调用方法 简介System.Reflection 命名空间包含通过检查托管代码中程序集、模块、成员、参数和其他实体的元数据来检索其相关信息的类型。 这些类型还可用于操作加载类型的实例，例如挂钩事件或调用方法。↑上边是微软 MSDN 的介绍，balabala一大堆…，总之反射调用它就对了，通过类库类名以及方法名称调用方法。 使用通过反射运行方法调用方法代码12345678910111213141516171819202122232425262728/// &lt;summary&gt;/// 运行方法/// &lt;/summary&gt;/// &lt;param name="strLibraryName"&gt;库名&lt;/param&gt;/// &lt;param name="strClassName"&gt;类名(带路径)&lt;/param&gt;/// &lt;param name="strMethodName"&gt;方法名&lt;/param&gt;/// &lt;param name="parameters"&gt;参数&lt;/param&gt;/// &lt;returns&gt;返回结果&lt;/returns&gt;public static object RunMethod(string strLibraryName, string strClassName, string strMethodName, object[] parameters)&#123; try &#123; Type type = Type.GetType($"&#123;strLibraryName&#125;.&#123;strClassName&#125;"); if (type != null) &#123; var vMethod = type.GetMethod(strMethodName); if (vMethod != null) &#123; return vMethod.Invoke(Activator.CreateInstance(type), parameters); &#125; &#125; return null; &#125; catch (Exception) &#123; return null; &#125;&#125; 调用方法示例12var parameters = new object[] &#123; item &#125;;RunMethod("ReflectionProject_Test", "ClassName", "MethodName", parameters); 通过反射接口插件式开发定义接口1234567891011121314151617181920/// &lt;summary&gt;/// 菜单插件接口/// &lt;/summary&gt;public interface MenuPluginInterface&#123; /// &lt;summary&gt; /// 菜单单击事件 /// &lt;/summary&gt; void Click(); /// &lt;summary&gt; /// 功能名称 /// &lt;/summary&gt; string strFunctionName &#123; get; &#125; /// &lt;summary&gt; /// 功能分组 /// &lt;/summary&gt; string strFunctionGroup &#123; get; &#125;&#125; 插件继承接口1234567891011121314151617181920212223242526272829/// &lt;summary&gt;/// 功能按钮测试Command/// &lt;/summary&gt;public class TestCommand : MenuPluginInterface&#123; /// &lt;summary&gt; /// Click Command /// &lt;/summary&gt; public void Click() &#123; // 打开插件功能 &#125; /// &lt;summary&gt; /// 功能名称 /// &lt;/summary&gt; public string strFunctionName &#123; get &#123; return "测试功能"; &#125; &#125; /// &lt;summary&gt; /// 功能分组 /// &lt;/summary&gt; public string strFunctionGroup &#123; get &#123; return "测试分组"; &#125; &#125;&#125; 反射方法1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt;/// 运行插件窗体/// &lt;/summary&gt;/// &lt;param name="strDllPath"&gt;Dll路径&lt;/param&gt;/// &lt;param name="strClassName"&gt;全类名&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool RunPluginClick(string strDllPath, string strClassName)&#123; try &#123; //反射获得Class Type Assembly assembly = Assembly.LoadFrom(strDllPath); Type type = assembly.GetType(strClassName); if (type != null) &#123; var container = new UnityContainer(); container.RegisterType&lt;MenuPluginInterface&gt;(new ContainerControlledLifetimeManager()); container.RegisterType(typeof(MenuPluginInterface), type); var manager = container.Resolve&lt;MenuPluginInterface&gt;(); manager.Click(); return true; &#125; else &#123; return false; &#125; &#125; catch (Exception) &#123; return false; &#125;&#125; 通过反射打开插件12string strProjectDll = "ReflectionProject_Test.dll";RunPluginClick(strProjectDll, "ReflectionProject_Test.TestCommand");]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>reflection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令启动程序]]></title>
    <url>%2Fblog%2F2016%2F08%2F10%2Fsystem-QueryCmd%2F</url>
    <content type="text"><![CDATA[通过运行或CMD命令启动软件 简介作为一个强迫症来说，电脑桌面当然是越精简越好，杂乱的文件不能有，甚至想干掉所有图标…Windows的强大足以完全用快捷键操作系统了，鼠标用得少了效率也提高不少。之前有想过用 Mac OS 的 Dock 的工具栏样式显示软件图标，但是没有MAC总觉得少点什么。通过 运行（Win+R） 的方式启动软件或许是个不错的方式，系统有集成很多自带的软件或者安装打包有环境变量的软件都可以输入名称运行（例如：calc、notepad、mspaint、mstsc）。 设置创建启动目录，存放想要启动的快捷图标，修改快捷方式启动的名称 配置环境变量（在环境变量Path下增加启动目录）Win7 Win10 通过 Win+R 打开运行窗口，输入启动名称即可。例：运行PS 2019年7月16日补充记录一个更好的替代或是搭配使用的工具Wox：官方网站（An effective launcher for windows）GitHub：https://github.com/Wox-launcher/Wox]]></content>
      <categories>
        <category>System</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑挂机锁]]></title>
    <url>%2Fblog%2F2016%2F05%2F31%2Fcsharp-DesktopLock%2F</url>
    <content type="text"><![CDATA[初学C#开发，Windows平台电脑挂机锁项目介绍：大学临毕业前想要做出点成品，漂洋过海跑到北京作为面试的资本。没有什么好点子，是一个同学的主意，本着学习的目的，还是比较实用的功能（没人会用的…）就做这个了。曾经一度认为只有桌面端软件才叫软件，奈何学校教学只有基础的语法还有偏向于WEB开发，有试过用java的awt和swing设计图形化界面，但是效果并不是很理想，后来有了解到微软平台MFC、QT、Winform,但是界面的画风显得很古老，使用异形窗体后会有很严重的锯齿，最后选用WPF作为主界面。项目开源地址：https://github.com/Sadness96/DesktopLock贴吧发布地址：http://tieba.baidu.com/p/4584097900项目虽然简单，BUG还有很多，甚至不如Windows自带的Win+L锁屏好使，但是经过几天的边学边做，真的给我明确了未来的方向。 设置菜单界面可通过三种方式设置挂机锁，1.密码解锁；2.时间解锁（根据系统当前时间拼接作为密码）；3.U盘解锁（通过写入加密数据到U盘，插入U盘时即可解锁）； 修改锁屏壁纸默认三种锁屏图片可选或自定义图片。 定时锁屏关机界面可定时多长时间后锁屏或关机。 USB写入密码插入U盘后写入加密秘钥，可通过设置U盘解锁方式，在插入U盘后系统自动解锁。 关于 锁屏可调节透明度，挂机时显示桌面运行的程序。]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>wpf</tag>
        <tag>ini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈尔滨信息工程学院]]></title>
    <url>%2Fblog%2F2016%2F05%2F10%2Fschool-University%2F</url>
    <content type="text"><![CDATA[选择不同，命运自然不同我不喜欢这个学校，因为在我来这之前，就已经发生了很多让人厌恶的故事。但是我还是来了，人生总要伴随着痛苦嘛。接受了，就是成长。但是我也很感谢这里，让我拥有两年的时间，得到足够成长，一切都按照计划进行着，下一步…等发生了再去记录吧！ 记录做过的成品，真正成长的开始：c（企业员工信息管理系统）使用C语言编写简易的控制台管理程序，实训有录像剪辑视频（使用会声会影）。由于涉及到她人肖像问题，不方便发布，感兴趣可以单独联系博主。插曲：制作视频的时候很赶工，几个小女生视频录一半着急忙慌就回家放假了，我带着朋友跑网吧通宵剪辑视频，他玩着联盟看我剪了一宿…然后在最后渲染的时候已经凌晨五点了，非常幸运的死机了，我凭着记忆快速重启电脑，安装好软件后重新剪辑，在通宵下机之前完成了。 java（学生成绩管理系统）使用Java的awt和swing设计开发C/S端程序，使用SQL Server数据库管理，exe4j打包为exe程序。]]></content>
      <categories>
        <category>School</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>java</tag>
        <tag>会声会影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[齐齐哈尔职业教育中心学校]]></title>
    <url>%2Fblog%2F2014%2F10%2F05%2Fschool-HighSchool%2F</url>
    <content type="text"><![CDATA[曾经不被人认可的小孩，自己选择了职高我在入学的第一天，校门前的滚动屏写着：“恭喜XXX同学考入天津大学，欢迎来到职业教育中心学校，不走高考独木桥。”在很多人眼里职高或技校很乱，学习不好的人考不到高中的人才会去这里学一门手艺。对！也不对！在这里，我认识的大部分人没有一个安逸的家，每个人在这里都在为自己的未来打拼。职高真的就不如普通的高中么？（过多个人言论，博主眼界有限，并不符合所有人情况）初中临近毕业的时候，我和一个好朋友选择了去职高，而另外几个同学被家里强制安排在普通高中里，我为了所谓的理想选择计算机专业（在2011年的时候很盛行说网瘾少年）我的好朋友选择了学汽修，几年过去了，高考终究又是一个坎，普通高中的同学们毕业选了专科或是三本，专业嘛，汽修、模具制造等等等…然而我和我的好朋友已经学了这个专业三年，我们跟去学汽修的同学说发动机原理，他听不懂。我跟模具制造的同学说AutoCAD他听不懂…大学终究要选择一个专业方向，普通高中真的会更好么？如果以上说的是一些学习较差的朋友，博主还有认识学习非常好考到重点高中的朋友，在临高考时迷茫了，似乎上学只是为了应付考试，不知道自己的定位，不知道应该考什么专业，有人通过我的建议找到了自己的目标，而有些人也盲目的听从了家里的安排。希望所有迷茫的人，终究能找到属于自己的位置。 在此记录曾经做过的，即是幼稚的回忆，又代表了成长：photoshop flash移动端浏览器和部分浏览器已不支持Flash播放访问速度慢或网页不兼容可能导致无法访问，可单独下载储存地址：https://github.com/Sadness96/sadness96.github.io/tree/master/flash/memory-HighSchool]]></content>
      <categories>
        <category>School</category>
      </categories>
      <tags>
        <tag>photoshop</tag>
        <tag>flash</tag>
      </tags>
  </entry>
</search>
