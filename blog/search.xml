<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[迁移博客至 GitHub Pages + Hexo]]></title>
    <url>%2Fblog%2F2019%2F06%2F18%2Fblog-TransferHexo%2F</url>
    <content type="text"><![CDATA[简介原来只有使用 WordPress 记录一部分博客，以及平时有随手记录工作生活的习惯，这次迁移博客统一整理一遍。 技术简介博客主体使用 GitHub Pages 作为静态网站托管平台，使用 Hexo 作为静态博客生成框架，以及使用 theme-next 主题。 开发环境VSCode + Node.js + Hexo + Python + GIT 搭建创建 GitHub PagesGitHub 仓库创建与用户名同名的 “.github.io” 库要求：名称必须为小写字母或数字例：Github 用户名为：Test；则创建库为：test.github.io库地址即为：https://github.com/Test/test.github.iogit地址为：https://github.com/Test/test.github.io.gitPages访问地址为：https://test.github.io设置网站为HTTPS：库 Settings 中勾选：Enforce HTTPS 域名配置在阿里云中购买域名（例：test.com）后需实名认证安全设置中设置禁止转移锁、禁止更新锁设置域名解析：新增两条记录1、记录类型：CNAME；主机记录：www；解析线路：默认；记录值：test.github.io；TTL：10分钟；2、记录类型：CNAME；主机记录：@；解析线路：默认；记录值：test.github.io；TTL：10分钟；即可跳转为 test.github.io 地址设置打开网站为域名地址：GitHub 库中新增 CNAME 文件 保存内容为域名地址（例：test.com）Settings 中显示 “Your site is published at https://test.com/ “ 即可 目录结构 目录文件夹或文件 作用及功能 blog 用于发布的静态博客 flash 网页中加载的Flash文件 hexoblog Hexo 编译博客源码 images 网页中加载的图片文件 resume 简历页面 .nojekyll 关闭jekyll检查 404.html 网站404页面 CNAME 设置Pages解析域名地址 README.md 自述文件 index.html 博客主界面 修改主题样式仅展示代码样式部分，主题配置文件请查阅官网 theme-next修改文件路径：hexoblog/themes/next/source/css/_custom/custom.styl1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// Custom styles.// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 20px; padding: 10px; background: #FFF; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125;.content-wrap &#123; background: transparent;&#125;.footer &#123; padding: 0px; padding-bottom: 20px;&#125;// 主页文章内间距.content-wrap &#123; padding: 0px;&#125;.posts-expand &#123; padding-top: 0px;&#125;// 超链接颜色.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125;// 主页文章块缩进.posts-expand .post-eof &#123; margin: 30px auto 10px; width: 0px; height: 0px;&#125;.posts-expand .post-meta &#123; margin: 3px 0 30px 0;&#125;.posts-expand .post-body img &#123; margin: 0px auto 0px;&#125;.post-button &#123; margin-top: 30px;&#125;// 底部页码格式.pagination &#123; margin: 40px 0 30px; border-top: 0px;&#125; 遇到的问题使用VSCode开发时生成静态页不加载CSS样式插件：View In Browser 本地网页打开插件：Live Server 启动一个服务打开网站 上传Hexo博客源码后报错：Date is not a valid datetime由于GitHub Pages默认使用jekyll作为代码检查，在上传Hexo源码之后存在编译不通过的情况，所以需要创建.nojekyll空文件在Repository的根目录下以关闭针对jekyll的检查。Windows下创建以“.”开头文件夹和文件（执行命令）：12md .folder //创建文件夹echo &gt;.file //创建文件 Hexo生成静态博客存在大量空白行请查看文章：压缩Hexo博客生成空白行 执行命令123456789101112cd hexoblog //进入博客源码文件夹hexo new &lt;title&gt; //创建新文章hexo clean //清理博客生成文件hexo generate //生成博客静文件hexo server //启动博客服务测试内容python compress.py //压缩Hexo生成空白行python deploy.py //拷贝至上级 "../blog" 发布目录cd .. //回到上级 "../" 目录git status //对比差异文件git add . //添加修改至缓存区git commit -m "Message" //填写修改内容git push //提交修改]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>python</tag>
        <tag>cmd</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[压缩Hexo博客生成空白行]]></title>
    <url>%2Fblog%2F2019%2F06%2F17%2Fpython-CompressHexo%2F</url>
    <content type="text"><![CDATA[解决Hexo博客系统生成导致大量空白行问题，生成文件拷贝到外部目录问题 删除Hexo博客系统生成文件大量空白行自动遍历目录下所有html文件，创建临时文件，把非空格行拷贝，最后在重命名文件恢复生成博客文章后执行命令：python compress.py 即可1234567891011121314151617181920212223242526272829import reimport osdef minify_html(filename): with open(filename, 'r', encoding='utf-8') as p: with open(filename+'.tmp', 'w', encoding='utf-8') as t: while True: l = p.readline() if not l: break else: if re.search(r'\S', l): t.write(l) os.remove(filename) os.rename(filename+'.tmp', filename) print('%s 已压缩！' % filename)def yasuo(dir_path): if dir_path[len(dir_path)-1] == '/': dir_path = dir_path[:len(dir_path)-1] file_list = os.listdir(dir_path) for i in file_list: if i.find('html') &gt; 0: minify_html(dir_path+'/'+i) elif os.path.isdir(dir_path+'/'+i) and not re.match(r'\.|\_', i): yasuo("%s/%s" % (dir_path, i))# dir_path：压缩相对路径yasuo('public') 拷贝Hexo博客系统public目录当前系统Hexo博客源码在 /hexoblog 目录下（该目录不被上传），将生成文件自动拷贝至上层目录 /blog 下生成博客文章后执行命令：python deploy.py 即可123456789101112131415161718192021import osimport shutildef deploy(dir_path, dir_copy): dirpath = r'%s\%s' % (os.path.dirname( os.path.realpath(__file__)), dir_path) dircopy = r'%s\%s' % (os.path.abspath( os.path.dirname(os.getcwd())), dir_copy) print('dirpath：%s', dirpath) print('dircopy：%s', dircopy) # 删除文件夹 if os.path.exists(dircopy): shutil.rmtree(dircopy) print('删除文件夹成功！') # 拷贝文件夹 shutil.copytree(dirpath, dircopy) print('拷贝文件夹成功！')# 生成博客相对路径# 拷贝上级目录相对路径deploy('public', 'blog')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科盾科技股份有限公司]]></title>
    <url>%2Fblog%2F2019%2F06%2F12%2Fwork-KedunTech%2F</url>
    <content type="text"><![CDATA[人像识别重建系统 个人简介2018年07月12日 - 2019年08月09日 就职于 科盾科技股份有限公司 软件研发工程师岗位。 公司简介科盾科技股份有限公司 成立于1999年，公司总部和研发中心位于北京中关村，试验验证展示基地在昌平区，生产基地在山东莱阳，在济南、深圳、武汉和南京等地设有办事处。目前拥有员工六百余人，是国内领先的安防和夜视产品专业供应商。（股票代码：835902）。 多年来公司始终坚持以“科技引领、质量兴企、信誉第一、服务至上”为经营宗旨，长期致力于夜视光电侦测、无线自组网通信、智能无人机、智能安防监控、大数据云服务、智能芯片、新能源、新材料等产品的研发、生产、销售和服务，成功掌握了数字图像处理、智能图像融合等关键核心技术，拥有一批品牌自主、技术原创的拳头产品，先后获得近百项国家专利。 公司拥有完备齐全的生产检测设备，采用标准化、集团化、精细化管理运营模式，拥有主被动相融合技术的夜视设备产业化基地，可为国家大安防建设提供整体解决方案。 公司秉承技术与人才共同发展的理念，紧盯世界科技前沿，紧跟国内外市场需求，专心致力于产品研发与创新，吸引培养了一大批优秀科研人才，成立了院士工作站，并与国内多家科研院所联合成立了研发中心，与法国ULIS公司建立了密切战略合作伙伴关系。 “科技铸造利剑，质量捍卫盾牌”。公司将进一步加大投入、完善制度，加强人才队伍建设，研发生产更多更优质的产品服务社会。 项目介绍（由于签署保密协议，仅介绍大致工作内容）人像识别重建系统，主要用于公安部门使用，当前视频监控得到了迅速发展。视频监控普遍存在的问题是：人脸图像分辨率低下。对于低分辨率的人脸图像，需要清晰化目标人的人脸图像和确定监控中目标人的真实身份，以便于公安部门提高破案率。现模拟画像破案率提高30% 指纹提高破案率10%。以及对于寻找失踪人口及儿童得到极大帮助！ 声明该项目为：第八届国际警用装备及反恐技术装备展览会 展出产品，功能及介绍均为宣传内容，如有兴趣请联系科盾科技股份有限公司。 项目背景该项目由清华大学 苏光大 教授多项国家发明专利为基础研发。主要使用技术有 OpenCV、深度学习、DNN（深度神经网络）、Caffe（卷积神经网络框架） 构成。1、基于人脸几何尺寸归一化的人脸图像识别方法，2007年获国家发明专利（发明专利号：ZL 2005 1 0067692.X，发明人：苏光大，孟凯，杜成，王俊艳）；2、一种人脸图像采集设备属性归一化的方法，2006年获得国家发明专利（发明专利号：ZL 2004 1 0047919.2，发明人：苏光大，章柏幸）；3、基于部件主分量分析的多模式人脸识别方法，2004年获得国家发明专利（发明专利号：ZL 01 1 36577.3，发明人：苏光大，张翠平）；4、录像带中模糊文字、模糊人像的复原方法，2004年获得国家发明专利（发明专利号：ZL 01 1 31098.7，发明人：苏光大）；5、实现邻域图像并行存取的方法及邻域图像帧存储体，2000年获得国家发明专利（发明专利号：ZL 97 1 12577.5，发明人：苏光大，左永荣）。 参与内容在该项目中负责完整的架构设计、系统原型设计（Axure RP）、系统流程设计（Visio）、系统UI设计（Photoshop、Illustrator）、编码开发（不包含算法部分）。 设计概要系统现由服务端与客户端组成：服务端采用 ASP.NET MVC，后转 .NET Core 框架。客户端采用 WPF MVVM、Prism、NSIS 架构；其他技术使用：数据库：MySQL高速缓存：Redis消息队列：RabbitMQ 重建流程 功能介绍超分辨率重建使监控拍摄到的模糊人像通过算法优化重建出意向人脸，增加案件破获概率。1、加载监控拍摄到的图像（正脸角度60以内）2、归一化图像480*360（自动处理）；调整直方图均衡及噪点；超分辨率重建 人脸识别使超分辨率重建得到的意向人脸或清晰人脸照片匹配数据库中相似的人像数据，从而排查可疑人员。 模拟画像通过人脸识别到的人像自由添加替换五官部件、调整，达到更趋向于犯罪嫌疑人的画像。]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>asp</tag>
        <tag>c++</tag>
        <tag>c#</tag>
        <tag>mysql</tag>
        <tag>axure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[调用神思二代身份证读卡器]]></title>
    <url>%2Fblog%2F2019%2F04%2F06%2Fcpp-Sdses%2F</url>
    <content type="text"><![CDATA[基于神思二代身份证读卡器做二次开发 简介公司中项目人证合一核查系统需要，使用神思二代身份证读卡器二次开发集成。由于神思二代证SKD只提供了C++/Java接口，项目还是采用C#作为主要开发语言，使用WPF开发界面，所以采用 C#/C++ 混合编程 的方式开发。 封装代码由官方提供的C++SDK二次封装为非托管动态链接库暴露接口给C#端调用读卡器读取身份证照片存为 RdCard.dll 库目录下 zp.bmp 文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include "stdafx.h"#include "2ndCardReader.h"// 主符号#include "resource.h"#include "Ucmd.h"#include &lt;fstream&gt;#include &lt;atlimage.h&gt;#pragma warning(disable:4996)using namespace std;typedef unsigned char BYTE;typedef unsigned short WORD;typedef unsigned long DWORD;typedef long LONG;//位图文件头文件定义typedef struct&#123; DWORD bfSize; //文件大小 WORD bfReserved1; //保留字 WORD bfReserved2; //保留字 DWORD bfOffBits; //实际位图数据偏移字节数=前三个部分长度之和&#125;ClBITMAPHEADER;//信息头BITMAPINFOHEADERtypedef struct&#123; DWORD biSize; //指定此结构体长度40 LONG biWidth; LONG biHeight; WORD biPlanes; //平面数 为1 WORD biBitCount; //采用颜色位数 DWORD biCompression; //压缩方式 DWORD biSizeImage; //实际位图占用字节数 LONG biXPelsPerMeter; //x方向分辨率 LONG biYPelsPerMeter; //y方向分辨率 DWORD biClrUsed; //使用的颜色数 DWORD biClrImportant; //重要的颜色数&#125;ClBITMAPINFOHEADER;typedef struct&#123; unsigned char rgbBlue; unsigned char rgbGreen; unsigned char rgbRed; unsigned char rgbReserved;&#125;ClRGBQUAD;typedef int(__stdcall *_UCommand1)(unsigned char* pCmd, int* parg0, int* parg1, int* parg2);typedef int(__stdcall *_GetAddr)(char* pbuf);typedef int(__stdcall *_GetBegin)(char* pbuf);typedef int(__stdcall *_GetName)(char* pbuf);typedef int(__stdcall *_GetSex)(char* pbuf);typedef int(__stdcall *_GetSexGB)(char* pbuf);typedef int(__stdcall *_GetFolk)(char* pbuf);typedef int(__stdcall *_GetFolkGB)(char* pbuf);typedef int(__stdcall *_GetIDNum)(char* pbuf);typedef int(__stdcall *_GetDep)(char* pbuf);typedef int(__stdcall *_GetBirth)(char* pbuf);typedef int(__stdcall *_GetEnd)(char* pbuf);typedef int(__stdcall *_GetNewAddr)(char* pbuf);typedef int(__stdcall *_FID_GetEnName)(char* pbuf);typedef int(__stdcall *_FID_GetSex)(char* pbuf);typedef int(__stdcall *_FID_GetSexGB)(char* pbuf);typedef int(__stdcall *_FID_GetIDNum)(char* pbuf);typedef int(__stdcall *_FID_GetNationality)(char* pbuf);typedef int(__stdcall *_FID_GetChNationality)(char* pbuf);typedef int(__stdcall *_FID_GetChName)(char* pbuf);typedef int(__stdcall *_FID_GetBegin)(char* pbuf);typedef int(__stdcall *_FID_GetEnd)(char* pbuf);typedef int(__stdcall *_FID_GetBirth)(char* pbuf);typedef int(__stdcall *_FID_GetVersion)(char* pbuf);typedef int(__stdcall *_FID_GetDep)(char* pbuf);typedef int(__stdcall *_GetSAMIDToStr)(char* id);_UCommand1 UCommand1;_GetAddr GetAddr;_GetBegin GetBegin;_GetName GetName;_GetSex GetSex;_GetSexGB GetSexGB;_GetFolk GetFolk;_GetFolkGB GetFolkGB;_GetIDNum GetIDNum;_GetDep GetDep;_GetBirth GetBirth;_GetEnd GetEnd;_GetNewAddr GetNewAddr;_FID_GetEnName FID_GetEnName;_FID_GetSex FID_GetSex;_FID_GetSexGB FID_GetSexGB;_FID_GetIDNum FID_GetIDNum;_FID_GetNationality FID_GetNationality;_FID_GetChNationality FID_GetChNationality;_FID_GetChName FID_GetChName;_FID_GetBegin FID_GetBegin;_FID_GetEnd FID_GetEnd;_FID_GetBirth FID_GetBirth;_FID_GetVersion FID_GetVersion;_FID_GetDep FID_GetDep;_GetSAMIDToStr GetSAMIDToStr;extern "C" char* TrimStr(char *str)&#123; char *head = str; while (*head == ' ') &#123; ++head; &#125; char *end = head + strlen(head) - 1; while (*end == ' ') &#123; --end; &#125; *(end + 1) = 0; strcpy(str, head); return str;&#125;extern "C" MY2NDCARDREADER_API int fn2ndCardReaderInfo(IDInfo* pIDInfo)&#123; int i = LoadDll(); if (i != 1) &#123; return -10; &#125; HINSTANCE hDll = LoadLibraryEx(L"RdCard.dll", 0, LOAD_WITH_ALTERED_SEARCH_PATH); if (hDll == NULL) &#123; return -10; &#125; UCommand1 = (_UCommand1)GetProcAddress(hDll, "UCommand1"); GetAddr = (_GetAddr)GetProcAddress(hDll, "GetAddr"); GetBegin = (_GetBegin)GetProcAddress(hDll, "GetBegin"); GetName = (_GetName)GetProcAddress(hDll, "GetName"); GetSex = (_GetSex)GetProcAddress(hDll, "GetSex"); GetSexGB = (_GetSexGB)GetProcAddress(hDll, "GetSexGB"); GetFolk = (_GetFolk)GetProcAddress(hDll, "GetFolk"); GetFolkGB = (_GetFolkGB)GetProcAddress(hDll, "GetFolkGB"); GetIDNum = (_GetIDNum)GetProcAddress(hDll, "GetIDNum"); GetDep = (_GetDep)GetProcAddress(hDll, "GetDep"); GetBirth = (_GetBirth)GetProcAddress(hDll, "GetBirth"); GetEnd = (_GetEnd)GetProcAddress(hDll, "GetEnd"); GetNewAddr = (_GetNewAddr)GetProcAddress(hDll, "GetNewAddr"); FID_GetEnName = (_FID_GetEnName)GetProcAddress(hDll, "FID_GetEnName"); FID_GetSex = (_FID_GetSex)GetProcAddress(hDll, "FID_GetSex"); FID_GetSexGB = (_FID_GetSexGB)GetProcAddress(hDll, "FID_GetSexGB"); FID_GetIDNum = (_FID_GetIDNum)GetProcAddress(hDll, "FID_GetIDNum"); FID_GetNationality = (_FID_GetNationality)GetProcAddress(hDll, "FID_GetNationality"); FID_GetChNationality = (_FID_GetChNationality)GetProcAddress(hDll, "FID_GetChNationality"); FID_GetChName = (_FID_GetChName)GetProcAddress(hDll, "FID_GetChName"); FID_GetBegin = (_FID_GetBegin)GetProcAddress(hDll, "FID_GetBegin"); FID_GetEnd = (_FID_GetEnd)GetProcAddress(hDll, "FID_GetEnd"); FID_GetBirth = (_FID_GetBirth)GetProcAddress(hDll, "FID_GetBirth"); FID_GetVersion = (_FID_GetVersion)GetProcAddress(hDll, "FID_GetVersion"); FID_GetDep = (_FID_GetDep)GetProcAddress(hDll, "FID_GetDep"); GetSAMIDToStr = (_GetSAMIDToStr)GetProcAddress(hDll, "GetSAMIDToStr"); if (UCommand1 == NULL || GetAddr == NULL || GetBegin == NULL || GetName == NULL || GetSex == NULL || GetSexGB == NULL || GetFolk == NULL || GetFolkGB == NULL || GetIDNum == NULL || GetDep == NULL || GetBirth == NULL || GetEnd == NULL || GetNewAddr == NULL || FID_GetEnName == NULL || FID_GetSex == NULL || FID_GetSexGB == NULL || FID_GetIDNum == NULL || FID_GetNationality == NULL || FID_GetChNationality == NULL || FID_GetChName == NULL || FID_GetBegin == NULL || FID_GetEnd == NULL || FID_GetBirth == NULL || FID_GetVersion == NULL || FID_GetDep == NULL || GetSAMIDToStr == NULL) &#123; return FALSE; &#125; //连接设备 unsigned char cmd = 0x41; int para0 = 0, para1 = 8811, para2 = 9986; int ret = UCommand1(&amp;cmd, &amp;para0, &amp;para1, &amp;para2); if (ret != 62171) &#123; //MessageBox("设备连接失败，请检查设备是否插好！"); return -11; &#125; //验证卡（寻卡） cmd = 0x43; ret = UCommand1(&amp;cmd, &amp;para0, &amp;para1, &amp;para2); //读卡 cmd = 0x49; ret = UCommand1(&amp;cmd, &amp;para0, &amp;para1, &amp;para2); if (ret != 62171) &#123; //MessageBox("读卡失败！"); return -12; &#125; GetAddr = (_GetAddr)GetProcAddress(hDll, "GetAddr"); GetName = (_GetName)GetProcAddress(hDll, "GetName"); GetSex = (_GetSex)GetProcAddress(hDll, "GetSex"); GetFolk = (_GetFolkGB)GetProcAddress(hDll, "GetFolkGB"); GetIDNum = (_GetIDNum)GetProcAddress(hDll, "GetIDNum"); GetBegin = (_GetBegin)GetProcAddress(hDll, "GetBegin"); GetEnd = (_GetEnd)GetProcAddress(hDll, "GetEnd"); GetDep = (_GetDep)GetProcAddress(hDll, "GetDep"); if (GetAddr == NULL || GetName == NULL || GetSex == NULL || GetFolk == NULL || GetIDNum == NULL || GetBegin == NULL || GetDep == NULL || GetEnd == NULL) &#123; return -22; &#125; GetName(pIDInfo-&gt;Name); TrimStr(pIDInfo-&gt;Name); GetSexGB(pIDInfo-&gt;Gender); GetBirth(pIDInfo-&gt;BirthDate); GetAddr(pIDInfo-&gt;Address); TrimStr(pIDInfo-&gt;Address); GetIDNum(pIDInfo-&gt;IDNumber); GetBegin(pIDInfo-&gt;Begin); GetEnd(pIDInfo-&gt;End); GetFolk(pIDInfo-&gt;Folk); GetDep(pIDInfo-&gt;IssuanceAuthority); pIDInfo-&gt;Nation = "中国"; //关闭读卡器 cmd = 0x42; UCommand1(&amp;cmd, &amp;para0, &amp;para1, &amp;para2); FreeDll(); return 1;&#125; 调用代码12[DllImport(@"2ndCardReader.dll", EntryPoint = "fn2ndCardReaderInfo", CallingConvention = CallingConvention.Cdecl)]public static extern int fn2ndCardReaderInfo(ref IDInfo pIDInfo); 12345678910111213141516 [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Ansi, Pack = 1)]public struct IDInfo&#123; //二代证信息 public IntPtr Name; public IntPtr Gender; public IntPtr Folk; public IntPtr Nation; public IntPtr BirthDate; public IntPtr Address; public IntPtr IDNumber; public IntPtr IssuanceAuthority; public IntPtr Begin; public IntPtr End; public IntPtr Image;&#125; 12345678910111213141516171819202122232425IDInfo pIDInfo = new IDInfo();pIDInfo.Name = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Gender = Marshal.StringToHGlobalAnsi("");pIDInfo.Nation = Marshal.StringToHGlobalAnsi(" ");pIDInfo.BirthDate = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Address = Marshal.StringToHGlobalAnsi(" ");pIDInfo.IDNumber = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Image = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Begin= Marshal.StringToHGlobalAnsi(" ");pIDInfo.End = Marshal.StringToHGlobalAnsi(" ");pIDInfo.Folk = Marshal.StringToHGlobalAnsi(" ");pIDInfo.IssuanceAuthority = Marshal.StringToHGlobalAnsi(" ");int i = fn2ndCardReaderInfo(ref pIDInfo);string Name = Marshal.PtrToStringAnsi(pIDInfo.Name);string Gender = Marshal.PtrToStringAnsi(pIDInfo.Gender);string Nation = Marshal.PtrToStringAnsi(pIDInfo.Nation);string BirthDate = Marshal.PtrToStringAnsi(pIDInfo.BirthDate);string Address = Marshal.PtrToStringAnsi(pIDInfo.Address);string IDNumber = Marshal.PtrToStringAnsi(pIDInfo.IDNumber);string IssuanceAuthority = Marshal.PtrToStringAnsi(pIDInfo.IssuanceAuthority);string Begin = Marshal.PtrToStringAnsi(pIDInfo.Begin);string End = Marshal.PtrToStringAnsi(pIDInfo.End);string Folk = Marshal.PtrToStringAnsi(pIDInfo.Folk);&#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c#</tag>
        <tag>sdses</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Asp服务端文件下载]]></title>
    <url>%2Fblog%2F2019%2F03%2F11%2Fasp-DownloadFile%2F</url>
    <content type="text"><![CDATA[服务端提供网页点击下载功能，或 WebApi 接口提供软件更新下载服务 继承 Controller 接口的控制器方法下载方式使用环境：网页端按钮点击下载按钮脚本链接进入这个方法之后，服务端直接生成文件，浏览器自动下载 1234567891011121314151617181920212223242526272829303132/// &lt;summary&gt;/// 下载文件/// &lt;/summary&gt;/// &lt;returns&gt;是否下载成功&lt;/returns&gt;public ActionResult DownLoadFile()&#123; string filePath = "服务端文件路径（程序自动获取路径或根据传入参数判断文件路径）"; FileInfo fileInfo = new FileInfo(filePath); if (fileInfo.Exists) &#123; Response.Clear(); Response.ClearContent(); Response.ClearHeaders(); Response.Buffer = true; Response.AddHeader("Content-Disposition", "attachment;filename=" + Server.UrlEncode(fileInfo.Name)); Response.AddHeader("Content-Length", fileInfo.Length.ToString()); Response.AddHeader("Content-Transfer-Encoding", "binary"); Response.ContentType = "application/x-msdownload"; Response.ContentEncoding = System.Text.Encoding.GetEncoding("gb2312"); Response.WriteFile(fileInfo.FullName); Response.Flush(); Response.End(); return Json(true); &#125; else &#123; return Json(false); &#125;&#125; 继承 ApiController 接口的 WebApi 方法下载方式使用环境：桌面端自动更新 提交需要更新的文件名 获取下载服务端返回文件流，桌面端接收并保存到指定目录替换 12345678910/// &lt;summary&gt;/// 下载文件/// &lt;/summary&gt;/// &lt;returns&gt;文件数据流&lt;/returns&gt;[HttpGet]public byte[] DownLoadFile()&#123; string filePath = "服务端文件路径（程序自动获取路径或根据传入参数判断文件路径）"; return File.Exists(filePath) ? File.ReadAllBytes(filePath) : null;&#125;]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>asp</tag>
        <tag>download</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nsis 使用介绍]]></title>
    <url>%2Fblog%2F2018%2F11%2F24%2Fsoftware-Nsis%2F</url>
    <content type="text"><![CDATA[基于 NSIS 的 Windows 桌面端打包程序 简介现工作中作为全栈开发工程师，不光写服务端B/S也要写桌面端C/S程序，在部署B/S的时候一般是拷贝文件或自动部署到服务器，但是桌面端程序普遍是打包为安装包(Install pack)在官网提供下载或是直接发送给用户安装升级。一般由质检部门打包测试，最后没有BUG的版本发布。NSIS（Nullsoft Scriptable Install System）是一个专业的开源系统，用于创建Windows安装程序。它的设计尽可能小巧灵活，因此非常适合互联网分发。只做了一个最基础安装包程序，如需定制样式可查阅官方网站。 安装包截图 脚本代码替换脚本中 “#” 开头的部分即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233; 该脚本使用 HM VNISEdit 脚本编辑器向导产生; 安装程序初始定义常量!define PRODUCT_NAME "#系统名称"!define PRODUCT_VERSION "#系统版本"!define PRODUCT_PUBLISHER "#公司名称"!define PRODUCT_WEB_SITE "#公司官网"!define PRODUCT_DIR_REGKEY "Software\Microsoft\Windows\CurrentVersion\App Paths\#EXE名称"!define PRODUCT_UNINST_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\$&#123;PRODUCT_NAME&#125;"!define PRODUCT_UNINST_ROOT_KEY "HKLM"!define PRODUCT_STARTMENU_REGVAL "NSIS:StartMenuDir"SetCompressor lzma; ------ MUI 现代界面定义 (1.67 版本以上兼容) ------!include "MUI.nsh"; MUI 预定义常量!define MUI_ABORTWARNING!define MUI_ICON "$&#123;NSISDIR&#125;\Contrib\Graphics\Icons\modern-install.ico"!define MUI_UNICON "$&#123;NSISDIR&#125;\Contrib\Graphics\Icons\modern-uninstall.ico"; 欢迎页面!insertmacro MUI_PAGE_WELCOME; 许可协议页面!define MUI_LICENSEPAGE_CHECKBOX!insertmacro MUI_PAGE_LICENSE "许可协议.txt"; 安装目录选择页面!insertmacro MUI_PAGE_DIRECTORY; 开始菜单设置页面var ICONS_GROUP!define MUI_STARTMENUPAGE_NODISABLE!define MUI_STARTMENUPAGE_DEFAULTFOLDER "#系统名称"!define MUI_STARTMENUPAGE_REGISTRY_ROOT "$&#123;PRODUCT_UNINST_ROOT_KEY&#125;"!define MUI_STARTMENUPAGE_REGISTRY_KEY "$&#123;PRODUCT_UNINST_KEY&#125;"!define MUI_STARTMENUPAGE_REGISTRY_VALUENAME "$&#123;PRODUCT_STARTMENU_REGVAL&#125;"!insertmacro MUI_PAGE_STARTMENU Application $ICONS_GROUP; 安装过程页面!insertmacro MUI_PAGE_INSTFILES; 安装完成页面!define MUI_FINISHPAGE_RUN "$INSTDIR\#EXE名称"!insertmacro MUI_PAGE_FINISH; 安装卸载过程页面!insertmacro MUI_UNPAGE_INSTFILES; 安装界面包含的语言设置!insertmacro MUI_LANGUAGE "SimpChinese"; 安装预释放文件!insertmacro MUI_RESERVEFILE_INSTALLOPTIONS; ------ MUI 现代界面定义结束 ------Name "$&#123;PRODUCT_NAME&#125; $&#123;PRODUCT_VERSION&#125;"OutFile "#打包文件名称"InstallDir "$PROGRAMFILES\#系统名称"InstallDirRegKey HKLM "$&#123;PRODUCT_UNINST_KEY&#125;" "UninstallString"ShowInstDetails showShowUnInstDetails showSection "MainSection" SEC01 SetOutPath "$INSTDIR" SetOverwrite ifnewer File "#打包文件" File /r "#打包特定后缀 *.*" SetOverwrite off File "#打包排除特定后缀 *.*"; 创建开始菜单快捷方式 !insertmacro MUI_STARTMENU_WRITE_BEGIN Application CreateDirectory "$SMPROGRAMS\$ICONS_GROUP" CreateShortCut "$SMPROGRAMS\$ICONS_GROUP\#系统名称.lnk" "$INSTDIR\#EXE名称" CreateShortCut "$DESKTOP\人#系统名称.lnk" "$INSTDIR\KeDun.Shell.exe" !insertmacro MUI_STARTMENU_WRITE_ENDSectionEndSection -AdditionalIcons !insertmacro MUI_STARTMENU_WRITE_BEGIN Application CreateShortCut "$SMPROGRAMS\$ICONS_GROUP\Uninstall.lnk" "$INSTDIR\uninst.exe" !insertmacro MUI_STARTMENU_WRITE_ENDSectionEndSection -Post WriteUninstaller "$INSTDIR\uninst.exe" WriteRegStr HKLM "$&#123;PRODUCT_DIR_REGKEY&#125;" "" "$INSTDIR\#EXE名称" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "DisplayName" "$(^Name)" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "UninstallString" "$INSTDIR\uninst.exe" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "DisplayIcon" "$INSTDIR\KeDun.Shell.exe" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "DisplayVersion" "$&#123;PRODUCT_VERSION&#125;" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "URLInfoAbout" "$&#123;PRODUCT_WEB_SITE&#125;" WriteRegStr $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" "Publisher" "$&#123;PRODUCT_PUBLISHER&#125;"SectionEnd; 安装net45Function CheckAndDownloadDotNet45 # Let's see if the user has the .NET Framework 4.5 installed on their system or not # Remember: you need Vista SP2 or 7 SP1. It is built in to Windows 8, and not needed # In case you're wondering, running this code on Windows 8 will correctly return is_equal # or is_greater (maybe Microsoft releases .NET 4.5 SP1 for example) # Set up our Variables Var /GLOBAL dotNET45IsThere Var /GLOBAL dotNET_CMD_LINE Var /GLOBAL EXIT_CODE # We are reading a version release DWORD that Microsoft says is the documented # way to determine if .NET Framework 4.5 is installed ReadRegDWORD $dotNET45IsThere HKLM "SOFTWARE\Microsoft\NET Framework Setup\NDP\v4\Full" "Release" IntCmp $dotNET45IsThere 378389 is_equal is_less is_greater is_equal: Goto done_compare_not_needed is_greater: # Useful if, for example, Microsoft releases .NET 4.5 SP1 # We want to be able to simply skip install since it's not # needed on this system Goto done_compare_not_needed is_less: Goto done_compare_needed done_compare_needed: #.NET Framework 4.5 install is *NEEDED* # Microsoft Download Center EXE: # Web Bootstrapper: http://go.microsoft.com/fwlink/?LinkId=225704 # Full Download: http://go.microsoft.com/fwlink/?LinkId=225702 # Setup looks for components\dotNET45Full.exe relative to the install EXE location # This allows the installer to be placed on a USB stick (for computers without internet connections) # If the .NET Framework 4.5 installer is *NOT* found, Setup will connect to Microsoft's website # and download it for you # Reboot Required with these Exit Codes: # 1641 or 3010 # Command Line Switches: # /showrmui /passive /norestart # Silent Command Line Switches: # /q /norestart # Let's see if the user is doing a Silent install or not IfSilent is_quiet is_not_quiet is_quiet: StrCpy $dotNET_CMD_LINE "/q /norestart" Goto LookForLocalFile is_not_quiet: StrCpy $dotNET_CMD_LINE "/showrmui /passive /norestart" Goto LookForLocalFile LookForLocalFile: # Let's see if the user stored the Full Installer IfFileExists "$EXEPATH\components\dotNET45Full.exe" do_local_install do_network_install do_local_install: # .NET Framework found on the local disk. Use this copy ExecWait '"$EXEPATH\components\dotNET45Full.exe" $dotNET_CMD_LINE' $EXIT_CODE Goto is_reboot_requested # Now, let's Download the .NET do_network_install: Var /GLOBAL dotNetDidDownload NSISdl::download "http://go.microsoft.com/fwlink/?LinkId=225704" "$TEMP\dotNET45Web.exe" $dotNetDidDownload StrCmp $dotNetDidDownload success fail success: ExecWait '"$TEMP\dotNET45Web.exe" $dotNET_CMD_LINE' $EXIT_CODE Goto is_reboot_requested fail: MessageBox MB_OK|MB_ICONEXCLAMATION "Unable to download .NET Framework. $&#123;PRODUCT_NAME&#125; will be installed, but will not function without the Framework!" Goto done_dotNET_function # $EXIT_CODE contains the return codes. 1641 and 3010 means a Reboot has been requested is_reboot_requested: $&#123;If&#125; $EXIT_CODE = 1641 $&#123;OrIf&#125; $EXIT_CODE = 3010 SetRebootFlag true $&#123;EndIf&#125; done_compare_not_needed: # Done dotNET Install Goto done_dotNET_function #exit the function done_dotNET_function:FunctionEnd/****************************** * 以下是安装程序的卸载部分 * ******************************/Section Uninstall !insertmacro MUI_STARTMENU_GETFOLDER "Application" $ICONS_GROUP Delete "$INSTDIR\uninst.exe" Delete "$INSTDIR\*.*" Delete "$INSTDIR\#EXE名称" Delete "$SMPROGRAMS\$ICONS_GROUP\Uninstall.lnk" Delete "$SMPROGRAMS\$ICONS_GROUP\Website.lnk" Delete "$DESKTOP\#系统名称.lnk" Delete "$SMPROGRAMS\$ICONS_GROUP\#系统名称.lnk" RMDir "$SMPROGRAMS\$ICONS_GROUP" RMDir /r "$INSTDIR\x86" RMDir /r "$INSTDIR\x64" RMDir /r "$INSTDIR\Template" RMDir /r "$INSTDIR\Logs" RMDir /r "$INSTDIR\Images" RMDir "$INSTDIR" DeleteRegKey $&#123;PRODUCT_UNINST_ROOT_KEY&#125; "$&#123;PRODUCT_UNINST_KEY&#125;" DeleteRegKey HKLM "$&#123;PRODUCT_DIR_REGKEY&#125;" SetAutoClose trueSectionEnd#-- 根据 NSIS 脚本编辑规则，所有 Function 区段必须放置在 Section 区段之后编写，以避免安装程序出现未可预知的问题。--#Function un.onInit MessageBox MB_ICONQUESTION|MB_YESNO|MB_DEFBUTTON2 "您确实要完全移除 $(^Name) ，及其所有的组件？" IDYES +2 AbortFunctionEndFunction un.onUninstSuccess HideWindow MessageBox MB_ICONINFORMATION|MB_OK "$(^Name) 已成功地从您的计算机移除。"FunctionEnd]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>nsis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打印Word文件]]></title>
    <url>%2Fblog%2F2018%2F10%2F25%2Fasp-PrintWord%2F</url>
    <content type="text"><![CDATA[服务端调用打印机打印Word文件 简介工作时需要直接操作 OA系统 调用打印机打印 Word 文件。 引用库介绍需要电脑安装 Microsoft Office 并引用COM组件 Microsoft.Office.Interop.Word 才可以调用打印机。 代码及调用打印Word12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697using Word = Microsoft.Office.Interop.Word;/// &lt;summary&gt;/// 打印Word/// &lt;/summary&gt;/// &lt;param name="filePath"&gt;需要打印的文件&lt;/param&gt;/// &lt;param name="PrintName"&gt;打印机名称&lt;/param&gt;private static void PrintWord(string filePath, string PrintName)&#123; try &#123; //要打印的文件路径 Object wordFile = filePath; object oMissing = Missing.Value; //自定义object类型的布尔值 object oTrue = true; object oFalse = false; object doNotSaveChanges = Word.WdSaveOptions.wdDoNotSaveChanges; //Word.Application appWord = null; //定义word Application相关 Word.Application appWord = new Word.Application(); //word程序不可见 appWord.Visible = false; //不弹出警告框 appWord.DisplayAlerts = Word.WdAlertLevel.wdAlertsNone; //先保存默认的打印机 string defaultPrinter = appWord.ActivePrinter; //打开要打印的文件 Word.Document doc = appWord.Documents.Open( ref wordFile, ref oMissing, ref oTrue, ref oFalse, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing ); //设置指定的打印机名字 appWord.ActivePrinter = PrintName; //打印 doc.PrintOut( ref oTrue,//此处为true表示后台打印 ref oFalse, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing, ref oMissing ); //打印完关闭word文件 doc.Close(ref doNotSaveChanges, ref oMissing, ref oMissing); //还原原来的默认打印机 appWord.ActivePrinter = defaultPrinter; //退出word程序 appWord.Quit(ref oMissing, ref oMissing, ref oMissing); doc = null; appWord = null; &#125; catch (Exception ex) &#123; //代码行数 string line = ex.StackTrace.ToString(); //返回错误发生的方法定义 string errorfunction = ex.TargetSite.ToString(); int code = ex.HResult; &#125;&#125; 调用方法12//打印WordPrintWord(dialog.FileName, "审批打印机");]]></content>
      <categories>
        <category>Asp.Net</category>
      </categories>
      <tags>
        <tag>asp</tag>
        <tag>printer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/S端调用 WebApi 帮助类]]></title>
    <url>%2Fblog%2F2018%2F08%2F27%2Fcsharp-WebApiHelper%2F</url>
    <content type="text"><![CDATA[使用 HttpClient 与 HttpWebRequest 两种方式调用 WebApi 帮助类 简介现最常见的软件开发模式就是 服务端（B/S、WebApi、WebServer) + 客户端(C/S、Android、IOS)。公司有部分新项目修改为逻辑在服务端处理，所以通过两种方法封装一个C/S端调用WebApi接口的帮助类。调试WebApi推荐使用：Postman。 帮助类HttpClientHttpClientHelper 创建Get请求123456789101112131415161718192021222324252627282930313233343536373839/// &lt;summary&gt;/// 创建Get请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreateGetHttpClient(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters)&#123; try &#123; StringBuilder builder = new StringBuilder(); builder.Append(url); builder.Append(requestUrl); if (parameters != null &amp;&amp; parameters.Count &gt;= 1) &#123; builder.Append("?"); int i = 0; foreach (var item in parameters) &#123; if (i &gt; 0) &#123; builder.Append("&amp;"); &#125; builder.AppendFormat("&#123;0&#125;=&#123;1&#125;", item.Key, item.Value); i++; &#125; &#125; HttpClient httpClient = new HttpClient(); httpClient.BaseAddress = new Uri(url); var result = httpClient.GetAsync(builder.ToString()).Result; return result.Content.ReadAsStringAsync().Result; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125; 创建Post请求12345678910111213141516171819202122/// &lt;summary&gt;/// 创建Post请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreatePostHttpClient(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters)&#123; try &#123; HttpClient httpClient = new HttpClient(); httpClient.BaseAddress = new Uri(url); var result = httpClient.PostAsync(requestUrl, new FormUrlEncodedContent(parameters)).Result; return result.Content.ReadAsStringAsync().Result; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125; HttpWebRequest创建Get请求123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/// &lt;summary&gt;/// 创建Get请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreateGetHttpWebRequest(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters)&#123; try &#123; StringBuilder builder = new StringBuilder(); builder.Append(url); builder.Append(requestUrl); if (parameters != null &amp;&amp; parameters.Count &gt;= 1) &#123; builder.Append("?"); int i = 0; foreach (var item in parameters) &#123; if (i &gt; 0) &#123; builder.Append("&amp;"); &#125; builder.AppendFormat("&#123;0&#125;=&#123;1&#125;", item.Key, item.Value); i++; &#125; &#125; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(builder.ToString()); request.Method = "GET"; request.ContentType = "application/x-www-form-urlencoded"; StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream(), Encoding.UTF8); return reader.ReadToEnd(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125;/// &lt;summary&gt;/// 创建Get请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;param name="encoding"&gt;字符编码&lt;/param&gt;/// &lt;param name="timout "&gt;请求超时前等待的毫秒数,默认值是 100,000 毫秒（100 秒）&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreateGetHttpWebRequest(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters, Encoding encoding, int timout)&#123; try &#123; StringBuilder builder = new StringBuilder(); builder.Append(url); builder.Append(requestUrl); if (parameters != null &amp;&amp; parameters.Count &gt;= 1) &#123; builder.Append("?"); int i = 0; foreach (var item in parameters) &#123; if (i &gt; 0) &#123; builder.Append("&amp;"); &#125; builder.AppendFormat("&#123;0&#125;=&#123;1&#125;", item.Key, item.Value); i++; &#125; &#125; HttpWebRequest request = (HttpWebRequest)WebRequest.Create(builder.ToString()); request.Method = "GET"; request.ContentType = "application/x-www-form-urlencoded"; request.Timeout = timout; StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream(), encoding); return reader.ReadToEnd(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125; 创建Post请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/// &lt;summary&gt;/// 创建Post请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreatePostHttpWebRequest(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters)&#123; try &#123; HttpWebRequest request = WebRequest.Create(url + requestUrl) as HttpWebRequest; request.ProtocolVersion = HttpVersion.Version10; request.Method = "POST"; request.ContentType = "application/x-www-form-urlencoded"; //如果需要POST数据 if (!(parameters == null || parameters.Count == 0)) &#123; StringBuilder buffer = new StringBuilder(); int i = 0; foreach (string key in parameters.Keys) &#123; if (i &gt; 0) &#123; buffer.AppendFormat("&amp;&#123;0&#125;=&#123;1&#125;", key, parameters[key]); &#125; else &#123; buffer.AppendFormat("&#123;0&#125;=&#123;1&#125;", key, parameters[key]); &#125; i++; &#125; byte[] data = Encoding.GetEncoding("utf-8").GetBytes(buffer.ToString()); using (Stream stream = request.GetRequestStream()) &#123; stream.Write(data, 0, data.Length); &#125; &#125; StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream(), Encoding.UTF8); return reader.ReadToEnd(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125;/// &lt;summary&gt;/// 创建Post请求/// &lt;/summary&gt;/// &lt;param name="url"&gt;Api访问地址&lt;/param&gt;/// &lt;param name="requestUrl"&gt;详细方法路径&lt;/param&gt;/// &lt;param name="parameters"&gt;请求参数&lt;/param&gt;/// &lt;param name="encoding"&gt;字符编码&lt;/param&gt;/// &lt;param name="timout "&gt;请求超时前等待的毫秒数,默认值是 100,000 毫秒（100 秒）&lt;/param&gt;/// &lt;returns&gt;Api返回值&lt;/returns&gt;public static string CreatePostHttpWebRequest(string url, string requestUrl, IDictionary&lt;string, string&gt; parameters, Encoding encoding, int timout)&#123; try &#123; HttpWebRequest request = WebRequest.Create(url + requestUrl) as HttpWebRequest; request.ProtocolVersion = HttpVersion.Version10; request.Method = "POST"; request.ContentType = "application/x-www-form-urlencoded"; request.Timeout = timout; //如果需要POST数据 if (!(parameters == null || parameters.Count == 0)) &#123; StringBuilder buffer = new StringBuilder(); int i = 0; foreach (string key in parameters.Keys) &#123; if (i &gt; 0) &#123; buffer.AppendFormat("&amp;&#123;0&#125;=&#123;1&#125;", key, parameters[key]); &#125; else &#123; buffer.AppendFormat("&#123;0&#125;=&#123;1&#125;", key, parameters[key]); &#125; i++; &#125; byte[] data = encoding.GetBytes(buffer.ToString()); using (Stream stream = request.GetRequestStream()) &#123; stream.Write(data, 0, data.Length); &#125; &#125; StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream(), Encoding.UTF8); return reader.ReadToEnd(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return ""; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>webapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Depends 使用介绍]]></title>
    <url>%2Fblog%2F2018%2F08%2F01%2Fsoftware-Depends%2F</url>
    <content type="text"><![CDATA[简介Depends：可以扫描任何32位或64位Windows模块（exe，dll，ocx，sys等），并构建所有相关模块的分层树形图。对于找到的每个模块，它列出了该模块导出的所有函数，以及其他模块实际调用了哪些函数。另一个视图显示所需文件的最小集合，以及每个文件的详细信息，包括文件的完整路径，基本地址，版本号，机器类型，调试信息等。对于解决与加载和执行模块相关的系统错误也非常有用。Dependency Walker检测到许多常见的应用程序问题，例如缺少模块，模块无效，导入/导出不匹配，循环依赖性错误，模块的机器类型不匹配以及模块初始化失败。工作中需要使用到 C#/C++ 混合编程，或者安装一个软件后提示丢失某些类库导致无法运行时，Depends是最好的选择。 使用引用类库缺少软件安装包或开发环境提示错误：无法加载 DLL“xxx.dll”: 找不到指定的模块。使用Depends检查缺少模块，模块无效的库。下图：OpenCV 使用 Visual Studio 2015 开发缺少mfc120d.dll、msvcr120d.dll、msvcp120d.dll库 C/C++开发方法声明为C++方法时，DllImport 引用被不明方法加密，调用时需拷贝对应方法的Function名字粘贴到EntryPoint。12[DllImport(@"CPP_Demo.dll", EntryPoint = "?filePath@@YAPADPAD@Z", CallingConvention = CallingConvention.Cdecl, CharSet = CharSet.Unicode)]public static extern IntPtr filePath(IntPtr filePath);]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>depends</tag>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#/C++ 混合编程]]></title>
    <url>%2Fblog%2F2018%2F08%2F01%2Fcpp-HybridCSharp%2F</url>
    <content type="text"><![CDATA[使用C++开发算法（全景拼接、人脸识别、超分辨率重建）/使用C#开发服务端业务逻辑和UI 简介现工作中作由于C++的UI（MFC、QT）开发界面比较难看，定制用户控件复杂且样式一般。而C#又不擅长于开发算法逻辑，效率不如C++。所以现在大部分公司都会选用C#/C++混合编程。 性能分析使用C#做界面要比C++高效的多，但是存在算法逻辑的时候由于性能问题不得不把部分模块交给C++处理，C++可以使用高效的栈内存对象（CCalc），而C#所有对象只能放在托管堆中。测试C#调用C++类库使用托管方式性能得到了一定程度的提升，但比起单纯的C++项目，还是差了很多；测试C#调用C++类库使用 DllImport Attribute 混合方式由非托管动态链接库效率与单独运行C++相差无几。 简单基础参数传递例子：1.最基础的加法运算；2.传入图片地址，通过OpenCV处理后返回图片地址；3.传入图片地址，通过OpenCV把彩色图像转换为灰度图像，然后返回给C#；方法声明为C++方法时，DllImport 引用被不明方法加密，调用时需使用Depends工具拷贝对应方法的Function名字粘贴到EntryPoint。详情查看Depends 使用介绍1234567891011121314151617181920212223242526272829303132int Add(int a, int b)&#123; return a + b;&#125;char* filePath(char* filePath)&#123; char* resurlt; resurlt = filePath; IplImage* img = cvLoadImage(filePath); //用原图像指针创建新图像 IplImage* dst = cvCreateImage(cvGetSize(img), IPL_DEPTH_8U, 1); if (NULL == dst) &#123; return FALSE; &#125; cvCvtColor(img, dst, CV_BGR2GRAY); return resurlt;&#125;IplImage* Color2Gray(char* filePath)&#123; IplImage* img = cvLoadImage(filePath); //用原图像指针创建新图像 IplImage* dst = cvCreateImage(cvGetSize(img), IPL_DEPTH_8U, 1); if (NULL == dst) &#123; return FALSE; &#125; cvCvtColor(img, dst, CV_BGR2GRAY); return dst;&#125; 123456789101112131415161718192021[DllImport(@"CPP_Demo.dll", EntryPoint = "?Add@@YAHHH@Z", CallingConvention = CallingConvention.Cdecl)]public static extern int Add(int a, int b);[DllImport(@"CPP_Demo.dll", EntryPoint = "?filePath@@YAPEADPEAD@Z", CallingConvention = CallingConvention.Cdecl)]public static extern IntPtr filePath(IntPtr filePath);[DllImport(@"CPP_Demo.dll", EntryPoint = "?Color2Gray@@YAPEAU_IplImage@@PEAD@Z", CallingConvention = CallingConvention.Cdecl)]public static extern IntPtr Color2Gray(IntPtr filePath);//加载基础图片image1.Source = new BitmapImage(new Uri(@"./image/HUA1.JPG", UriKind.Relative));//测试1int iAdd = Add(8, 12);//测试2string strFile = Marshal.PtrToStringAnsi(filePath(Marshal.StringToHGlobalAnsi(@"F:\Demos\C#调用C++类库(OpenCV)\CSharp_Demo\CSharp_Demo\Image\HUA1.JPG")));//测试3IntPtr imageGray = Color2Gray(Marshal.StringToHGlobalAnsi(@"F:\Demos\C#调用C++类库(OpenCV)\CSharp_Demo\CSharp_Demo\Image\HUA1.JPG"));MIplImage lplimage = (Emgu.CV.Structure.MIplImage)System.Runtime.InteropServices.Marshal.PtrToStructure(imageGray, typeof(Emgu.CV.Structure.MIplImage));Image&lt;Gray, Byte&gt; dst = new Image&lt;Gray, Byte&gt;(lplimage.Width, lplimage.Height, lplimage.WidthStep, lplimage.ImageData);image2.Source = ChangeBitmapToImageSource(dst.ToBitmap()); 错误及处理报错：无法加载 DLL“xxx.dll”: 找不到指定的模块推荐使用 Depends 工具检测缺少引用类库 报错：调用 Dll “试图加载格式不正确的程序。(异常来自 HRESULT:0x8007000B)调用64位类库需要把项目改为64位桌面端修改：属性→生成→目标平台设为”Any Cpu”，取消勾选”首选32位”。Web端修改：工具→选项→项目和解决方案→Web项目→勾选”对网站和项目使用 IIS Express 的 64 位版”]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>c#</tag>
        <tag>depends</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis操作帮助类]]></title>
    <url>%2Fblog%2F2018%2F07%2F07%2Fcsharp-RedisHelper%2F</url>
    <content type="text"><![CDATA[基于 StackExchange.Redis 库操作 Redis 帮助类 简介Redis 作为典型的 非关系型数据库（NoSQL） 采用Key-Value方式储存数据，持久化储存于内存中，对于请发请求速度要远高于传统数据库。 帮助类RedisHelper 引用 StackExchange.Redis 库。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229/// &lt;summary&gt;/// Redis 排序类型/// &lt;/summary&gt;public enum OrderType&#123; /// &lt;summary&gt; /// 提升 /// &lt;/summary&gt; Ascending, /// &lt;summary&gt; /// 下降 /// &lt;/summary&gt; Descending&#125;/// &lt;summary&gt;/// 获取 Redis 连接对象/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public IConnectionMultiplexer GetConnectionRedisMultiplexer()&#123; if (_connMultiplexer == null || !_connMultiplexer.IsConnected) lock (Locker) &#123; if (_connMultiplexer == null || !_connMultiplexer.IsConnected) _connMultiplexer = ConnectionMultiplexer.Connect(ConnectionString); &#125; return _connMultiplexer;&#125;#region 其它/// &lt;summary&gt;/// 获取事务/// &lt;/summary&gt;/// &lt;returns&gt;&lt;/returns&gt;public ITransaction GetTransaction()&#123; return _db.CreateTransaction();&#125;#endregion 其它#region private field/// &lt;summary&gt;/// 连接字符串/// &lt;/summary&gt;private static readonly string ConnectionString;/// &lt;summary&gt;/// redis 连接对象/// &lt;/summary&gt;private static IConnectionMultiplexer _connMultiplexer;/// &lt;summary&gt;/// 默认的 Key 值（用来当作 RedisKey 的前缀）/// &lt;/summary&gt;private static readonly string DefaultKey;/// &lt;summary&gt;/// 锁/// &lt;/summary&gt;private static readonly object Locker = new object();/// &lt;summary&gt;/// 数据库/// &lt;/summary&gt;private readonly IDatabase _db;#endregion private field#region 构造函数/// &lt;summary&gt;/// 构造函数/// &lt;/summary&gt;static RedisHelper()&#123; try &#123; ConnectionString = ConfigurationManager.ConnectionStrings["RedisConnectionString"].ConnectionString; &#125; catch (Exception) &#123; ConnectionString = "127.0.0.1:6379"; &#125; _connMultiplexer = ConnectionMultiplexer.Connect(ConnectionString); try &#123; DefaultKey = ConfigurationManager.AppSettings["Redis.DefaultKey"]; &#125; catch (Exception) &#123; DefaultKey = string.Empty; &#125; AddRegisterEvent();&#125;/// &lt;summary&gt;/// 构造函数/// &lt;/summary&gt;/// &lt;param name="db"&gt;&lt;/param&gt;public RedisHelper(int db = 0)&#123; _db = _connMultiplexer.GetDatabase(db);&#125;#endregion 构造函数#region String 操作/// &lt;summary&gt;/// 设置 key 并保存字符串（如果 key 已存在，则覆盖值）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool StringSet(string redisKey, string redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return _db.StringSet(redisKey, redisValue, expiry);&#125;/// &lt;summary&gt;/// 保存多个 Key-value/// &lt;/summary&gt;/// &lt;param name="keyValuePairs"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool StringSet(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; keyValuePairs)&#123; var pairs = keyValuePairs.Select(x =&gt; new KeyValuePair&lt;RedisKey, RedisValue&gt;(AddKeyPrefix(x.Key), x.Value)); return _db.StringSet(pairs.ToArray());&#125;/// &lt;summary&gt;/// 获取字符串/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string StringGet(string redisKey, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return _db.StringGet(redisKey);&#125;/// &lt;summary&gt;/// 存储一个对象（该对象会被序列化保存）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool StringSet&lt;T&gt;(string redisKey, T redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(redisValue); return _db.StringSet(redisKey, json, expiry);&#125;/// &lt;summary&gt;/// 获取一个对象（会进行反序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T StringGet&lt;T&gt;(string redisKey, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(_db.StringGet(redisKey));&#125;#region async/// &lt;summary&gt;/// 保存一个字符串值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; StringSetAsync(string redisKey, string redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.StringSetAsync(redisKey, redisValue, expiry);&#125;/// &lt;summary&gt;/// 保存一组字符串值/// &lt;/summary&gt;/// &lt;param name="keyValuePairs"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; StringSetAsync(IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; keyValuePairs)&#123; var pairs = keyValuePairs.Select(x =&gt; new KeyValuePair&lt;RedisKey, RedisValue&gt;(AddKeyPrefix(x.Key), x.Value)); return await _db.StringSetAsync(pairs.ToArray());&#125;/// &lt;summary&gt;/// 获取单个值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;string&gt; StringGetAsync(string redisKey, string redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.StringGetAsync(redisKey);&#125;/// &lt;summary&gt;/// 存储一个对象（该对象会被序列化保存）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; StringSetAsync&lt;T&gt;(string redisKey, T redisValue, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(redisValue); return await _db.StringSetAsync(redisKey, json, expiry);&#125;/// &lt;summary&gt;/// 获取一个对象（会进行反序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;T&gt; StringGetAsync&lt;T&gt;(string redisKey, TimeSpan? expiry = null)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(await _db.StringGetAsync(redisKey));&#125;#endregion async#endregion String 操作#region Hash 操作/// &lt;summary&gt;/// 判断该字段是否存在 hash 中/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool HashExists(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return _db.HashExists(redisKey, hashField);&#125;/// &lt;summary&gt;/// 从 hash 中移除指定字段/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool HashDelete(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return _db.HashDelete(redisKey, hashField);&#125;/// &lt;summary&gt;/// 从 hash 中移除指定字段/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long HashDelete(string redisKey, IEnumerable&lt;string&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var fields = hashFields.Select(x =&gt; (RedisValue)x); return _db.HashDelete(redisKey, fields.ToArray());&#125;/// &lt;summary&gt;/// 在 hash 设定值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool HashSet(string redisKey, string hashField, string value)&#123; redisKey = AddKeyPrefix(redisKey); return _db.HashSet(redisKey, hashField, value);&#125;/// &lt;summary&gt;/// 在 hash 中设定值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;public void HashSet(string redisKey, IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var entries = hashFields.Select(x =&gt; new HashEntry(x.Key, x.Value)); _db.HashSet(redisKey, entries.ToArray());&#125;/// &lt;summary&gt;/// 在 hash 中获取值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string HashGet(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return _db.HashGet(redisKey, hashField);&#125;/// &lt;summary&gt;/// 在 hash 中获取值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; HashGet(string redisKey, IEnumerable&lt;string&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var fields = hashFields.Select(x =&gt; (RedisValue)x); return ConvertStrings(_db.HashGet(redisKey, fields.ToArray()));&#125;/// &lt;summary&gt;/// 从 hash 返回所有的字段值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; HashKeys(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(_db.HashKeys(redisKey));&#125;/// &lt;summary&gt;/// 返回 hash 中的所有值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; HashValues(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(_db.HashValues(redisKey));&#125;/// &lt;summary&gt;/// 在 hash 设定值（序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool HashSet&lt;T&gt;(string redisKey, string hashField, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(redisValue); return _db.HashSet(redisKey, hashField, json);&#125;/// &lt;summary&gt;/// 在 hash 中获取值（反序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T HashGet&lt;T&gt;(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(_db.HashGet(redisKey, hashField));&#125;#region async/// &lt;summary&gt;/// 判断该字段是否存在 hash 中/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; HashExistsAsync(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.HashExistsAsync(redisKey, hashField);&#125;/// &lt;summary&gt;/// 从 hash 中移除指定字段/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; HashDeleteAsync(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.HashDeleteAsync(redisKey, hashField);&#125;/// &lt;summary&gt;/// 从 hash 中移除指定字段/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; HashDeleteAsync(string redisKey, IEnumerable&lt;string&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var fields = hashFields.Select(x =&gt; (RedisValue)x); return await _db.HashDeleteAsync(redisKey, fields.ToArray());&#125;/// &lt;summary&gt;/// 在 hash 设定值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; HashSetAsync(string redisKey, string hashField, string value)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.HashSetAsync(redisKey, hashField, value);&#125;/// &lt;summary&gt;/// 在 hash 中设定值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;public async Task HashSetAsync(string redisKey, IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; hashFields)&#123; redisKey = AddKeyPrefix(redisKey); var entries = hashFields.Select(x =&gt; new HashEntry(AddKeyPrefix(x.Key), x.Value)); await _db.HashSetAsync(redisKey, entries.ToArray());&#125;/// &lt;summary&gt;/// 在 hash 中获取值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;string&gt; HashGetAsync(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.HashGetAsync(redisKey, hashField);&#125;/// &lt;summary&gt;/// 在 hash 中获取值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashFields"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; HashGetAsync(string redisKey, IEnumerable&lt;string&gt; hashFields, string value)&#123; redisKey = AddKeyPrefix(redisKey); var fields = hashFields.Select(x =&gt; (RedisValue)x); return ConvertStrings(await _db.HashGetAsync(redisKey, fields.ToArray()));&#125;/// &lt;summary&gt;/// 从 hash 返回所有的字段值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; HashKeysAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(await _db.HashKeysAsync(redisKey));&#125;/// &lt;summary&gt;/// 返回 hash 中的所有值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; HashValuesAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(await _db.HashValuesAsync(redisKey));&#125;/// &lt;summary&gt;/// 在 hash 设定值（序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; HashSetAsync&lt;T&gt;(string redisKey, string hashField, T value)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(value); return await _db.HashSetAsync(redisKey, hashField, json);&#125;/// &lt;summary&gt;/// 在 hash 中获取值（反序列化）/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="hashField"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;T&gt; HashGetAsync&lt;T&gt;(string redisKey, string hashField)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(await _db.HashGetAsync(redisKey, hashField));&#125;#endregion async#endregion Hash 操作#region List 操作/// &lt;summary&gt;/// 移除并返回存储在该键列表的第一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string ListLeftPop(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListLeftPop(redisKey);&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的最后一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public string ListRightPop(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListRightPop(redisKey);&#125;/// &lt;summary&gt;/// 移除列表指定键上与该值相同的元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListRemove(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListRemove(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 在列表尾部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListRightPush(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListRightPush(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 在列表头部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListLeftPush(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListLeftPush(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 返回列表上该键的长度，如果不存在，返回 0/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListLength(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListLength(redisKey);&#125;/// &lt;summary&gt;/// 返回在该列表上键所对应的元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="start"&gt;&lt;/param&gt;/// &lt;param name="stop"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; ListRange(string redisKey, long start = 0L, long stop = -1L)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(_db.ListRange(redisKey, start, stop));&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的第一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T ListLeftPop&lt;T&gt;(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(_db.ListLeftPop(redisKey));&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的最后一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public T ListRightPop&lt;T&gt;(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(_db.ListRightPop(redisKey));&#125;/// &lt;summary&gt;/// 在列表尾部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListRightPush&lt;T&gt;(string redisKey, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListRightPush(redisKey, Serialize(redisValue));&#125;/// &lt;summary&gt;/// 在列表头部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long ListLeftPush&lt;T&gt;(string redisKey, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return _db.ListLeftPush(redisKey, Serialize(redisValue));&#125;#region List-async/// &lt;summary&gt;/// 移除并返回存储在该键列表的第一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;string&gt; ListLeftPopAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListLeftPopAsync(redisKey);&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的最后一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;string&gt; ListRightPopAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListRightPopAsync(redisKey);&#125;/// &lt;summary&gt;/// 移除列表指定键上与该值相同的元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListRemoveAsync(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListRemoveAsync(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 在列表尾部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListRightPushAsync(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListRightPushAsync(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 在列表头部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListLeftPushAsync(string redisKey, string redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListLeftPushAsync(redisKey, redisValue);&#125;/// &lt;summary&gt;/// 返回列表上该键的长度，如果不存在，返回 0/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListLengthAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListLengthAsync(redisKey);&#125;/// &lt;summary&gt;/// 返回在该列表上键所对应的元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="start"&gt;&lt;/param&gt;/// &lt;param name="stop"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; ListRangeAsync(string redisKey, long start = 0L, long stop = -1L)&#123; redisKey = AddKeyPrefix(redisKey); var query = await _db.ListRangeAsync(redisKey, start, stop); return query.Select(x =&gt; x.ToString());&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的第一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;T&gt; ListLeftPopAsync&lt;T&gt;(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(await _db.ListLeftPopAsync(redisKey));&#125;/// &lt;summary&gt;/// 移除并返回存储在该键列表的最后一个元素/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;T&gt; ListRightPopAsync&lt;T&gt;(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return Deserialize&lt;T&gt;(await _db.ListRightPopAsync(redisKey));&#125;/// &lt;summary&gt;/// 在列表尾部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListRightPushAsync&lt;T&gt;(string redisKey, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListRightPushAsync(redisKey, Serialize(redisValue));&#125;/// &lt;summary&gt;/// 在列表头部插入值。如果键不存在，先创建再插入值/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisValue"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; ListLeftPushAsync&lt;T&gt;(string redisKey, T redisValue)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.ListLeftPushAsync(redisKey, Serialize(redisValue));&#125;#endregion List-async#endregion List 操作#region SortedSet 操作/// &lt;summary&gt;/// SortedSet 新增/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="score"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool SortedSetAdd(string redisKey, string member, double score)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetAdd(redisKey, member, score);&#125;/// &lt;summary&gt;/// 在有序集合中返回指定范围的元素，默认情况下从低到高。/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="start"&gt;&lt;/param&gt;/// &lt;param name="stop"&gt;&lt;/param&gt;/// &lt;param name="order"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public IEnumerable&lt;string&gt; SortedSetRangeByRank(string redisKey, long start = 0L, long stop = -1L, OrderType order = OrderType.Ascending)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetRangeByRank(redisKey, start, stop, (Order)order).Select(x =&gt; x.ToString());&#125;/// &lt;summary&gt;/// 返回有序集合的元素个数/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long SortedSetLength(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetLength(redisKey);&#125;/// &lt;summary&gt;/// 返回有序集合的元素个数/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="memebr"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool SortedSetLength(string redisKey, string memebr)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetRemove(redisKey, memebr);&#125;/// &lt;summary&gt;/// SortedSet 新增/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="score"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool SortedSetAdd&lt;T&gt;(string redisKey, T member, double score)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(member); return _db.SortedSetAdd(redisKey, json, score);&#125;/// &lt;summary&gt;/// 增量的得分排序的集合中的成员存储键值键按增量/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public double SortedSetIncrement(string redisKey, string member, double value = 1)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetIncrement(redisKey, member, value);&#125;#region SortedSet-Async/// &lt;summary&gt;/// SortedSet 新增/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="score"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; SortedSetAddAsync(string redisKey, string member, double score)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.SortedSetAddAsync(redisKey, member, score);&#125;/// &lt;summary&gt;/// 在有序集合中返回指定范围的元素，默认情况下从低到高。/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;IEnumerable&lt;string&gt;&gt; SortedSetRangeByRankAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return ConvertStrings(await _db.SortedSetRangeByRankAsync(redisKey));&#125;/// &lt;summary&gt;/// 返回有序集合的元素个数/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; SortedSetLengthAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.SortedSetLengthAsync(redisKey);&#125;/// &lt;summary&gt;/// 返回有序集合的元素个数/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="memebr"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; SortedSetRemoveAsync(string redisKey, string memebr)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.SortedSetRemoveAsync(redisKey, memebr);&#125;/// &lt;summary&gt;/// SortedSet 新增/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="score"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; SortedSetAddAsync&lt;T&gt;(string redisKey, T member, double score)&#123; redisKey = AddKeyPrefix(redisKey); var json = Serialize(member); return await _db.SortedSetAddAsync(redisKey, json, score);&#125;/// &lt;summary&gt;/// 增量的得分排序的集合中的成员存储键值键按增量/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="member"&gt;&lt;/param&gt;/// &lt;param name="value"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public Task&lt;double&gt; SortedSetIncrementAsync(string redisKey, string member, double value = 1)&#123; redisKey = AddKeyPrefix(redisKey); return _db.SortedSetIncrementAsync(redisKey, member, value);&#125;#endregion SortedSet-Async#endregion SortedSet 操作#region key 操作/// &lt;summary&gt;/// 移除指定 Key/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool KeyDelete(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.KeyDelete(redisKey);&#125;/// &lt;summary&gt;/// 移除指定 Key/// &lt;/summary&gt;/// &lt;param name="redisKeys"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public long KeyDelete(IEnumerable&lt;string&gt; redisKeys)&#123; var keys = redisKeys.Select(x =&gt; (RedisKey)AddKeyPrefix(x)); return _db.KeyDelete(keys.ToArray());&#125;/// &lt;summary&gt;/// 校验 Key 是否存在/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool KeyExists(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.KeyExists(redisKey);&#125;/// &lt;summary&gt;/// 重命名 Key/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisNewKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool KeyRename(string redisKey, string redisNewKey)&#123; redisKey = AddKeyPrefix(redisKey); return _db.KeyRename(redisKey, redisNewKey);&#125;/// &lt;summary&gt;/// 设置 Key 的时间/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public bool KeyExpire(string redisKey, TimeSpan? expiry)&#123; redisKey = AddKeyPrefix(redisKey); return _db.KeyExpire(redisKey, expiry);&#125;#region key-async/// &lt;summary&gt;/// 移除指定 Key/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; KeyDeleteAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.KeyDeleteAsync(redisKey);&#125;/// &lt;summary&gt;/// 移除指定 Key/// &lt;/summary&gt;/// &lt;param name="redisKeys"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;long&gt; KeyDeleteAsync(IEnumerable&lt;string&gt; redisKeys)&#123; var keys = redisKeys.Select(x =&gt; (RedisKey)AddKeyPrefix(x)); return await _db.KeyDeleteAsync(keys.ToArray());&#125;/// &lt;summary&gt;/// 校验 Key 是否存在/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; KeyExistsAsync(string redisKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.KeyExistsAsync(redisKey);&#125;/// &lt;summary&gt;/// 重命名 Key/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="redisNewKey"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; KeyRenameAsync(string redisKey, string redisNewKey)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.KeyRenameAsync(redisKey, redisNewKey);&#125;/// &lt;summary&gt;/// 设置 Key 的时间/// &lt;/summary&gt;/// &lt;param name="redisKey"&gt;&lt;/param&gt;/// &lt;param name="expiry"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public async Task&lt;bool&gt; KeyExpireAsync(string redisKey, TimeSpan? expiry)&#123; redisKey = AddKeyPrefix(redisKey); return await _db.KeyExpireAsync(redisKey, expiry);&#125;#endregion key-async#endregion key 操作#region private method/// &lt;summary&gt;/// 添加 Key 的前缀/// &lt;/summary&gt;/// &lt;param name="key"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static string AddKeyPrefix(string key)&#123; return $"&#123;DefaultKey&#125;&#123;key&#125;";&#125;/// &lt;summary&gt;/// 转换为字符串/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;/// &lt;param name="list"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static IEnumerable&lt;string&gt; ConvertStrings&lt;T&gt;(IEnumerable&lt;T&gt; list) where T : struct&#123; if (list == null) throw new ArgumentNullException(nameof(list)); return list.Select(x =&gt; x.ToString());&#125;#region 注册事件/// &lt;summary&gt;/// 添加注册事件/// &lt;/summary&gt;private static void AddRegisterEvent()&#123; _connMultiplexer.ConnectionRestored += ConnMultiplexer_ConnectionRestored; _connMultiplexer.ConnectionFailed += ConnMultiplexer_ConnectionFailed; _connMultiplexer.ErrorMessage += ConnMultiplexer_ErrorMessage; _connMultiplexer.ConfigurationChanged += ConnMultiplexer_ConfigurationChanged; _connMultiplexer.HashSlotMoved += ConnMultiplexer_HashSlotMoved; _connMultiplexer.InternalError += ConnMultiplexer_InternalError; _connMultiplexer.ConfigurationChangedBroadcast += ConnMultiplexer_ConfigurationChangedBroadcast;&#125;/// &lt;summary&gt;/// 重新配置广播时（通常意味着主从同步更改）/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ConfigurationChangedBroadcast(object sender, EndPointEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ConfigurationChangedBroadcast)&#125;: &#123;e.EndPoint&#125;");&#125;/// &lt;summary&gt;/// 发生内部错误时（主要用于调试）/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_InternalError(object sender, InternalErrorEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_InternalError)&#125;: &#123;e.Exception&#125;");&#125;/// &lt;summary&gt;/// 更改集群时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_HashSlotMoved(object sender, HashSlotMovedEventArgs e)&#123; Console.WriteLine( $"&#123;nameof(ConnMultiplexer_HashSlotMoved)&#125;: &#123;nameof(e.OldEndPoint)&#125;-&#123;e.OldEndPoint&#125; To &#123;nameof(e.NewEndPoint)&#125;-&#123;e.NewEndPoint&#125;, ");&#125;/// &lt;summary&gt;/// 配置更改时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ConfigurationChanged(object sender, EndPointEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ConfigurationChanged)&#125;: &#123;e.EndPoint&#125;");&#125;/// &lt;summary&gt;/// 发生错误时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ErrorMessage(object sender, RedisErrorEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ErrorMessage)&#125;: &#123;e.Message&#125;");&#125;/// &lt;summary&gt;/// 物理连接失败时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ConnectionFailed(object sender, ConnectionFailedEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ConnectionFailed)&#125;: &#123;e.Exception&#125;");&#125;/// &lt;summary&gt;/// 建立物理连接时/// &lt;/summary&gt;/// &lt;param name="sender"&gt;&lt;/param&gt;/// &lt;param name="e"&gt;&lt;/param&gt;private static void ConnMultiplexer_ConnectionRestored(object sender, ConnectionFailedEventArgs e)&#123; Console.WriteLine($"&#123;nameof(ConnMultiplexer_ConnectionRestored)&#125;: &#123;e.Exception&#125;");&#125;#endregion 注册事件/// &lt;summary&gt;/// 序列化/// &lt;/summary&gt;/// &lt;param name="obj"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static byte[] Serialize(object obj)&#123; if (obj == null) return null; var binaryFormatter = new BinaryFormatter(); using (var memoryStream = new MemoryStream()) &#123; binaryFormatter.Serialize(memoryStream, obj); var data = memoryStream.ToArray(); return data; &#125;&#125;/// &lt;summary&gt;/// 反序列化/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;/// &lt;param name="data"&gt;&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;private static T Deserialize&lt;T&gt;(byte[] data)&#123; if (data == null) return default(T); var binaryFormatter = new BinaryFormatter(); using (var memoryStream = new MemoryStream(data)) &#123; var result = (T)binaryFormatter.Deserialize(memoryStream); return result; &#125;&#125;#endregion private method 2018年9月6日补充方法：获得所有Key/Key-Value123456789101112131415161718192021222324252627282930313233/// &lt;summary&gt;/// 获得Redis所有Key值/// &lt;/summary&gt;/// &lt;returns&gt;Redis所有Key值&lt;/returns&gt;public List&lt;string&gt; GetAllKeys()&#123; List&lt;string&gt; keyList = new List&lt;string&gt;(); foreach (var ep in _connMultiplexer.GetEndPoints()) &#123; var server = _connMultiplexer.GetServer(ep); var keys = server.Keys(0, "*"); foreach (var item in keys) &#123; keyList.Add((string)item); &#125; &#125; return keyList;&#125;/// &lt;summary&gt;/// 获得Redis所有Key值和Value值/// &lt;/summary&gt;/// &lt;returns&gt;Redis所有Key值和Value值&lt;/returns&gt;public Dictionary&lt;string, string&gt; GetAllKeysValues()&#123; Dictionary&lt;string, string&gt; dicAllKeysValues = new Dictionary&lt;string, string&gt;(); List&lt;string&gt; listAllKeys = GetAllKeys(); foreach (var item in listAllKeys) &#123; dicAllKeysValues.Add(item, StringGet(item)); &#125; return dicAllKeysValues;&#125; 错误处理Redis错误信息：MISCONG Redis is configured to save RDB执行：config set stop-writes-on-bgsave-error no]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ Demo]]></title>
    <url>%2Fblog%2F2018%2F07%2F07%2Fcsharp-RabbitMQ%2F</url>
    <content type="text"><![CDATA[RabbitMQ 消息队列使用介绍 简介RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。具备异步、解耦等机制。RabbitMQ在全球范围内在小型初创公司和大型企业中进行了超过35,000次RabbitMQ生产部署，是最受欢迎的开源消息代理。RabbitMQ轻量级，易于在内部和云中部署。它支持多种消息传递协议。RabbitMQ可以部署在分布式和联合配置中，以满足高规模，高可用性要求。RabbitMQ可在许多操作系统和云环境中运行，并为大多数流行语言提供各种开发人员工具。 安装部署请参阅官方文档 C#代码调用引用 RabbitMQ.Client 库 生产者123456789101112131415161718192021/// &lt;summary&gt;/// 生产者/// &lt;/summary&gt;public static void Send()&#123; var factory = new ConnectionFactory() &#123; HostName = "localhost" &#125;; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) &#123; channel.QueueDeclare(queue: "hello", durable: false, exclusive: false, autoDelete: false, arguments: null); string message = "Hello World!"; var body = Encoding.UTF8.GetBytes(message); channel.BasicPublish(exchange: "", routingKey: "hello", basicProperties: null, body: body); Console.WriteLine(" [x] Sent &#123;0&#125;", message); &#125; Console.WriteLine(" Press [enter] to exit."); Console.ReadLine();&#125; 消费者123456789101112131415161718192021222324/// &lt;summary&gt;/// 消费者/// &lt;/summary&gt;public static void Receive()&#123; var factory = new ConnectionFactory() &#123; HostName = "localhost" &#125;; using (var connection = factory.CreateConnection()) using (var channel = connection.CreateModel()) &#123; channel.QueueDeclare(queue: "hello", durable: false, exclusive: false, autoDelete: false, arguments: null); var consumer = new EventingBasicConsumer(channel); consumer.Received += (model, ea) =&gt; &#123; var body = ea.Body; var message = Encoding.UTF8.GetString(body); Console.WriteLine(" [x] Received &#123;0&#125;", message); &#125;; channel.BasicConsume(queue: "hello", autoAck: true, consumer: consumer); Console.WriteLine(" Press [enter] to exit."); Console.ReadLine(); &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EntityFramework Demo]]></title>
    <url>%2Fblog%2F2018%2F07%2F02%2Fcsharp-EntityFramework%2F</url>
    <content type="text"><![CDATA[EntityFramework 框架使用介绍 简介Entity Framework 是微软以 ADO.NET 为基础所发展出来的对象关系对应 (O/R Mapping) 解决方案。在.NET 3.5之前，开发者通常使用 ADO.NET 直接连接操作数据库，而Entity Framework的出现可以让开发者更多的从代码层面考虑数据交互，Entity Framework 会把字段映射为实体模型，通过 Lambda表达式 来操作数据，不需要考虑各种类型数据库和拼写SQL语句。同时也有效的防止了 SQL注入。 搭建-以MySQL为例类库或应用程序项目下新建项 实体模型向导从EF 4.X开始支持三种构建方法：Database First：数据库优先，你的项目已经有一个数据库，并且使用工具（如Visual Studio中的EF设计器)依据数据库生成C#或VB类。你可以通过EF设计器修改这些创建的类以及类和数据库之间的映射关系；这种方式的关键是先要有数据，然后才有代码和模型。Model First：模型优先，通过在EF设计器中创建一个空的容器，在其中设计实体数据模型。这个模型将用于生成数据库以及C#或者VB类。这种方式的关键是先要有模型，然后才有数据库和代码。Code First：代码优先，开发者只需要写代码，将会自动创建模型和数据库。现采用基础又最常用的 Database First 方式创建！ 更改数据源连接MySQL需要单独安装 mysql-connector-net 与 mysql-for-visualstudio 修改连接属性 添加连接串 选择框架版本 添加数据库表模型，完成 如果出现闪退、无法编辑数据，尝试修改引用库版本EntityFramework：6.0.0.0EntityFramework.SqlServer：6.0.0.0MySql.Data：6.9.9.0MySql.Data.Entity.EF6：6.9.9.0 增删改查12345678910111213141516//新增officeautomationEntities ef = new officeautomationEntities();user_info user = new user_info();user.UserName = "00006";user.Password = "123456";ef.user_info.Add(user);ef.SaveChanges();//修改var query = ef.user_info.Where(o =&gt; o.UserName.Equals("00006")).FirstOrDefault();query.Password = "mq1i1JC92zal7nnbFZjtPQ==";ef.SaveChanges();//删除ef.user_info.Remove(query);ef.SaveChanges();//查询var v = ef.user_info.Where(o =&gt; o.UserName.Equals("00003")).ToList(); 错误及处理EF创建时崩溃MySql引用库版本修改为6.9.9 报错：Host “”is not allowed to connect to this MySQL server123grant all privileges on *.* to 'root'@'192.168.0.1' identified by '密码';grant all privileges on *.* to 'root'@'%' identified by '密码';flush privileges; 报错：Mysql表 “TableDetails” 中列 “IsPrimaryKey” 的值位 DBNull。123use 库名;SET GLOBAL optimizer_switch='derived_merge=off';SET optimizer_switch='derived_merge=off'; 报错：其他信息: 对一个或多个实体的验证失败。有关详细信息，请参见“EntityValidationErrors”属性。写入数据与表设定不一致SaveChanges();方法前后使用：Configuration.ValidateOnSaveEnabled123ef.Configuration.ValidateOnSaveEnabled = false;ef.SaveChanges();ef.Configuration.ValidateOnSaveEnabled = true;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>ef</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地林伟业科技股份有限公司]]></title>
    <url>%2Fblog%2F2018%2F05%2F28%2Fwork-Forestar%2F</url>
    <content type="text"><![CDATA[基于 ArcGIS 和公司自主平台 Mapzone 进行地理信息系统二次开发 个人简介2016年06月28日 - 2018年06月28日 就职于 北京地林伟业科技股份有限公司 软件研发工程师岗位。 公司简介北京地林伟业科技股份有限公司（简称“地林伟业”，股票代码：430416），是“互联网+”林业信息化服务提供商，为用户提供林业信息化全方位解决方案，经过10余年的不懈努力,地林伟业在各项业务上都取得了长足发展，成为林业信息化领域的翘楚。 公司有自主研发的MAPZONE GIS系列产品，包括桌面产品MAPZONE Desktop、移动产品MAPZONE Mobile、服务端产品MAPZONE Server、三维产品MAPZONE Globe以及相应的开发包MAPZONE SDK。 公司在自主技术的基础上，研发了FORESTAR应用平台系列产品，包括FORESTAR GIS应用平台、FORESTAR二三维一体化平台、共享服务平台、综合信息应用服务平台、电子政务平台、FORESTAR OA网络办公平台、林业应用支撑平台，为林业行业提供了从移动端、Web端、桌面端、服务器端的完整解决方案。 公司经过多年的积累，为整个“互联网+”林业信息化提供了一整套解决方案，包括“互联网+”林业资源监管解决方案、“互联网+”生态修复工程解决方案、“互联网+”灾害应急工程解决方案、“互联网+”林业改革创新解决方案、“互联网+”林业产业提升解决方案、“互联网+”公共服务建设解决方案、“互联网+”林业政务服务解决方案、“互联网+”基础能力建设解决方案。 项目介绍（由于签署保密协议，仅介绍大致工作内容）由 C# + WinForm + DevExpress 开发基于 ArcGIS 与公司自主研发 MAPZONE GIS 的地理信息系统。参与过主要的项目有：林地更新、二类调查、农村土地确权。工作主要开发C/S端程序，并且与Android端与B/S端开发人员对接。由于B/S端同事不熟悉 Lambda 表达式 所以在功能迁移的时候使用 JAVA 开发了一段时间 Web API。大量使用 NPOI/DOCX 技术导出报表及合同证书。带领帮助初级开发人员解决问题。]]></content>
      <categories>
        <category>Work</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>mysql</tag>
        <tag>winform</tag>
        <tag>sqlite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密解密帮助类]]></title>
    <url>%2Fblog%2F2018%2F01%2F10%2Fcsharp-EncryptionHelper%2F</url>
    <content type="text"><![CDATA[提供几种对称加密与非对称加密算法，以及单项加密与文件夹加密 简介工作中需要各种方式的加密（传输文本加密，文件加密，图片Base64编码，文件MD5与SHA1值计算），既有对称式加密与非对称式加密，也有单向加密，应用于各种使用环境。 警告由于2017年5月12日的比特币勒索病毒 WannaCry 爆发，100多个国家和地区超过10万台电脑遭到了勒索病毒攻击、感染。其原理就是加密电脑中的文件，以用秘钥勒索比特币。技术本质并无好坏之分，多行善事。 帮助类、介绍对称式加密对称加密算法 解密使用相同密钥及相同算法的逆算法对密文进行解密。 AESAES 一种区块加密标准，替代原先的DES，对称密钥加密中最流行的算法之一。AESHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161/// &lt;summary&gt;/// AES加密/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥&lt;/param&gt;/// &lt;returns&gt;AES密文&lt;/returns&gt;public static string AESEncrypt(string strPlaintext, string strKey)&#123; try &#123; if (string.IsNullOrEmpty(strPlaintext)) &#123; return string.Empty; &#125; strKey = strKey.Length &lt; 32 ? strKey.PadRight(32, '0') : strKey.Substring(0, 32); Byte[] toEncryptArray = Encoding.UTF8.GetBytes(strPlaintext); RijndaelManaged rijndaelManaged = new RijndaelManaged &#123; Key = Encoding.UTF8.GetBytes(strKey), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 &#125;; ICryptoTransform pCryptoTransform = rijndaelManaged.CreateEncryptor(); Byte[] resultArray = pCryptoTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return Convert.ToBase64String(resultArray, 0, resultArray.Length); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// AES解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;AES密文&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥&lt;/param&gt;/// &lt;returns&gt;明文&lt;/returns&gt;public static string AESDecrypt(string strCiphertext, string strKey)&#123; try &#123; if (string.IsNullOrEmpty(strCiphertext)) &#123; return string.Empty; &#125; strKey = strKey.Length &lt; 32 ? strKey.PadRight(32, '0') : strKey.Substring(0, 32); Byte[] toEncryptArray = Convert.FromBase64String(strCiphertext); RijndaelManaged rijndaelManaged = new RijndaelManaged &#123; Key = Encoding.UTF8.GetBytes(strKey), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 &#125;; ICryptoTransform pCryptoTransform = rijndaelManaged.CreateDecryptor(); Byte[] resultArray = pCryptoTransform.TransformFinalBlock(toEncryptArray, 0, toEncryptArray.Length); return Encoding.UTF8.GetString(resultArray); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 文件AES加密/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;加密文件目录&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FileAESEncrypt(string strFilePath, string strSaveFilePath, string strKey)&#123; try &#123; //设置Aes秘钥和格式 strKey = strKey.Length &lt; 32 ? strKey.PadRight(32, '0') : strKey.Substring(0, 32); RijndaelManaged rijndaelManaged = new RijndaelManaged &#123; Key = Encoding.UTF8.GetBytes(strKey), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 &#125;; //读取文本加密数据 FileStream fileStream = File.OpenRead(strFilePath); byte[] byteFileStream = new byte[fileStream.Length]; fileStream.Read(byteFileStream, 0, (int)fileStream.Length); fileStream.Close(); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateEncryptor(), CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteFileStream, 0, byteFileStream.Length); cryptoStream.FlushFinalBlock(); fileStream = File.OpenWrite(strSaveFilePath); foreach (byte byteMemoryStream in memoryStream.ToArray()) &#123; fileStream.WriteByte(byteMemoryStream); &#125; fileStream.Close(); cryptoStream.Close(); memoryStream.Close(); return true; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件AES解密/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;被加密的文件路径&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;解密文件目录&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FileAESDecrypt(string strFilePath, string strSaveFilePath, string strKey)&#123; try &#123; strKey = strKey.Length &lt; 32 ? strKey.PadRight(32, '0') : strKey.Substring(0, 32); RijndaelManaged rijndaelManaged = new RijndaelManaged &#123; Key = Encoding.UTF8.GetBytes(strKey), Mode = CipherMode.ECB, Padding = PaddingMode.PKCS7 &#125;; FileStream fileStream = File.OpenRead(strFilePath); byte[] byteFileStream = new byte[fileStream.Length]; fileStream.Read(byteFileStream, 0, (int)fileStream.Length); fileStream.Close(); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, rijndaelManaged.CreateDecryptor(), CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteFileStream, 0, byteFileStream.Length); cryptoStream.FlushFinalBlock(); fileStream = File.OpenWrite(strSaveFilePath); foreach (byte byteMemoryStream in memoryStream.ToArray()) &#123; fileStream.WriteByte(byteMemoryStream); &#125; fileStream.Close(); cryptoStream.Close(); memoryStream.Close(); return true; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; DESDES 一种使用密钥加密的块算法,1977年被美国联邦政府的国家标准局确定为联邦资料处理标准（FIPS），并授权在非密级政府通信中使用。DESHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/// &lt;summary&gt;/// DES加密/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥(8位)&lt;/param&gt;/// &lt;param name="strIV"&gt;向量(8位)&lt;/param&gt;/// &lt;returns&gt;DES密文&lt;/returns&gt;public static string DESEncrypt(string strPlaintext, string strKey, string strIV)&#123; try &#123; DESCryptoServiceProvider desCrypto = new DESCryptoServiceProvider(); desCrypto.Key = UTF8Encoding.Default.GetBytes(strKey); desCrypto.IV = UTF8Encoding.UTF8.GetBytes(strIV); using (ICryptoTransform cryptoTransform = desCrypto.CreateEncryptor()) &#123; byte[] byteBaseUTF8 = Encoding.UTF8.GetBytes(strPlaintext); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteBaseUTF8, 0, byteBaseUTF8.Length); cryptoStream.FlushFinalBlock(); &#125; return Convert.ToBase64String(memoryStream.ToArray()); &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// DES解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;DES密文&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥(8位)&lt;/param&gt;/// &lt;param name="strIV"&gt;向量(8位)&lt;/param&gt;/// &lt;returns&gt;明文&lt;/returns&gt;public static string DESDecrypt(string strCiphertext, string strKey, string strIV)&#123; try &#123; DESCryptoServiceProvider desCrypto = new DESCryptoServiceProvider(); desCrypto.Key = UTF8Encoding.Default.GetBytes(strKey); desCrypto.IV = UTF8Encoding.UTF8.GetBytes(strIV); using (ICryptoTransform cryptoTransform = desCrypto.CreateDecryptor()) &#123; byte[] byteBase64 = Convert.FromBase64String(strCiphertext); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, cryptoTransform, CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteBase64, 0, byteBase64.Length); cryptoStream.FlushFinalBlock(); &#125; return Encoding.UTF8.GetString(memoryStream.ToArray()); &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 文件DES加密/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;加密文件目录&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥(8位)&lt;/param&gt;/// &lt;param name="strIV"&gt;向量(8位)&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FileDESEncrypt(string strFilePath, string strSaveFilePath, string strKey, string strIV)&#123; try &#123; DESCryptoServiceProvider desCrypto = new DESCryptoServiceProvider(); desCrypto.Key = UTF8Encoding.Default.GetBytes(strKey); desCrypto.IV = UTF8Encoding.UTF8.GetBytes(strIV); FileStream fileStream = File.OpenRead(strFilePath); byte[] byteFileStream = new byte[fileStream.Length]; fileStream.Read(byteFileStream, 0, (int)fileStream.Length); fileStream.Close(); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, desCrypto.CreateEncryptor(), CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteFileStream, 0, byteFileStream.Length); cryptoStream.FlushFinalBlock(); fileStream = File.OpenWrite(strSaveFilePath); foreach (byte byteMemoryStream in memoryStream.ToArray()) &#123; fileStream.WriteByte(byteMemoryStream); &#125; fileStream.Close(); cryptoStream.Close(); memoryStream.Close(); return true; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件DES解密/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;被加密的文件路径&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;解密文件目录&lt;/param&gt;/// &lt;param name="strKey"&gt;秘钥(8位)&lt;/param&gt;/// &lt;param name="strIV"&gt;向量(8位)&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FileDESDecrypt(string strFilePath, string strSaveFilePath, string strKey, string strIV)&#123; try &#123; DESCryptoServiceProvider desCrypto = new DESCryptoServiceProvider(); desCrypto.Key = UTF8Encoding.Default.GetBytes(strKey); desCrypto.IV = UTF8Encoding.UTF8.GetBytes(strIV); FileStream fileStream = File.OpenRead(strFilePath); byte[] byteFileStream = new byte[fileStream.Length]; fileStream.Read(byteFileStream, 0, (int)fileStream.Length); fileStream.Close(); using (var memoryStream = new MemoryStream()) &#123; using (var cryptoStream = new CryptoStream(memoryStream, desCrypto.CreateDecryptor(), CryptoStreamMode.Write)) &#123; cryptoStream.Write(byteFileStream, 0, byteFileStream.Length); cryptoStream.FlushFinalBlock(); fileStream = File.OpenWrite(strSaveFilePath); foreach (byte byteMemoryStream in memoryStream.ToArray()) &#123; fileStream.WriteByte(byteMemoryStream); &#125; fileStream.Close(); cryptoStream.Close(); memoryStream.Close(); return true; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; 非对称式加密非对称加密算法 需要两个密钥：公开密钥（publickey:简称公钥）和私有密钥（privatekey:简称私钥）。公钥与私钥是一对，如果用公钥对数据进行加密，只有用对应的私钥才能解密。 RSARSA 一种非对称加密算法。在公开密钥加密和电子商业中RSA被广泛使用。RSAHelper 只能使用产生出的密钥，且加密更加复杂所以只能加密短文本。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/// &lt;summary&gt;/// RSA产生秘钥/// &lt;/summary&gt;/// &lt;param name="xmlPublicKey"&gt;公钥&lt;/param&gt;/// &lt;param name="xmlPrivateKey"&gt;私钥&lt;/param&gt;public static void RSAKey(out string xmlPublicKey, out string xmlPrivateKey)&#123; try &#123; RSACryptoServiceProvider rsaCrypto = new RSACryptoServiceProvider(); xmlPublicKey = rsaCrypto.ToXmlString(false); xmlPrivateKey = rsaCrypto.ToXmlString(true); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); xmlPublicKey = string.Empty; xmlPrivateKey = string.Empty; &#125;&#125;/// &lt;summary&gt;/// RSA加密/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;param name="xmlPublicKey"&gt;公钥&lt;/param&gt;/// &lt;returns&gt;RSA密文&lt;/returns&gt;public static string RSAEncrypt(string strPlaintext, string xmlPublicKey)&#123; try &#123; RSACryptoServiceProvider rsaCrypto = new RSACryptoServiceProvider(); rsaCrypto.FromXmlString(xmlPublicKey); UnicodeEncoding unicodeEncoding = new UnicodeEncoding(); byte[] byteBaseUnicode = unicodeEncoding.GetBytes(strPlaintext); byte[] byteBaseEncrypt = rsaCrypto.Encrypt(byteBaseUnicode, false); string strRSAEncrypt = Convert.ToBase64String(byteBaseEncrypt); return strRSAEncrypt; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// RSA解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;RSA密文&lt;/param&gt;/// &lt;param name="xmlPrivateKey"&gt;私钥&lt;/param&gt;/// &lt;returns&gt;明文&lt;/returns&gt;public static string RSADecrypt(string strCiphertext, string xmlPrivateKey)&#123; try &#123; RSACryptoServiceProvider rsaCrypto = new RSACryptoServiceProvider(); rsaCrypto.FromXmlString(xmlPrivateKey); byte[] byteBase64 = Convert.FromBase64String(strCiphertext); byte[] byteBaseDecrypt = rsaCrypto.Decrypt(byteBase64, false); string strRSADecrypt = (new UnicodeEncoding()).GetString(byteBaseDecrypt); return strRSADecrypt; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125; 单项加密密码散列函数 一种单向函数，也就是说极其难以由散列函数输出的结果，回推输入的数据是什么。多用于文件效验完整性。 MD5MD5 一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value），用于确保信息传输完整一致。MD5Helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141/// &lt;summary&gt;/// MD5加密(16位小写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;MD5密文(16位小写)&lt;/returns&gt;public static string MD5Encrypt_16Lower(string strPlaintext)&#123; try &#123; MD5CryptoServiceProvider md5Crypto = new MD5CryptoServiceProvider(); string strCiphertext = BitConverter.ToString(md5Crypto.ComputeHash(UTF8Encoding.Default.GetBytes(strPlaintext)), 4, 8); strCiphertext = strCiphertext.Replace("-", ""); strCiphertext = strCiphertext.ToLower(); return strCiphertext; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// MD5加密(16位大写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;MD5密文(16位小写)&lt;/returns&gt;public static string MD5Encrypt_16Upper(string strPlaintext)&#123; try &#123; MD5CryptoServiceProvider md5Crypto = new MD5CryptoServiceProvider(); string strCiphertext = BitConverter.ToString(md5Crypto.ComputeHash(UTF8Encoding.Default.GetBytes(strPlaintext)), 4, 8); strCiphertext = strCiphertext.Replace("-", ""); strCiphertext = strCiphertext.ToUpper(); return strCiphertext; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// MD5加密(32位小写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;MD5密文(32位小写)&lt;/returns&gt;public static string MD5Encrypt_32Lower(string strPlaintext)&#123; try &#123; MD5CryptoServiceProvider md5Crypto = new MD5CryptoServiceProvider(); string strCiphertext = BitConverter.ToString(md5Crypto.ComputeHash(UTF8Encoding.Default.GetBytes(strPlaintext))); strCiphertext = strCiphertext.Replace("-", ""); strCiphertext = strCiphertext.ToLower(); return strCiphertext; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// MD5加密(32位大写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;MD5密文(32位小写)&lt;/returns&gt;public static string MD5Encrypt_32Upper(string strPlaintext)&#123; try &#123; MD5CryptoServiceProvider md5Crypto = new MD5CryptoServiceProvider(); string strCiphertext = BitConverter.ToString(md5Crypto.ComputeHash(UTF8Encoding.Default.GetBytes(strPlaintext))); strCiphertext = strCiphertext.Replace("-", ""); strCiphertext = strCiphertext.ToUpper(); return strCiphertext; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件MD5值(32位小写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件MD5值(32位小写)&lt;/returns&gt;public static string FileMD5Encrypt_32Lower(string strFilePath)&#123; try &#123; FileStream fileStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read); System.Security.Cryptography.MD5 md5 = new System.Security.Cryptography.MD5CryptoServiceProvider(); byte[] byteHash = md5.ComputeHash(fileStream); fileStream.Close(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; byteHash.Length; i++) &#123; stringBuilder.Append(byteHash[i].ToString("x2")); &#125; return stringBuilder.ToString(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件MD5值(32位大写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件MD5值(32位大写)&lt;/returns&gt;public static string FileMD5Encrypt_32Upper(string strFilePath)&#123; try &#123; FileStream fileStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read); System.Security.Cryptography.MD5 md5 = new System.Security.Cryptography.MD5CryptoServiceProvider(); byte[] byteHash = md5.ComputeHash(fileStream); fileStream.Close(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; byteHash.Length; i++) &#123; stringBuilder.Append(byteHash[i].ToString("X2")); &#125; return stringBuilder.ToString(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125; SHA1SHA1 安全哈希算法（Secure Hash Algorithm）主要适用于数字签名标准 （Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。SHA1Helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/// &lt;summary&gt;/// SHA1加密(40位小写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;SHA1密文(40位小写)&lt;/returns&gt;public static string SHA1Encrypt_40Lower(string strPlaintext)&#123; try &#123; System.Security.Cryptography.SHA1 sha1Crypto = new SHA1CryptoServiceProvider(); byte[] bytes_sha1_in = UTF8Encoding.Default.GetBytes(strPlaintext); byte[] bytes_sha1_out = sha1Crypto.ComputeHash(bytes_sha1_in); string str_sha1_out = BitConverter.ToString(bytes_sha1_out); str_sha1_out = str_sha1_out.Replace("-", ""); str_sha1_out = str_sha1_out.ToLower(); return str_sha1_out; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// SHA1加密(40位大写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;SHA1密文(40位大写)&lt;/returns&gt;public static string SHA1Encrypt_40Upper(string strPlaintext)&#123; try &#123; System.Security.Cryptography.SHA1 sha1Crypto = new SHA1CryptoServiceProvider(); byte[] bytes_sha1_in = UTF8Encoding.Default.GetBytes(strPlaintext); byte[] bytes_sha1_out = sha1Crypto.ComputeHash(bytes_sha1_in); string str_sha1_out = BitConverter.ToString(bytes_sha1_out); str_sha1_out = str_sha1_out.Replace("-", ""); str_sha1_out = str_sha1_out.ToUpper(); return str_sha1_out; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件SHA1值(40位小写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件SHA1值(40位小写)&lt;/returns&gt;public static string FileSHA1Encrypt_40Lower(string strFilePath)&#123; try &#123; FileStream fileStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read); System.Security.Cryptography.SHA1 sha1 = new SHA1CryptoServiceProvider(); byte[] byteHash = sha1.ComputeHash(fileStream); fileStream.Close(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; byteHash.Length; i++) &#123; stringBuilder.Append(byteHash[i].ToString("x2")); &#125; return stringBuilder.ToString(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件SHA1值(40位大写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件SHA1值(40位大写)&lt;/returns&gt;public static string FileSHA1Encrypt_40Upper(string strFilePath)&#123; try &#123; FileStream fileStream = new FileStream(strFilePath, FileMode.Open, FileAccess.Read); System.Security.Cryptography.SHA1 sha1 = new SHA1CryptoServiceProvider(); byte[] byteHash = sha1.ComputeHash(fileStream); fileStream.Close(); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; byteHash.Length; i++) &#123; stringBuilder.Append(byteHash[i].ToString("X2")); &#125; return stringBuilder.ToString(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125; CRC32CRC32 循环冗余校验。在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC是最著名的一种。CRC32Helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267/// &lt;summary&gt;/// CRC32加密(8位小写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;CRC32密文(8位小写)&lt;/returns&gt;public static string CRC32Encrypt_8Lower(string strPlaintext)&#123; try &#123; Crc32 crc32Crypto = new Crc32(); byte[] bytes_crc32_in = UTF8Encoding.Default.GetBytes(strPlaintext); byte[] bytes_crc32_out = crc32Crypto.ComputeHash(bytes_crc32_in); string str_crc32_out = BitConverter.ToString(bytes_crc32_out); str_crc32_out = str_crc32_out.Replace("-", ""); str_crc32_out = str_crc32_out.ToLower(); return str_crc32_out; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// CRC32加密(8位大写)/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;CRC32密文(8位大写)&lt;/returns&gt;public static string CRC32Encrypt_8Upper(string strPlaintext)&#123; try &#123; Crc32 crc32Crypto = new Crc32(); byte[] bytes_crc32_in = UTF8Encoding.Default.GetBytes(strPlaintext); byte[] bytes_crc32_out = crc32Crypto.ComputeHash(bytes_crc32_in); string str_crc32_out = BitConverter.ToString(bytes_crc32_out); str_crc32_out = str_crc32_out.Replace("-", ""); str_crc32_out = str_crc32_out.ToUpper(); return str_crc32_out; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件CRC32值(8位小写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件CRC32值(8位小写)&lt;/returns&gt;public static string FileCRC32Encrypt_8Lower(string strFilePath)&#123; try &#123; String hashCRC32 = String.Empty; //检查文件是否存在,如果文件存在则进行计算,否则返回空值 if (System.IO.File.Exists(strFilePath)) &#123; using (System.IO.FileStream fileStream = new System.IO.FileStream(strFilePath, System.IO.FileMode.Open, System.IO.FileAccess.Read)) &#123; //计算文件的CSC32值 Crc32 calculator = new Crc32(); Byte[] buffer = calculator.ComputeHash(fileStream); calculator.Clear(); //将字节数组转换成十六进制的字符串形式 StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; buffer.Length; i++) &#123; stringBuilder.Append(buffer[i].ToString("x2")); &#125; hashCRC32 = stringBuilder.ToString(); &#125; &#125; return hashCRC32; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 获取文件CRC32值(8位大写)/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件路径&lt;/param&gt;/// &lt;returns&gt;文件CRC32值(8位大写)&lt;/returns&gt;public static string FileCRC32Encrypt_8Upper(string strFilePath)&#123; try &#123; String hashCRC32 = String.Empty; //检查文件是否存在,如果文件存在则进行计算,否则返回空值 if (System.IO.File.Exists(strFilePath)) &#123; using (System.IO.FileStream fileStream = new System.IO.FileStream(strFilePath, System.IO.FileMode.Open, System.IO.FileAccess.Read)) &#123; //计算文件的CSC32值 Crc32 calculator = new Crc32(); Byte[] buffer = calculator.ComputeHash(fileStream); calculator.Clear(); //将字节数组转换成十六进制的字符串形式 StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i &lt; buffer.Length; i++) &#123; stringBuilder.Append(buffer[i].ToString("X2")); &#125; hashCRC32 = stringBuilder.ToString(); &#125; &#125; return hashCRC32; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 提供 CRC32 算法的实现/// &lt;/summary&gt;public class Crc32 : System.Security.Cryptography.HashAlgorithm&#123; /// &lt;summary&gt; /// Default Polynomial /// &lt;/summary&gt; public const UInt32 DefaultPolynomial = 0xedb88320; /// &lt;summary&gt; /// Default Seed /// &lt;/summary&gt; public const UInt32 DefaultSeed = 0xffffffff; private UInt32 hash; private UInt32 seed; private UInt32[] table; private static UInt32[] defaultTable; /// &lt;summary&gt; /// Crc32 /// &lt;/summary&gt; public Crc32() &#123; table = InitializeTable(DefaultPolynomial); seed = DefaultSeed; Initialize(); &#125; /// &lt;summary&gt; /// Crc32 /// &lt;/summary&gt; /// &lt;param name="polynomial"&gt;&lt;/param&gt; /// &lt;param name="seed"&gt;&lt;/param&gt; public Crc32(UInt32 polynomial, UInt32 seed) &#123; table = InitializeTable(polynomial); this.seed = seed; Initialize(); &#125; /// &lt;summary&gt; /// 初始化 /// &lt;/summary&gt; public override void Initialize() &#123; hash = seed; &#125; /// &lt;summary&gt; /// Hash Core /// &lt;/summary&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;param name="start"&gt;&lt;/param&gt; /// &lt;param name="length"&gt;&lt;/param&gt; protected override void HashCore(byte[] buffer, int start, int length) &#123; hash = CalculateHash(table, hash, buffer, start, length); &#125; /// &lt;summary&gt; /// Hash Final /// &lt;/summary&gt; /// &lt;returns&gt;&lt;/returns&gt; protected override byte[] HashFinal() &#123; byte[] hashBuffer = UInt32ToBigEndianBytes(~hash); this.HashValue = hashBuffer; return hashBuffer; &#125; /// &lt;summary&gt; /// Compute /// &lt;/summary&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static UInt32 Compute(byte[] buffer) &#123; return ~CalculateHash(InitializeTable(DefaultPolynomial), DefaultSeed, buffer, 0, buffer.Length); &#125; /// &lt;summary&gt; /// Compute /// &lt;/summary&gt; /// &lt;param name="seed"&gt;&lt;/param&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static UInt32 Compute(UInt32 seed, byte[] buffer) &#123; return ~CalculateHash(InitializeTable(DefaultPolynomial), seed, buffer, 0, buffer.Length); &#125; /// &lt;summary&gt; /// Compute /// &lt;/summary&gt; /// &lt;param name="polynomial"&gt;&lt;/param&gt; /// &lt;param name="seed"&gt;&lt;/param&gt; /// &lt;param name="buffer"&gt;&lt;/param&gt; /// &lt;returns&gt;&lt;/returns&gt; public static UInt32 Compute(UInt32 polynomial, UInt32 seed, byte[] buffer) &#123; return ~CalculateHash(InitializeTable(polynomial), seed, buffer, 0, buffer.Length); &#125; private static UInt32[] InitializeTable(UInt32 polynomial) &#123; if (polynomial == DefaultPolynomial &amp;&amp; defaultTable != null) &#123; return defaultTable; &#125; UInt32[] createTable = new UInt32[256]; for (int i = 0; i &lt; 256; i++) &#123; UInt32 entry = (UInt32)i; for (int j = 0; j &lt; 8; j++) &#123; if ((entry &amp; 1) == 1) entry = (entry &gt;&gt; 1) ^ polynomial; else entry = entry &gt;&gt; 1; &#125; createTable[i] = entry; &#125; if (polynomial == DefaultPolynomial) &#123; defaultTable = createTable; &#125; return createTable; &#125; private static UInt32 CalculateHash(UInt32[] table, UInt32 seed, byte[] buffer, int start, int size) &#123; UInt32 crc = seed; for (int i = start; i &lt; size; i++) &#123; unchecked &#123; crc = (crc &gt;&gt; 8) ^ table[buffer[i] ^ crc &amp; 0xff]; &#125; &#125; return crc; &#125; private byte[] UInt32ToBigEndianBytes(UInt32 x) &#123; return new byte[] &#123; (byte)((x &gt;&gt; 24) &amp; 0xff), (byte)((x &gt;&gt; 16) &amp; 0xff), (byte)((x &gt;&gt; 8) &amp; 0xff), (byte)(x &amp; 0xff) &#125;; &#125;&#125; 其它方式（Base64）Base64Base64 网络上最常见的用于传输8Bit字节码的编码方式之一，准确的来说Base64不属于加密范围，仅是一种基于64个可打印字符来表示二进制数据的方法。多用于图片传输使用。Base64Helper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157/// &lt;summary&gt;/// Base64加密/// &lt;/summary&gt;/// &lt;param name="strPlaintext"&gt;明文&lt;/param&gt;/// &lt;returns&gt;Base64密文&lt;/returns&gt;public static string Base64Encrypt(string strPlaintext)&#123; try &#123; byte[] bytes = Encoding.UTF8.GetBytes(strPlaintext); return Convert.ToBase64String(bytes); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// Base64解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;Base64密文&lt;/param&gt;/// &lt;returns&gt;明文&lt;/returns&gt;public static string Base64Decrypt(string strCiphertext)&#123; try &#123; byte[] bytes = Convert.FromBase64String(strCiphertext); return Encoding.UTF8.GetString(bytes); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 图片Base64加密/// &lt;/summary&gt;/// &lt;param name="strImagePath"&gt;图片路径&lt;/param&gt;/// &lt;param name="imageFormat"&gt;指定图像格式&lt;/param&gt;/// &lt;returns&gt;Base64密文&lt;/returns&gt;public static string ImageBase64Encrypt(string strImagePath, ImageFormat imageFormat)&#123; try &#123; MemoryStream memoryStream = new MemoryStream(); Bitmap bitmap = new Bitmap(strImagePath); if (imageFormat == null) &#123; imageFormat = GetImageFormatFromPath(strImagePath); &#125; bitmap.Save(memoryStream, imageFormat); byte[] bytes = memoryStream.GetBuffer(); return Convert.ToBase64String(bytes); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 图片Base64解密/// &lt;/summary&gt;/// &lt;param name="strCiphertext"&gt;Base64密文&lt;/param&gt;/// &lt;param name="strSaveFilePath"&gt;解密图片目录&lt;/param&gt;/// &lt;param name="imageFormat"&gt;指定图像格式&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool ImageBase64Decrypt(string strCiphertext, string strSaveFilePath, ImageFormat imageFormat)&#123; try &#123; byte[] bytes = Convert.FromBase64String(strCiphertext); MemoryStream memoryStream = new MemoryStream(bytes); Bitmap bitmap = new Bitmap(memoryStream); if (imageFormat == null) &#123; imageFormat = GetImageFormatFromPath(strSaveFilePath); &#125; bitmap.Save(strSaveFilePath, imageFormat); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 根据图片路径获得图片格式(缺少MemoryBmp)/// &lt;/summary&gt;/// &lt;param name="strImagePath"&gt;图片路径&lt;/param&gt;/// &lt;returns&gt;图片格式&lt;/returns&gt;public static ImageFormat GetImageFormatFromPath(string strImagePath)&#123; try &#123; string strImageExtension = Path.GetExtension(strImagePath).ToLower(); if (string.IsNullOrEmpty(strImageExtension)) &#123; return null; &#125; else &#123; if (strImageExtension.Equals(".bmp") || strImageExtension.Equals(".rle") || strImageExtension.Equals(".dlb")) &#123; return ImageFormat.Bmp; &#125; else if (strImageExtension.Equals(".emf")) &#123; return ImageFormat.Emf; &#125; else if (strImageExtension.Equals(".exif")) &#123; return ImageFormat.Exif; &#125; else if (strImageExtension.Equals(".gif")) &#123; return ImageFormat.Gif; &#125; else if (strImageExtension.Equals(".ico")) &#123; return ImageFormat.Icon; &#125; else if (strImageExtension.Equals(".jpg") || strImageExtension.Equals(".jpeg") || strImageExtension.Equals(".jpe")) &#123; return ImageFormat.Jpeg; &#125; else if (strImageExtension.Equals(".png") || strImageExtension.Equals(".pns")) &#123; return ImageFormat.Png; &#125; else if (strImageExtension.Equals(".tif") || strImageExtension.Equals(".tiff")) &#123; return ImageFormat.Tiff; &#125; else if (strImageExtension.Equals(".wmf")) &#123; return ImageFormat.Wmf; &#125; else &#123; return null; &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125; 文件夹加密起因是一个女性朋友提出的需求，大概是说不想自己电脑的文件夹被其他人打开，但是又不想加密文件，因为耗时会很久，只想加密文件夹。查过各种资料后没有找到更好的方法，暂且使用一种修改文件夹后缀名达到让电脑识别为控制面板或回收站等图标的方式，然后修改恢复文件夹的时候预设匹对一个设定好的密码文件，就可以达到加密解密文件夹的效果，但是理解原理的人是可以直接破解的，但是我相信理解这项技术的不多，并且不会对每一个系统图标虎视眈眈的。FolderHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/// &lt;summary&gt;/// 加密文件/// &lt;/summary&gt;public static string Lock = ".&#123;2559a1f2-21d7-11d4-bdaf-00c04f60b9f0&#125;";/// &lt;summary&gt;/// 控制面板/// &lt;/summary&gt;public static string Control = ".&#123;21EC2020-3AEA-1069-A2DD-08002B30309D&#125;";/// &lt;summary&gt;/// RunIE/// &lt;/summary&gt;public static string RunIE = ".&#123;2559a1f4-21d7-11d4-bdaf-00c04f60b9f0&#125;";/// &lt;summary&gt;/// 回收站/// &lt;/summary&gt;public static string Recycle = ".&#123;645FF040-5081-101B-9F08-00AA002F954E&#125;";/// &lt;summary&gt;/// Help/// &lt;/summary&gt;public static string Help = ".&#123;2559a1f1-21d7-11d4-bdaf-00c04f60b9f0&#125;";/// &lt;summary&gt;/// NetWork/// &lt;/summary&gt;public static string NetWork = ".&#123;7007ACC7-3202-11D1-AAD2-00805FC1270E&#125;";/// &lt;summary&gt;/// 文件夹加密(可破解)/// &lt;/summary&gt;/// &lt;param name="strFolderPath"&gt;文件夹路径&lt;/param&gt;/// &lt;param name="strClsid"&gt;Clsid类型&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FolderEncrypt(string strFolderPath, string strClsid)&#123; try &#123; DirectoryInfo directoryInfo = new DirectoryInfo(strFolderPath); directoryInfo.MoveTo(directoryInfo.Parent.FullName + "\\" + directoryInfo.Name + strClsid); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件夹解密/// 理论上可以解密所有该方法加密的文件夹/// &lt;/summary&gt;/// &lt;param name="strFolderPath"&gt;文件夹路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FolderDecrypt(string strFolderPath)&#123; try &#123; DirectoryInfo directoryInfo = new DirectoryInfo(strFolderPath); directoryInfo.MoveTo(strFolderPath.Substring(0, strFolderPath.LastIndexOf("."))); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件夹加密(带密码)(可破解)/// &lt;/summary&gt;/// &lt;param name="strFolderPath"&gt;文件夹路径&lt;/param&gt;/// &lt;param name="strClsid"&gt;Clsid类型&lt;/param&gt;/// &lt;param name="strPassword"&gt;加密密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FolderEncrypt(string strFolderPath, string strClsid, string strPassword)&#123; try &#123; DirectoryInfo directoryInfo = new DirectoryInfo(strFolderPath); XmlDocument xmlDocument = new XmlDocument(); XmlNode xmlNode = xmlDocument.CreateNode(XmlNodeType.XmlDeclaration, "", ""); xmlDocument.AppendChild(xmlNode); XmlElement xmlElement = xmlDocument.CreateElement("", "ROOT", ""); XmlText xmlText = xmlDocument.CreateTextNode(strPassword); xmlElement.AppendChild(xmlText); xmlDocument.AppendChild(xmlElement); xmlDocument.Save(strFolderPath + "\\Lock.xml"); directoryInfo.MoveTo(directoryInfo.Parent.FullName + "\\" + directoryInfo.Name + strClsid); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 文件夹解密(带密码)/// &lt;/summary&gt;/// &lt;param name="strFolderPath"&gt;文件夹路径&lt;/param&gt;/// &lt;param name="strPassword"&gt;加密密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool FolderDecrypt(string strFolderPath, string strPassword)&#123; try &#123; DirectoryInfo directoryInfo = new DirectoryInfo(strFolderPath); bool bIsPassword = false; XmlTextReader xmlTextReader = new XmlTextReader(strFolderPath + "\\Lock.xml"); while (xmlTextReader.Read()) &#123; if (xmlTextReader.NodeType == XmlNodeType.Text) &#123; if (xmlTextReader.Value == strPassword) &#123; bIsPassword = true; break; &#125; &#125; &#125; xmlTextReader.Close(); if (bIsPassword) &#123; File.Delete(strFolderPath + "\\Lock.xml"); directoryInfo.MoveTo(strFolderPath.Substring(0, strFolderPath.LastIndexOf("."))); return true; &#125; else &#123; return false; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>aes</tag>
        <tag>base64</tag>
        <tag>crc32</tag>
        <tag>des</tag>
        <tag>folder</tag>
        <tag>md5</tag>
        <tag>rsa</tag>
        <tag>sha1</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows任务计划帮助类]]></title>
    <url>%2Fblog%2F2017%2F09%2F18%2Fcsharp-TaskschdHelper%2F</url>
    <content type="text"><![CDATA[基于 TaskScheduler 库操作Windows任务计划帮助类 简介任务计划 可以将任何脚本、程序或文档安排在某个最方便的时间运行。常见于系统开机自启动程序，或定期运行自动更新程序或守护程序。 帮助类TaskschdHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/// &lt;summary&gt;/// 创建任务计划/// &lt;/summary&gt;/// &lt;param name="strCreator"&gt;作者&lt;/param&gt;/// &lt;param name="strTaskName"&gt;任务名称&lt;/param&gt;/// &lt;param name="strPath"&gt;任务计划路径&lt;/param&gt;/// &lt;param name="strInterval"&gt;任务触发时间(PT1M:1分钟,PT1H30M:90分钟)&lt;/param&gt;/// &lt;param name="strStartBoundary"&gt;任务开始时间(yyyy-MM-ddTHH:mm:ss)&lt;/param&gt;/// &lt;param name="strDescription"&gt;任务描述&lt;/param&gt;/// &lt;returns&gt;任务状态&lt;/returns&gt;public static bool CreateTaskschd(string strCreator, string strTaskName, string strPath, string strInterval, string strStartBoundary, string strDescription)&#123; try &#123; if (IsExists(strTaskName)) &#123; DeleteTaskschd(strTaskName); &#125; //new scheduler TaskSchedulerClass scheduler = new TaskSchedulerClass(); //pc-name/ip,username,domain,password scheduler.Connect(null, null, null, null); //get scheduler folder ITaskFolder folder = scheduler.GetFolder("\\"); //set base attr ITaskDefinition task = scheduler.NewTask(0); task.RegistrationInfo.Author = strCreator;//creator task.RegistrationInfo.Description = strDescription;//description //set trigger (IDailyTrigger ITimeTrigger) ITimeTrigger tt = (ITimeTrigger)task.Triggers.Create(_TASK_TRIGGER_TYPE2.TASK_TRIGGER_TIME); tt.Repetition.Interval = strInterval;// format PT1H1M==1小时1分钟 设置的值最终都会转成分钟加入到触发器 tt.StartBoundary = strStartBoundary;//start time //set action IExecAction action = (IExecAction)task.Actions.Create(_TASK_ACTION_TYPE.TASK_ACTION_EXEC); action.Path = strPath;//计划任务调用的程序路径 task.Settings.ExecutionTimeLimit = "PT0S"; //运行任务时间超时停止任务吗? PTOS 不开启超时 task.Settings.DisallowStartIfOnBatteries = false;//只有在交流电源下才执行 task.Settings.RunOnlyIfIdle = false;//仅当计算机空闲下才执行 IRegisteredTask regTask = folder.RegisterTaskDefinition(strTaskName, task, (int)_TASK_CREATION.TASK_CREATE, null, //user null, //password _TASK_LOGON_TYPE.TASK_LOGON_INTERACTIVE_TOKEN, ""); IRunningTask runTask = regTask.Run(null); //return runTask.State; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); //return _TASK_STATE.TASK_STATE_UNKNOWN; return false; &#125;&#125;/// &lt;summary&gt;/// 删除任务计划/// &lt;/summary&gt;/// &lt;param name="strTaskName"&gt;任务计划名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteTaskschd(string strTaskName)&#123; try &#123; TaskSchedulerClass taskScheduler = new TaskSchedulerClass(); taskScheduler.Connect(null, null, null, null); ITaskFolder taskFolder = taskScheduler.GetFolder("\\"); taskFolder.DeleteTask(strTaskName, 0); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 获得所有任务计划/// &lt;/summary&gt;/// &lt;returns&gt;所有任务计划&lt;/returns&gt;public static IRegisteredTaskCollection GetAllTaskschd()&#123; try &#123; TaskSchedulerClass taskScheduler = new TaskSchedulerClass(); taskScheduler.Connect(null, null, null, null); ITaskFolder taskFolder = taskScheduler.GetFolder("\\"); IRegisteredTaskCollection tasks_exists = taskFolder.GetTasks(1); return tasks_exists; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 任务计划是否存在/// &lt;/summary&gt;/// &lt;param name="strTaskName"&gt;任务计划名称&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static bool IsExists(string strTaskName)&#123; try &#123; bool isExists = false; IRegisteredTaskCollection tasks_exists = GetAllTaskschd(); for (int i = 1; i &lt;= tasks_exists.Count; i++) &#123; IRegisteredTask registeredTask = tasks_exists[i]; if (registeredTask.Name.Equals(strTaskName)) &#123; isExists = true; break; &#125; &#125; return isExists; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
        <tag>taskschd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VisualSVN 使用介绍]]></title>
    <url>%2Fblog%2F2017%2F08%2F20%2Fsoftware-VisualSVN%2F</url>
    <content type="text"><![CDATA[使用 SVN 作为版本管理工具 简介SVN 是一个开放源代码的版本控制系统，现大部分公司还是使用SVN作为代码托管服务，我曾经提议公司将版本控制替换为 GIT，但是项目经理有考虑员工学习成本，最后没有使用。 部署服务端（VisualSVN Server）VisualSVN Server 使Subversion服务器在Windows上安装和管理变得简单方便。下载地址 安装即可。 设置创建成员 创建项目库 设置项目名 设置项目结构 设置项目访问权限 设置项目成员 客户端连接TortoiseSVN 是一个Apache ™ Subversion（SVN）&reg;客户端，实现为Windows外壳扩展。它直观且易于使用，因为它不需要Subversion命令行客户端运行。下载地址 安装即可。右键 SVN Checkout… 连接项目库]]></content>
      <categories>
        <category>Software</category>
      </categories>
      <tags>
        <tag>software</tag>
        <tag>svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows注册表帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F22%2Fcsharp-RegistryHelper%2F</url>
    <content type="text"><![CDATA[基于 Microsoft.Win32 库操作Windows注册表帮助类 简介注册表（Registry） 作为Windows操作系统中的一个核心数据库，用于存储系统和应用程序的设置信息。修改常见的功能有：软件启动项、系统级菜单、文件默认启动程序及默认图标。常见的修改方式有Windows自带的命令regedit进入图形界面修改，或者熟悉批处理脚本（.bat）的朋友可以更方便的修改。 帮助类RegistryHelper 引用 Microsoft.Win32 库。 设置软件启动项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#region Registry Startup Items/// &lt;summary&gt;/// 创建注册表启动项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动项软件路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateStartupItems(string strName, string strSoftwarePath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.CurrentUser.CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run"); &#125; registryKey.SetValue(strName, strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表启动项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteStartupItems(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteValue(strName, false); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 获得注册表中所有启动项/// &lt;/summary&gt;/// &lt;returns&gt;注册表中启动项(键值,启动路径)&lt;/returns&gt;public static Dictionary&lt;string, string&gt; GetAllStartupItems()&#123; try &#123; Dictionary&lt;string, string&gt; dicAllStartupItems = new Dictionary&lt;string, string&gt;(); RegistryKey registryKey = null; //获取HKEY_CURRENT_USER中的启动项 registryKey = Microsoft.Win32.Registry.CurrentUser.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true); if (registryKey != null) &#123; foreach (string strValeName in registryKey.GetValueNames()) &#123; if (!dicAllStartupItems.ContainsKey(strValeName)) &#123; dicAllStartupItems.Add(strValeName, registryKey.GetValue(strValeName).ToString()); &#125; &#125; &#125; //获取HKEY_LOCAL_MACHINE中的启动项 registryKey = Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Run", true); if (registryKey != null) &#123; foreach (string strValeName in registryKey.GetValueNames()) &#123; if (!dicAllStartupItems.ContainsKey(strValeName)) &#123; dicAllStartupItems.Add(strValeName, registryKey.GetValue(strValeName).ToString()); &#125; &#125; &#125; return dicAllStartupItems; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;#endregion 设置系统右键菜单桌面右键菜单项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#region 注册表桌面右键菜单项/// &lt;summary&gt;/// 创建注册表桌面右键菜单项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateDesktopRightClickMenu(string strName, string strDisplayName, string strSoftwarePath, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Directory\Background\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Directory\Background\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Directory\Background\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Directory\Background\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 创建注册表桌面右键菜单项(二级菜单)(WIN7-X64下测试通过)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;一级菜单键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;一级菜单右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;一级菜单右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;param name="listSecondaryMenu"&gt;二级菜单配置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateDesktopRightClickMenu2(string strName, string strDisplayName, string strIcoPath, List&lt;SecondaryMenuModel&gt; listSecondaryMenu)&#123; try &#123; if (string.IsNullOrEmpty(strName) || listSecondaryMenu.Count &lt; 1) &#123; return false; &#125; //创建一级菜单 RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Directory\Background\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Directory\Background\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; //创建二级菜单 foreach (SecondaryMenuModel vSecondaryMenu in listSecondaryMenu) &#123; string strName2 = vSecondaryMenu.strSecondaryMenuName; string strDisplayName2 = vSecondaryMenu.strDisplayName; string strSoftwarePath2 = vSecondaryMenu.strSoftwarePath; string strIcoPath2 = vSecondaryMenu.strIcoPath; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2, true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2); &#125; if (!string.IsNullOrEmpty(strDisplayName2)) &#123; registryKey.SetValue("", strDisplayName2); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath2)) &#123; registryKey.SetValue("icon", strIcoPath2); &#125; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command", true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath2); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表桌面右键菜单项(二级菜单只删除一级菜单)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteDesktopRightClickMenu(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Directory\Background\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 文件夹右键菜单项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#region 注册表文件夹右键菜单项/// &lt;summary&gt;/// 创建注册表文件夹右键菜单项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateFolderRightClickMenu(string strName, string strDisplayName, string strSoftwarePath, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Folder\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Folder\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Folder\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Folder\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 创建注册表文件夹右键菜单项(二级菜单)(WIN7-X64下测试通过)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;一级菜单键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;一级菜单右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;一级菜单右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;param name="listSecondaryMenu"&gt;二级菜单配置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateFolderRightClickMenu2(string strName, string strDisplayName, string strIcoPath, List&lt;SecondaryMenuModel&gt; listSecondaryMenu)&#123; try &#123; if (string.IsNullOrEmpty(strName) || listSecondaryMenu.Count &lt; 1) &#123; return false; &#125; //创建一级菜单 RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Folder\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"Folder\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; //创建二级菜单 foreach (SecondaryMenuModel vSecondaryMenu in listSecondaryMenu) &#123; string strName2 = vSecondaryMenu.strSecondaryMenuName; string strDisplayName2 = vSecondaryMenu.strDisplayName; string strSoftwarePath2 = vSecondaryMenu.strSoftwarePath; string strIcoPath2 = vSecondaryMenu.strIcoPath; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2, true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2); &#125; if (!string.IsNullOrEmpty(strDisplayName2)) &#123; registryKey.SetValue("", strDisplayName2); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath2)) &#123; registryKey.SetValue("icon", strIcoPath2); &#125; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command", true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath2); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表文件夹右键菜单项(二级菜单只删除一级菜单)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteFolderRightClickMenu(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"Folder\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 文件右键菜单项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159#region 注册表文件右键菜单项/// &lt;summary&gt;/// 创建注册表文件右键菜单项/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateFileRightClickMenu(string strName, string strDisplayName, string strSoftwarePath, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"*\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"*\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"*\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"*\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 创建注册表文件右键菜单项(二级菜单)(WIN7-X64下测试通过)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;一级菜单键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;一级菜单右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;一级菜单右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;param name="listSecondaryMenu"&gt;二级菜单配置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateFileRightClickMenu2(string strName, string strDisplayName, string strIcoPath, List&lt;SecondaryMenuModel&gt; listSecondaryMenu)&#123; try &#123; if (string.IsNullOrEmpty(strName) || listSecondaryMenu.Count &lt; 1) &#123; return false; &#125; //创建一级菜单 RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"*\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(@"*\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; //创建二级菜单 foreach (SecondaryMenuModel vSecondaryMenu in listSecondaryMenu) &#123; string strName2 = vSecondaryMenu.strSecondaryMenuName; string strDisplayName2 = vSecondaryMenu.strDisplayName; string strSoftwarePath2 = vSecondaryMenu.strSoftwarePath; string strIcoPath2 = vSecondaryMenu.strIcoPath; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2, true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2); &#125; if (!string.IsNullOrEmpty(strDisplayName2)) &#123; registryKey.SetValue("", strDisplayName2); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath2)) &#123; registryKey.SetValue("icon", strIcoPath2); &#125; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command", true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath2); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表文件右键菜单项(二级菜单只删除一级菜单)/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteFileRightClickMenu(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(@"*\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 特定文件右键菜单项123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258#region 注册表特定文件右键菜单项/// &lt;summary&gt;/// 创建注册表特定文件右键菜单项/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateSpecificFileRightClickMenu(string strFileType, string strName, string strDisplayName, string strSoftwarePath, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType); &#125; //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\shell\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\" + strName + @"\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\shell\" + strName + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 创建注册表特定文件右键菜单项(二级菜单)(WIN7-X64下测试通过)/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strName"&gt;一级菜单键值名称&lt;/param&gt;/// &lt;param name="strDisplayName"&gt;一级菜单右键菜单显示名称,如果为空显示键值名称&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;一级菜单右键菜单图片路径,如果为空则不显示图片&lt;/param&gt;/// &lt;param name="listSecondaryMenu"&gt;二级菜单配置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateSpecificFileRightClickMenu2(string strFileType, string strName, string strDisplayName, string strIcoPath, List&lt;SecondaryMenuModel&gt; listSecondaryMenu)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strName) || listSecondaryMenu.Count &lt; 1) &#123; return false; &#125; //创建一级菜单 RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType); &#125; //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\shell\\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\\" + strName, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\shell\\" + strName); &#125; if (!string.IsNullOrEmpty(strDisplayName)) &#123; registryKey.SetValue("MUIVerb", strDisplayName); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath)) &#123; registryKey.SetValue("icon", strIcoPath); &#125; string strSecondaryMenuName = string.Empty; for (int iSecondaryMenu = 0; iSecondaryMenu &lt; listSecondaryMenu.Count; iSecondaryMenu++) &#123; if (iSecondaryMenu &lt; listSecondaryMenu.Count - 1) &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; strSecondaryMenuName += ';'; &#125; else &#123; strSecondaryMenuName += listSecondaryMenu[iSecondaryMenu].strSecondaryMenuName; &#125; &#125; if (!string.IsNullOrEmpty(strSecondaryMenuName)) &#123; registryKey.SetValue("SubCommands", strSecondaryMenuName); &#125; &#125; //创建二级菜单 foreach (SecondaryMenuModel vSecondaryMenu in listSecondaryMenu) &#123; string strName2 = vSecondaryMenu.strSecondaryMenuName; string strDisplayName2 = vSecondaryMenu.strDisplayName; string strSoftwarePath2 = vSecondaryMenu.strSoftwarePath; string strIcoPath2 = vSecondaryMenu.strIcoPath; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2, true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2); &#125; if (!string.IsNullOrEmpty(strDisplayName2)) &#123; registryKey.SetValue("", strDisplayName2); &#125; if (!string.IsNullOrEmpty(strIcoPath) &amp;&amp; File.Exists(strIcoPath2)) &#123; registryKey.SetValue("icon", strIcoPath2); &#125; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command", true); if (registryKey == null) &#123; registryKey = RegistryKey.OpenBaseKey(RegistryHive.LocalMachine, Environment.Is64BitOperatingSystem ? RegistryView.Registry64 : RegistryView.Registry32).CreateSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\CommandStore\shell\" + strName2 + @"\command"); &#125; registryKey.SetValue("", strSoftwarePath2); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除注册表特定文件右键菜单项(二级菜单只删除一级菜单)/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteSpecificFileRightClickMenu(string strFileType, string strName)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\", true); if (registryKey == null) &#123; return false; &#125; registryKey.DeleteSubKeyTree(strName); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 设置系统特定文件后缀默认图标12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#region Registry Default Icon/// &lt;summary&gt;/// 修改特定后缀文件默认图标(需重启电脑)/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strIcoPath"&gt;替换图片路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool ModifyDefaultIcon(string strFileType, string strIcoPath)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strIcoPath) || !File.Exists(strIcoPath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType); &#125; //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\DefaultIcon\", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\DefaultIcon\"); &#125; if (!string.IsNullOrEmpty(strIcoPath)) &#123; registryKey.SetValue("", strIcoPath); &#125; &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\DefaultIcon\", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\DefaultIcon\"); &#125; if (!string.IsNullOrEmpty(strIcoPath)) &#123; registryKey.SetValue("", strIcoPath); &#125; &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 设置系统特定后缀文件默认程序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#region Registry Default Programs/// &lt;summary&gt;/// 修改特定后缀文件默认程序/// &lt;/summary&gt;/// &lt;param name="strFileType"&gt;特定文件类型(例:.txt|.exe)&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;替换程序路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool ModifyDefaultPrograms(string strFileType, string strSoftwarePath)&#123; try &#123; if (string.IsNullOrEmpty(strFileType) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType, true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType); &#125; //获取(默认)中的数据 string strDefault = registryKey.ValueCount &gt;= 1 ? registryKey.GetValue("").ToString() : string.Empty; if (string.IsNullOrEmpty(strDefault)) &#123; //如果该后缀名里(默认)没有值,则创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strFileType + @"\shell\open\command\", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strFileType + @"\shell\open\command\"); &#125; if (!string.IsNullOrEmpty(strSoftwarePath)) &#123; registryKey.SetValue("", strSoftwarePath); &#125; &#125; else &#123; //如果该后缀名里(默认)存在值,读取值所在的路径创建shell写入菜单功能 registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strDefault + @"\shell\open\command\", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strDefault + @"\shell\open\command\"); &#125; if (!string.IsNullOrEmpty(strSoftwarePath)) &#123; registryKey.SetValue("", strSoftwarePath); &#125; &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion 创建 URL Protocol 协议,通过网页打开本地应用由于公司业务需求，制作单点登录功能，该方法作为比较常见的一种，安装C/S端软件时写入注册表，B/S程序通过A标签即可打开C/S端程序并且自动登录B/S的用户名密码。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#region Registry URL Protocol/// &lt;summary&gt;/// 创建 URL Protocol 协议,通过网页打开本地应用/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;param name="strSoftwarePath"&gt;启动软件路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CreateURLProtocol(string strName, string strSoftwarePath)&#123; try &#123; if (string.IsNullOrEmpty(strName) || string.IsNullOrEmpty(strSoftwarePath)) &#123; return false; &#125; //Web端调用方法:&lt;a href="strName://"%1"参数&gt;URL Protocol&lt;/a&gt; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strName + @"\shell\open\command", true); if (registryKey == null) &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot.CreateSubKey(strName + @"\shell\open\command"); &#125; registryKey.SetValue("", strSoftwarePath); registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除 URL Protocol 协议/// &lt;/summary&gt;/// &lt;param name="strName"&gt;键值名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteURLProtocol(string strName)&#123; try &#123; if (string.IsNullOrEmpty(strName)) &#123; return false; &#125; RegistryKey registryKey = Microsoft.Win32.Registry.ClassesRoot.OpenSubKey(strName, true); if (registryKey == null) &#123; return false; &#125; else &#123; registryKey = Microsoft.Win32.Registry.ClassesRoot; registryKey.DeleteSubKeyTree(strName); &#125; registryKey.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;#endregion]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSV文件帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F21%2Fcsharp-CSVHelper%2F</url>
    <content type="text"><![CDATA[操作 CSV 文件帮助类 简介工作中用户提供 CSV 文件作为参考数据使用，需要读取到系统中进行相关计算CSV（逗号分隔值文件格式）其文件以纯文本形式存储表格数据，分隔字符也可以不是逗号，可用Excel编辑的表格文件。CSVHelper 帮助类主要提供内存表格DataTable互相转换，以正则表达式与截取拼接。 CSV文件操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216/// &lt;summary&gt;/// DataTable转换为CSV/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;CSV文件路径&lt;/param&gt;/// &lt;param name="dtSourceData"&gt;DataTable数据&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DataTableConversionCSV(string strSource, DataTable dtSourceData)&#123; try &#123; if (string.IsNullOrEmpty(strSource) || dtSourceData.Rows.Count &lt; 1) &#123; return false; &#125; FileStream fileStream = new FileStream(Path.ChangeExtension(strSource, "csv"), FileMode.Create); StreamWriter streamWriter = new StreamWriter(fileStream); //记录当前读取到的一行数据 string strRowOfData = string.Empty; //循环保存列名 for (int iColumnsName = 0; iColumnsName &lt; dtSourceData.Columns.Count; iColumnsName++) &#123; strRowOfData += string.Format("&#123;0&#125;&#123;1&#125;&#123;0&#125;", "\"", dtSourceData.Columns[iColumnsName].ColumnName.ToString()); if (iColumnsName &lt; dtSourceData.Columns.Count - 1) &#123; strRowOfData += ","; &#125; &#125; streamWriter.WriteLine(strRowOfData); //循环保存数据 for (int iRow = 0; iRow &lt; dtSourceData.Rows.Count; iRow++) &#123; strRowOfData = string.Empty; for (int iColumns = 0; iColumns &lt; dtSourceData.Columns.Count; iColumns++) &#123; strRowOfData += string.Format("&#123;0&#125;&#123;1&#125;&#123;0&#125;", "\"", dtSourceData.Rows[iRow][iColumns].ToString()); if (iColumns &lt; dtSourceData.Columns.Count - 1) &#123; strRowOfData += ","; &#125; &#125; streamWriter.WriteLine(strRowOfData); &#125; streamWriter.Close(); fileStream.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// CSV转换为DataTable(默认 UTF8 编码)/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;CSV文件路径&lt;/param&gt;/// &lt;returns&gt;成功返回CSV的DataTable,失败返回NULL&lt;/returns&gt;public static DataTable CSVConversionDataTable(string strSource)&#123; try &#123; if (string.IsNullOrEmpty(strSource) || !File.Exists(strSource)) &#123; return null; &#125; DataTable dtTargetData = new DataTable(); //初始化 System.IO.FileStream 类的新实例 FileStream fileStreamOpen = new FileStream(strSource, FileMode.Open, FileAccess.Read); //从当前流中读取一行字符并将数据作为字符串返回 StreamReader streamReader = new StreamReader(fileStreamOpen, Encoding.UTF8); //记录当前读取到的一行数据 string strRowOfData; //记录当前是否为标题行 bool boolIsFirst = true; //循环获得CSV文件数据 while ((strRowOfData = streamReader.ReadLine()) != null) &#123; //从当前 System.String 对象中移除所有前导和尾随空白字符 strRowOfData.Trim(); //替换两遍连续两个 ,, 为 ,"",(希望数据里不存在两个逗号相连的情况) strRowOfData = strRowOfData.Replace(",,", ",\"\","); strRowOfData = strRowOfData.Replace(",,", ",\"\","); //如果截取第一个字符是 ',' 则在最前面加双引号 if (strRowOfData.Substring(0, 1) == ",") &#123; strRowOfData = string.Format("\"\"&#123;0&#125;", strRowOfData); &#125; //根据CSV规则分割字符串 string strRegexCSV = string.Format("[^\",]+|\"(?:[^\"]|\"\")*\""); Regex regexCSV = new Regex(strRegexCSV); MatchCollection matchCollection = regexCSV.Matches(strRowOfData); //判断是否为标题行 if (boolIsFirst) &#123; foreach (Match mColumnValue in matchCollection) &#123; dtTargetData.Columns.Add(InterceptionQuotes(mColumnValue.Value)); &#125; boolIsFirst = false; &#125; else &#123; DataRow drTargetData = dtTargetData.NewRow(); for (int iColumn = 0; iColumn &lt; dtTargetData.Columns.Count &amp;&amp; iColumn &lt; matchCollection.Count; iColumn++) &#123; drTargetData[iColumn] = InterceptionQuotes(matchCollection[iColumn].Value); &#125; dtTargetData.Rows.Add(drTargetData); &#125; &#125; streamReader.Close(); fileStreamOpen.Close(); return dtTargetData; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// CSV转换为DataTable/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;CSV文件路径&lt;/param&gt;/// &lt;param name="encoding"&gt;The character encoding to use.&lt;/param&gt;/// &lt;returns&gt;成功返回CSV的DataTable,失败返回NULL&lt;/returns&gt;public static DataTable CSVConversionDataTable(string strSource, Encoding encoding)&#123; try &#123; if (string.IsNullOrEmpty(strSource) || !File.Exists(strSource)) &#123; return null; &#125; DataTable dtTargetData = new DataTable(); //初始化 System.IO.FileStream 类的新实例 FileStream fileStreamOpen = new FileStream(strSource, FileMode.Open, FileAccess.Read); //从当前流中读取一行字符并将数据作为字符串返回 StreamReader streamReader = new StreamReader(fileStreamOpen, encoding); //记录当前读取到的一行数据 string strRowOfData; //记录当前是否为标题行 bool boolIsFirst = true; //循环获得CSV文件数据 while ((strRowOfData = streamReader.ReadLine()) != null) &#123; //从当前 System.String 对象中移除所有前导和尾随空白字符 strRowOfData.Trim(); //替换两遍连续两个 ,, 为 ,"",(希望数据里不存在两个逗号相连的情况) strRowOfData = strRowOfData.Replace(",,", ",\"\","); strRowOfData = strRowOfData.Replace(",,", ",\"\","); //如果截取第一个字符是 ',' 则在最前面加双引号 if (strRowOfData.Substring(0, 1) == ",") &#123; strRowOfData = string.Format("\"\"&#123;0&#125;", strRowOfData); &#125; //根据CSV规则分割字符串 string strRegexCSV = string.Format("[^\",]+|\"(?:[^\"]|\"\")*\""); Regex regexCSV = new Regex(strRegexCSV); MatchCollection matchCollection = regexCSV.Matches(strRowOfData); //判断是否为标题行 if (boolIsFirst) &#123; foreach (Match mColumnValue in matchCollection) &#123; dtTargetData.Columns.Add(InterceptionQuotes(mColumnValue.Value)); &#125; boolIsFirst = false; &#125; else &#123; DataRow drTargetData = dtTargetData.NewRow(); for (int iColumn = 0; iColumn &lt; dtTargetData.Columns.Count &amp;&amp; iColumn &lt; matchCollection.Count; iColumn++) &#123; drTargetData[iColumn] = InterceptionQuotes(matchCollection[iColumn].Value); &#125; dtTargetData.Rows.Add(drTargetData); &#125; &#125; streamReader.Close(); fileStreamOpen.Close(); return dtTargetData; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 截取字符串前后双引号/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;源字符串&lt;/param&gt;/// &lt;returns&gt;截取后字符串&lt;/returns&gt;private static string InterceptionQuotes(string strSource)&#123; try &#123; if (strSource[0] == '\"' &amp;&amp; strSource[strSource.Length - 1] == '\"') &#123; return strSource.Substring(1, strSource.Length - 2); &#125; else &#123; return strSource; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>csv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows屏幕截图帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F21%2Fcsharp-ScreenshotHelper%2F</url>
    <content type="text"><![CDATA[截取Windows屏幕全屏或指定区域帮助类 简介平时习惯于用QQ截图，但是公司一台电脑没有外网链接，登录不了QQ截图就很麻烦，通常是按PrtSc键截取全屏幕，然后在粘贴在Windows自带的画图应用中截取区域。原本计划自己实现一个仿制QQ截图（画笔、框选、编辑文字、提取颜色）的功能，但是一直也没有付诸行动，但是需要用到的技术栈都已经整理。屏幕录像的原理也是按照固定的FPS写入视频流，但是实际测试截取速度比较慢，无法稳定在30FPS以上。 帮助类ScreenshotHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/// &lt;summary&gt;/// 全屏幕截图/// &lt;/summary&gt;/// &lt;returns&gt;截图Bitmap&lt;/returns&gt;public static Bitmap ScreenshotFullScreen()&#123; try &#123; //得到屏幕整体宽度 double dPrimaryScreenWidth = SystemParameters.PrimaryScreenWidth; //得到屏幕整体高度 double dPrimaryScreenHeight = SystemParameters.PrimaryScreenHeight; //初始化使用指定的大小(屏幕大小)的 System.Drawing.Bitmap 类的新实例. Bitmap bitmapScreenshot = new Bitmap((int)dPrimaryScreenWidth, (int)dPrimaryScreenHeight); //从指定的载入原创建新的 System.Drawing.Graphics. Graphics graphicsScreenshot = Graphics.FromImage(bitmapScreenshot); //获取或设置绘制到此 System.Drawing.Graphics 的渲染质量:高质量 低速度合成. graphicsScreenshot.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality; //截取电脑屏幕:从屏幕到 System.Drawing.Graphics 的绘图图面. graphicsScreenshot.CopyFromScreen((int)0, (int)0, (int)0, (int)0, new System.Drawing.Size((int)dPrimaryScreenWidth, (int)dPrimaryScreenHeight)); return bitmapScreenshot; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 截取指定位置截图/// &lt;/summary&gt;/// &lt;param name="iStartX"&gt;截取起始坐标X&lt;/param&gt;/// &lt;param name="iStartY"&gt;截取起始坐标Y&lt;/param&gt;/// &lt;param name="iInterceptWidth"&gt;截取宽度&lt;/param&gt;/// &lt;param name="iInterceptHeight"&gt;截取高度&lt;/param&gt;/// &lt;returns&gt;截图Bitmap&lt;/returns&gt;public static Bitmap ScreenshotsSpecifyLocation(int iStartX, int iStartY, int iInterceptWidth, int iInterceptHeight)&#123; try &#123; //初始化使用指定的大小(屏幕大小)的 System.Drawing.Bitmap 类的新实例. Bitmap bitmapScreenshot = new Bitmap((int)iInterceptWidth, (int)iInterceptHeight); //从指定的载入原创建新的 System.Drawing.Graphics. Graphics graphicsScreenshot = Graphics.FromImage(bitmapScreenshot); //获取或设置绘制到此 System.Drawing.Graphics 的渲染质量:高质量 低速度合成. graphicsScreenshot.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality; //截取电脑屏幕:从屏幕到 System.Drawing.Graphics 的绘图图面. graphicsScreenshot.CopyFromScreen(iStartX, iStartY, (int)0, (int)0, new System.Drawing.Size((int)iInterceptWidth, (int)iInterceptHeight)); return bitmapScreenshot; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二维码帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F06%2Fcsharp-QRCodeHelper%2F</url>
    <content type="text"><![CDATA[基于 ZXing.QrCode 库制作的横条码/二维码生成识别工具 简介二维码（QR Code码） 在现在生活中十分常见，扫一扫即可付款。原本想要学习一下二维码原理自己造轮子，后来还是决定站在巨人的肩膀上使用Google的开源库ZXing来生成和识别二维码/横条码。 帮助类QRCodeHelper 帮助类提供二维码生成，带LOGO二维码，以及图像识别功能。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211/// &lt;summary&gt;/// 注销对象方法API/// &lt;/summary&gt;[DllImport("gdi32")]private static extern int DeleteObject(IntPtr o);/// &lt;summary&gt;/// 生成二维码/// &lt;/summary&gt;/// &lt;param name="strContent"&gt;二维码文本&lt;/param&gt;/// &lt;param name="iWidth"&gt;二维码宽度&lt;/param&gt;/// &lt;param name="iHeigth"&gt;二维码高度&lt;/param&gt;/// &lt;returns&gt;二维码位图&lt;/returns&gt;public static Bitmap GetQRCode(string strContent, int iWidth, int iHeigth)&#123; try &#123; //构造二维码写码器 MultiFormatWriter writer = new MultiFormatWriter(); Dictionary&lt;EncodeHintType, object&gt; hint = new Dictionary&lt;EncodeHintType, object&gt;(); hint.Add(EncodeHintType.CHARACTER_SET, "UTF-8"); hint.Add(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); hint.Add(EncodeHintType.MARGIN, 1); //生成二维码 BitMatrix bitMatrix = writer.encode(strContent, BarcodeFormat.QR_CODE, iWidth, iHeigth, hint); BarcodeWriter barcodeWriter = new BarcodeWriter(); Bitmap bitmapQRCode = barcodeWriter.Write(bitMatrix); //获取二维码实际尺寸(去掉二维码两边空白后的实际尺寸) int[] rectangle = bitMatrix.getEnclosingRectangle(); //将img转换成bmp格式，否则后面无法创建Graphics对象 Bitmap bitmapQRCodeBMP = new Bitmap(bitmapQRCode.Width, bitmapQRCode.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb); using (Graphics g = Graphics.FromImage(bitmapQRCodeBMP)) &#123; g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic; g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality; g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality; g.DrawImage(bitmapQRCode, 0, 0); &#125; return bitmapQRCodeBMP; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 生成二维码(带LOGO)/// &lt;/summary&gt;/// &lt;param name="strContent"&gt;二维码文本&lt;/param&gt;/// &lt;param name="iWidth"&gt;二维码宽度&lt;/param&gt;/// &lt;param name="iHeigth"&gt;二维码高度&lt;/param&gt;/// &lt;param name="strLogoPath"&gt;LOGO图片路径&lt;/param&gt;/// &lt;returns&gt;二维码位图&lt;/returns&gt;public static Bitmap GetQRCode_logo(string strContent, int iWidth, int iHeigth, string strLogoPath)&#123; try &#123; //构造二维码写码器 MultiFormatWriter writer = new MultiFormatWriter(); Dictionary&lt;EncodeHintType, object&gt; hint = new Dictionary&lt;EncodeHintType, object&gt;(); hint.Add(EncodeHintType.CHARACTER_SET, "UTF-8"); hint.Add(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H); hint.Add(EncodeHintType.MARGIN, 1); //生成二维码 BitMatrix bitMatrix = writer.encode(strContent, BarcodeFormat.QR_CODE, iWidth, iHeigth, hint); BarcodeWriter barcodeWriter = new BarcodeWriter(); Bitmap bitmapQRCode = barcodeWriter.Write(bitMatrix); //获取二维码实际尺寸(去掉二维码两边空白后的实际尺寸) int[] rectangle = bitMatrix.getEnclosingRectangle(); //将img转换成bmp格式，否则后面无法创建Graphics对象 Bitmap bitmapQRCodeBMP = new Bitmap(bitmapQRCode.Width, bitmapQRCode.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb); using (Graphics g = Graphics.FromImage(bitmapQRCodeBMP)) &#123; g.InterpolationMode = System.Drawing.Drawing2D.InterpolationMode.HighQualityBicubic; g.SmoothingMode = System.Drawing.Drawing2D.SmoothingMode.HighQuality; g.CompositingQuality = System.Drawing.Drawing2D.CompositingQuality.HighQuality; g.DrawImage(bitmapQRCode, 0, 0); &#125; //获得LOGO位图并计算插入图片的大小和位置 Bitmap bitmapLogo = new Bitmap(strLogoPath); int middleW = Math.Min((int)(rectangle[2] / 3.5), bitmapLogo.Width); int middleH = Math.Min((int)(rectangle[3] / 3.5), bitmapLogo.Height); int middleL = (bitmapQRCode.Width - middleW) / 2; int middleT = (bitmapQRCode.Height - middleH) / 2; //将二维码插入图片(白底) Graphics myGraphic = Graphics.FromImage(bitmapQRCodeBMP); myGraphic.DrawImage(bitmapLogo, middleL, middleT, middleW, middleH); return bitmapQRCodeBMP; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 从位图获取图像源/// &lt;/summary&gt;/// &lt;param name="bitmapQRCode"&gt;位图二维码&lt;/param&gt;/// &lt;returns&gt;图像源(用以显示在控件上)&lt;/returns&gt;public static ImageSource GetImageSourceFromBitmap(Bitmap bitmapQRCode)&#123; try &#123; IntPtr ipQRCode = bitmapQRCode.GetHbitmap(); BitmapSource bitmapSource = System.Windows.Interop.Imaging.CreateBitmapSourceFromHBitmap(ipQRCode, IntPtr.Zero, Int32Rect.Empty, System.Windows.Media.Imaging.BitmapSizeOptions.FromEmptyOptions()); DeleteObject(ipQRCode); return bitmapSource; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 识别二维码和条形码/// &lt;/summary&gt;/// &lt;param name="bitmapQRCode"&gt;二维码和条形码位图&lt;/param&gt;/// &lt;returns&gt;成功返回二维码和条形码内容,失败返回NULL或Empty&lt;/returns&gt;public static string BarcodeReader(Bitmap bitmapQRCode)&#123; try &#123; BarcodeReader barcodeReader = new BarcodeReader(); barcodeReader.Options.CharacterSet = "UTF-8"; Result resultQRCode = barcodeReader.Decode(bitmapQRCode); if (resultQRCode == null) &#123; return string.Empty; &#125; else &#123; return resultQRCode.Text; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 识别二维码和条形码/// &lt;/summary&gt;/// &lt;param name="strQRCodePath"&gt;二维码和条形码文件路径&lt;/param&gt;/// &lt;returns&gt;成功返回二维码和条形码内容,失败返回NULL或Empty&lt;/returns&gt;public static string BarcodeReader(string strQRCodePath)&#123; try &#123; BarcodeReader barcodeReader = new BarcodeReader(); barcodeReader.Options.CharacterSet = "UTF-8"; Bitmap bitmapQRCode = new Bitmap(strQRCodePath); Result resultQRCode = barcodeReader.Decode(bitmapQRCode); if (resultQRCode == null) &#123; return string.Empty; &#125; else &#123; return resultQRCode.Text; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 保存二维码和条形码位图到指定位置/// &lt;/summary&gt;/// &lt;param name="strSavePath"&gt;文件保存位置&lt;/param&gt;/// &lt;param name="bitmapQRCode"&gt;二维码和条形码位图&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool SaveBitmap(string strSavePath, Bitmap bitmapQRCode)&#123; try &#123; ImageFormat imageFormat; switch (System.IO.Path.GetExtension(strSavePath)) &#123; case ".bmp": imageFormat = ImageFormat.Bmp; break; case ".emf": imageFormat = ImageFormat.Emf; break; case ".exif": imageFormat = ImageFormat.Exif; break; case ".gif": imageFormat = ImageFormat.Gif; break; case ".icon": imageFormat = ImageFormat.Icon; break; case ".jpeg": imageFormat = ImageFormat.Jpeg; break; case ".jpg": imageFormat = ImageFormat.Jpeg; break; case ".memorybmp": imageFormat = ImageFormat.MemoryBmp; break; case ".png": imageFormat = ImageFormat.Png; break; case ".tiff": imageFormat = ImageFormat.Tiff; break; case ".wmf": imageFormat = ImageFormat.Wmf; break; default: imageFormat = ImageFormat.Png; break; &#125; bitmapQRCode.Save(strSavePath, imageFormat); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>qrcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows关机帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F06%2Fcsharp-ShutdownHelper%2F</url>
    <content type="text"><![CDATA[关闭Windows计算机帮助类…鬼知道为什么我关电脑也能整理出一篇文章。 简介起初在刚接触C#时制作 Desktop Lock 时有设置自动关机的功能，使用的是执行 CMD 的 shutdown 命令，但是极容易出现被杀毒软件误报毒或误被取消关机。然后又通过调用 Win32 API 的方式关闭计算机。 帮助类ShutdownHelper CMD Shutdown123456789101112public void shutdown()&#123; Process myProcess = new Process(); myProcess.StartInfo.FileName = "cmd.exe"; myProcess.StartInfo.UseShellExecute = false; myProcess.StartInfo.RedirectStandardInput = true; myProcess.StartInfo.RedirectStandardOutput = true; myProcess.StartInfo.RedirectStandardError = true; myProcess.StartInfo.CreateNoWindow = true; myProcess.Start(); myProcess.StandardInput.WriteLine("shutdown -s -f -t 0");&#125; Win32 API12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485[StructLayout(LayoutKind.Sequential, Pack = 1)]internal struct TokPriv1Luid&#123; public int Count; public long Luid; public int Attr;&#125;[DllImport("kernel32.dll", ExactSpelling = true)]internal static extern IntPtr GetCurrentProcess();[DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]internal static extern bool OpenProcessToken(IntPtr h, int acc, ref IntPtr phtok);[DllImport("advapi32.dll", SetLastError = true)]internal static extern bool LookupPrivilegeValue(string host, string name, ref long pluid);[DllImport("advapi32.dll", ExactSpelling = true, SetLastError = true)]internal static extern bool AdjustTokenPrivileges(IntPtr htok, bool disall, ref TokPriv1Luid newst, int len, IntPtr prev, IntPtr relen);[DllImport("user32.dll", ExactSpelling = true, SetLastError = true)]internal static extern bool ExitWindowsEx(int flg, int rea);internal const int SE_PRIVILEGE_ENABLED = 0x00000002;internal const int TOKEN_QUERY = 0x00000008;internal const int TOKEN_ADJUST_PRIVILEGES = 0x00000020;internal const string SE_SHUTDOWN_NAME = "SeShutdownPrivilege";internal const int EWX_LOGOFF = 0x00000000;internal const int EWX_SHUTDOWN = 0x00000001;internal const int EWX_REBOOT = 0x00000002;internal const int EWX_FORCE = 0x00000004;internal const int EWX_POWEROFF = 0x00000008;internal const int EWX_FORCEIFHUNG = 0x00000010;/// &lt;summary&gt;/// 关闭Windows/// &lt;/summary&gt;/// &lt;param name="flg"&gt;&lt;/param&gt;private static void DoExitWin(int flg)&#123; bool ok; TokPriv1Luid tp; IntPtr hproc = GetCurrentProcess(); IntPtr htok = IntPtr.Zero; ok = OpenProcessToken(hproc, TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, ref htok); tp.Count = 1; tp.Luid = 0; tp.Attr = SE_PRIVILEGE_ENABLED; ok = LookupPrivilegeValue(null, SE_SHUTDOWN_NAME, ref tp.Luid); ok = AdjustTokenPrivileges(htok, false, ref tp, 0, IntPtr.Zero, IntPtr.Zero); ok = ExitWindowsEx(flg, 0);&#125;/// &lt;summary&gt;/// 关闭计算机/// &lt;/summary&gt;public static void Shutdown()&#123; try &#123; DoExitWin(EWX_SHUTDOWN); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;/// &lt;summary&gt;/// 注销计算机/// &lt;/summary&gt;public static void Logoff()&#123; try &#123; DoExitWin(EWX_LOGOFF); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;/// &lt;summary&gt;/// 重启计算机/// &lt;/summary&gt;public static void Reboot()&#123; try &#123; DoExitWin(EWX_REBOOT); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
        <tag>shutdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑硬件信息帮助类]]></title>
    <url>%2Fblog%2F2017%2F06%2F06%2Fcsharp-PCInformationHelper%2F</url>
    <content type="text"><![CDATA[获取电脑硬件基础信息，用于开发时作为唯一标示或注册激活使用 帮助类及说明PCInformationHelper 获取的信息有：网卡MAC地址、CPU-ID、硬盘序列号、内存序列号、主板序列号、BIOS序列号、显卡信息。可拼接加密生成唯一序列号，可用于软件激活使用或作为其他唯一标识。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200/// &lt;summary&gt;/// 读取网卡MAC地址/// &lt;/summary&gt;/// &lt;returns&gt;成功返回网卡MAC地址,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; MAC()&#123; try &#123; List&lt;string&gt; listMAC = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_NetworkAdapterConfiguration"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; if ((bool)mo["IPEnabled"]) &#123; strMac = mo["MacAddress"].ToString(); listMAC.Add(strMac); &#125; &#125; return listMAC; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取CPU-ID/// &lt;/summary&gt;/// &lt;returns&gt;成功返回CPU-ID,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; CPU()&#123; try &#123; List&lt;string&gt; listCPU = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_Processor"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Manufacturer = 处理器制造商 //Name = 处理器名字 //Processorid = CPU-ID strMac = mo["Processorid"].ToString(); listCPU.Add(strMac); &#125; return listCPU; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取硬盘序列号/// &lt;/summary&gt;/// &lt;returns&gt;成功返回硬盘序列号,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; DESK()&#123; try &#123; List&lt;string&gt; listDESK = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("win32_DiskDrive"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Model = 硬盘信息 //SerialNumber = 硬盘序列号 strMac = mo["SerialNumber"].ToString(); listDESK.Add(strMac); &#125; return listDESK; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取内存序列号/// &lt;/summary&gt;/// &lt;returns&gt;成功返回内存序列号,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; Memory()&#123; try &#123; List&lt;string&gt; listMemory = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_PhysicalMemory"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Manufacturer = 内存生产商 //SerialNumber = 序列号 strMac = mo["SerialNumber"].ToString(); listMemory.Add(strMac); &#125; return listMemory; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取主板序列号/// &lt;/summary&gt;/// &lt;returns&gt;成功返回主板序列号,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; Motherboard()&#123; try &#123; List&lt;string&gt; listMotherboard = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("WIN32_BaseBoard"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Manufacturer = 主板制造商 //Product = 主板型号 //SerialNumber = 序列号 strMac = mo["SerialNumber"].ToString(); listMotherboard.Add(strMac); &#125; return listMotherboard; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取BIOS序列号/// &lt;/summary&gt;/// &lt;returns&gt;成功返回BIOS序列号,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; BIOS()&#123; try &#123; List&lt;string&gt; listBIOS = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_BIOS"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Manufacturer = BIOS制造商名称 //SerialNumber = BIOS序列号 //ReleaseDate = 出厂日期 //Version = 版本号 strMac = mo["SerialNumber"].ToString(); listBIOS.Add(strMac); &#125; return listBIOS; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 读取显卡信息/// &lt;/summary&gt;/// &lt;returns&gt;成功返回显卡信息,失败返回NULL&lt;/returns&gt;public static List&lt;string&gt; Video()&#123; try &#123; List&lt;string&gt; listVideo = new List&lt;string&gt;(); string strMac = ""; ManagementClass mc = new ManagementClass("Win32_VideoController"); ManagementObjectCollection moc = mc.GetInstances(); foreach (ManagementObject mo in moc) &#123; //Name = 显卡信息 //DriverVersion = 驱动程序版本 strMac = mo["Name"].ToString(); listVideo.Add(strMac); &#125; return listVideo; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NPOI/DOCX 帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F27%2Fcsharp-NPOIHelper%2F</url>
    <content type="text"><![CDATA[使用 NPOI/DocX 二次封装Office（Word、Excel）帮助类 简介工作中需要大量生成导出报表或合同证书文件，原理为使用Excel或Word模板，批量替换标签以达到效果。 设计由于原类库都属于基础方法，二次封装后具有更简易的使用方式，可直接传入生成的数据集或标签替换集合。 引用库介绍由于微软默认推荐的类库 Microsoft.Office.Interop.Word 与 Microsoft.Office.Interop.Excel 需要电脑安装 Microsoft Office 并引用COM组件才可以使用（已知调用打印机需引用COM组件），所以选用类库可独立于Office组件，在任意一台电脑也可以运行。NPOI：POI Java项目的.NET版本。可以非常轻松地读/写Office 2003/2007文件。DocX：DocX是一个.NET库，允许开发人员以简单直观的方式操作Word文件。 Excel文件操作ExcelHelper提供创建文件（2003/2007）及Sheet分页创建编辑，读取Excel文件至内存DataSet及反向DataSet保存至Excel文件。仅显示最外层引用方法，详细调用请在帮助类种查看！12345678910111213141516171819202122232425262728293031323334/// &lt;summary&gt;/// Excel所有分页转换为DataSet/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Excel文件路径&lt;/param&gt;/// &lt;returns&gt;成功返回Excel的DataSet,失败返回NULL&lt;/returns&gt;public static DataSet ExcelConversionDataSet(string strDataSourcePath)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || !File.Exists(strDataSourcePath)) &#123; return null; &#125; DataSet dsTargetData = new DataSet(); Dictionary&lt;int, string&gt; dicAllSheet = GetExcelAllSheet(strDataSourcePath); foreach (var vAllSheet in dicAllSheet) &#123; DataTable dtTargetData = new DataTable(); dtTargetData.TableName = vAllSheet.Value; dtTargetData = ExcelConversionDataTable(strDataSourcePath, vAllSheet.Value); if (dtTargetData == null) &#123; continue; &#125; dsTargetData.Tables.Add(dtTargetData); &#125; return dsTargetData; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt;/// DataSet转换为Excel/// 存在文件则新建DataTableName的分页(如果分页名冲突则或为空则使用默认名称)/// 不存在文件则新建(Excel,名称为DataTableName,如果没有则使用默认名称)/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Excel文件路径&lt;/param&gt;/// &lt;param name="dsSourceData"&gt;DataTable数据&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DataSetConversionExcel(string strDataSourcePath, DataSet dsSourceData)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || dsSourceData.Tables.Count &lt; 1) &#123; return false; &#125; foreach (DataTable dtSourceData in dsSourceData.Tables) &#123; Dictionary&lt;int, string&gt; dicAllSheet = GetExcelAllSheet(strDataSourcePath); string strTableName = string.IsNullOrEmpty(dtSourceData.TableName) ? string.Format("Sheet&#123;0&#125;", dicAllSheet.Count + 1) : dtSourceData.TableName; if (dicAllSheet.ContainsValue(dtSourceData.TableName)) &#123; RemoveExcelSheet(strDataSourcePath, dtSourceData.TableName); &#125; if (!FillDataTable(strDataSourcePath, strTableName, dtSourceData, true, 0, 0)) &#123; return false; &#125; &#125; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; 根据公司项目需要，把多个Excel的Sheet页的内容及样式合并为一个文件，Microsoft.Office.Interop.Excel提供拷贝分页方法，但是需要安装Microsoft Office，所以用NPOI类库实现了一个拷贝方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/// &lt;summary&gt;/// 拷贝Sheet页到另一个Sheet页/// &lt;/summary&gt;/// &lt;param name="strSourceExcelPath"&gt;源Excel路径&lt;/param&gt;/// &lt;param name="strFromSheetName"&gt;源Excel拷贝Sheet&lt;/param&gt;/// &lt;param name="strTargetExcelPath"&gt;目标Excel路径&lt;/param&gt;/// &lt;param name="strToSheetName"&gt;目标Excel拷贝Sheet&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CopySheet(string strSourceExcelPath, string strFromSheetName, string strTargetExcelPath, string strToSheetName)&#123; try &#123; if (string.IsNullOrEmpty(strSourceExcelPath) || string.IsNullOrEmpty(strTargetExcelPath) || !File.Exists(strSourceExcelPath)) &#123; TXTHelper.Logs(string.Format("源数据和目标数据参数为空或文件不存在!")); return false; &#125; if (string.IsNullOrEmpty(strFromSheetName) || string.IsNullOrEmpty(strToSheetName)) &#123; TXTHelper.Logs(string.Format("源Sheet页和目标Sheet页参数为空!")); return false; &#125; //获得源数据和目标数据的Sheet页 IWorkbook iSourceWorkbook = null; ISheet iSourceSheet = GetExcelSheetAt(strSourceExcelPath, strFromSheetName, out iSourceWorkbook); IWorkbook iTargetWorkbook = null; ISheet iTargetSheet = null; if (iSourceSheet == null) &#123; TXTHelper.Logs(string.Format("指定源数据Sheet页为空!")); return false; &#125; if (!File.Exists(strTargetExcelPath)) &#123; //如果文件不存在则创建Excel if (System.IO.Path.GetExtension(strTargetExcelPath) == ".xls") &#123; bool bCreare = CreateExcel_Office2003(strTargetExcelPath, strToSheetName); &#125; else if (System.IO.Path.GetExtension(strTargetExcelPath) == ".xlsx") &#123; bool bCreare = CreateExcel_Office2007(strTargetExcelPath, strToSheetName); &#125; else &#123; TXTHelper.Logs(string.Format("指定目标Excel文件路径格式错误!")); return false; &#125; iTargetSheet = GetExcelSheetAt(strTargetExcelPath, strToSheetName, out iTargetWorkbook); &#125; else &#123; //如果文件存在则判断是否存在执行Sheet Dictionary&lt;int, string&gt; dicAllSheet = GetExcelAllSheet(strTargetExcelPath); if (dicAllSheet.ContainsValue(strToSheetName)) &#123; iTargetSheet = GetExcelSheetAt(strTargetExcelPath, strToSheetName, out iTargetWorkbook); &#125; else &#123; iTargetSheet = CreateExcelSheetAt(strTargetExcelPath, strToSheetName, out iTargetWorkbook); &#125; &#125; //调用Sheet拷贝Sheet方法 bool bCopySheet = CopySheetAt(iSourceWorkbook, iSourceSheet, iTargetWorkbook, iTargetSheet); if (bCopySheet) &#123; if (System.IO.Path.GetExtension(strTargetExcelPath) == ".xls") &#123; FileStream fileStream2003 = new FileStream(Path.ChangeExtension(strTargetExcelPath, "xls"), FileMode.Create); iTargetWorkbook.Write(fileStream2003); fileStream2003.Close(); iTargetWorkbook.Close(); &#125; else if (System.IO.Path.GetExtension(strTargetExcelPath) == ".xlsx") &#123; FileStream fileStream2007 = new FileStream(Path.ChangeExtension(strTargetExcelPath, "xlsx"), FileMode.Create); iTargetWorkbook.Write(fileStream2007); fileStream2007.Close(); iTargetWorkbook.Close(); &#125; return true; &#125; else &#123; TXTHelper.Logs(string.Format("拷贝失败!")); return false; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140// &lt;summary&gt;/// 拷贝Sheet页到另一个Sheet页(浅拷贝,不提供保存方法)/// Office2003单Sheet页仅支持4000个样式/// &lt;/summary&gt;/// &lt;param name="iSourceWorkbook"&gt;源Excel工作簿&lt;/param&gt;/// &lt;param name="iFromSheet"&gt;源Sheet页&lt;/param&gt;/// &lt;param name="iTargetWorkbook"&gt;目标Excel工作簿&lt;/param&gt;/// &lt;param name="iToSheet"&gt;目标Sheet页&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CopySheetAt(IWorkbook iSourceWorkbook, ISheet iFromSheet, IWorkbook iTargetWorkbook, ISheet iToSheet)&#123; try &#123; //拷贝数据 DataTable dtExcelFromData = GetDataTable(iFromSheet, false, 0, 0, 0, 0); iToSheet = FillDataTable(iToSheet, dtExcelFromData, false, 0, 0); //拷贝单元格合并 for (int iMergedRegions = 0; iMergedRegions &lt; iFromSheet.NumMergedRegions; iMergedRegions++) &#123; iToSheet.AddMergedRegion(iFromSheet.GetMergedRegion(iMergedRegions)); &#125; //拷贝样式(遍历Sheet页行) List&lt;ICellStyle&gt; listCellStyle = new List&lt;ICellStyle&gt;(); for (int iRowNum = 0; iRowNum &lt;= iFromSheet.LastRowNum; iRowNum++) &#123; IRow iFromRowData = iFromSheet.GetRow(iRowNum); IRow iToRowData = iToSheet.GetRow(iRowNum); if (iFromRowData == null || iToRowData == null) &#123; continue; &#125; //设置行高 short sFromHeight = iFromRowData.Height; iToRowData.Height = sFromHeight; //遍历Sheet页列 for (int iRowCell = 0; iRowCell &lt;= iFromRowData.LastCellNum; iRowCell++) &#123; //设置列宽 int iFromColumnWidth = iFromSheet.GetColumnWidth(iRowNum) / 256; iToSheet.SetColumnWidth(iRowNum, iFromColumnWidth * 256); //复制数据 ICell iFromCell = iFromRowData.GetCell(iRowCell); if (iFromCell != null) &#123; //获得源Sheet页的样式 ICellStyle iFromCellStyle = iFromCell.CellStyle; //获得目标Excel指定Cell ICell iToCell = iToRowData.GetCell(iRowCell); if (iToCell == null) continue; #region 复制单元格样式 //指定Cell创新目标Excel工作簿新样式 ICellStyle iToNewCellStyle = null; foreach (ICellStyle vCellStyle in listCellStyle) &#123; IFont iVToFont = vCellStyle.GetFont(iTargetWorkbook); IFont iFromFont = iFromCellStyle.GetFont(iSourceWorkbook); if (vCellStyle.Alignment == iFromCellStyle.Alignment &amp;&amp; vCellStyle.BorderBottom == iFromCellStyle.BorderBottom &amp;&amp; vCellStyle.BorderLeft == iFromCellStyle.BorderLeft &amp;&amp; vCellStyle.BorderRight == iFromCellStyle.BorderRight &amp;&amp; vCellStyle.BorderTop == iFromCellStyle.BorderTop &amp;&amp; vCellStyle.BottomBorderColor == iFromCellStyle.BottomBorderColor &amp;&amp; vCellStyle.DataFormat == iFromCellStyle.DataFormat &amp;&amp; vCellStyle.FillBackgroundColor == iFromCellStyle.FillBackgroundColor &amp;&amp; vCellStyle.FillForegroundColor == iFromCellStyle.FillForegroundColor &amp;&amp; vCellStyle.FillPattern == iFromCellStyle.FillPattern &amp;&amp; vCellStyle.Indention == iFromCellStyle.Indention &amp;&amp; vCellStyle.IsHidden == iFromCellStyle.IsHidden &amp;&amp; vCellStyle.IsLocked == iFromCellStyle.IsLocked &amp;&amp; vCellStyle.LeftBorderColor == iFromCellStyle.LeftBorderColor &amp;&amp; vCellStyle.RightBorderColor == iFromCellStyle.RightBorderColor &amp;&amp; vCellStyle.Rotation == iFromCellStyle.Rotation &amp;&amp; vCellStyle.TopBorderColor == iFromCellStyle.TopBorderColor &amp;&amp; vCellStyle.VerticalAlignment == iFromCellStyle.VerticalAlignment &amp;&amp; vCellStyle.WrapText == iFromCellStyle.WrapText &amp;&amp; //字体比对 iVToFont.Color == iFromFont.Color &amp;&amp; iVToFont.FontHeightInPoints == iFromFont.FontHeightInPoints &amp;&amp; iVToFont.FontName == iFromFont.FontName &amp;&amp; iVToFont.IsBold == iFromFont.IsBold &amp;&amp; iVToFont.IsItalic == iFromFont.IsItalic &amp;&amp; iVToFont.IsStrikeout == iFromFont.IsStrikeout &amp;&amp; iVToFont.Underline == iFromFont.Underline) &#123; iToNewCellStyle = vCellStyle; break; &#125; &#125; if (iToNewCellStyle == null) &#123; //创建新样式 iToNewCellStyle = iTargetWorkbook.CreateCellStyle(); //复制样式 iToNewCellStyle.Alignment = iFromCellStyle.Alignment;//对齐 iToNewCellStyle.BorderBottom = iFromCellStyle.BorderBottom;//下边框 iToNewCellStyle.BorderLeft = iFromCellStyle.BorderLeft;//左边框 iToNewCellStyle.BorderRight = iFromCellStyle.BorderRight;//右边框 iToNewCellStyle.BorderTop = iFromCellStyle.BorderTop;//上边框 iToNewCellStyle.BottomBorderColor = iFromCellStyle.BottomBorderColor;//下边框颜色 iToNewCellStyle.DataFormat = iFromCellStyle.DataFormat;//数据格式 iToNewCellStyle.FillBackgroundColor = iFromCellStyle.FillBackgroundColor;//填充背景色 iToNewCellStyle.FillForegroundColor = iFromCellStyle.FillForegroundColor;//填充前景色 iToNewCellStyle.FillPattern = iFromCellStyle.FillPattern;//填充图案 iToNewCellStyle.Indention = iFromCellStyle.Indention;//压痕 iToNewCellStyle.IsHidden = iFromCellStyle.IsHidden;//隐藏 iToNewCellStyle.IsLocked = iFromCellStyle.IsLocked;//锁定 iToNewCellStyle.LeftBorderColor = iFromCellStyle.LeftBorderColor;//左边框颜色 iToNewCellStyle.RightBorderColor = iFromCellStyle.RightBorderColor;//右边框颜色 iToNewCellStyle.Rotation = iFromCellStyle.Rotation;//旋转 iToNewCellStyle.TopBorderColor = iFromCellStyle.TopBorderColor;//上边框颜色 iToNewCellStyle.VerticalAlignment = iFromCellStyle.VerticalAlignment;//垂直对齐 iToNewCellStyle.WrapText = iFromCellStyle.WrapText;//文字换行 //复制字体 IFont iFromFont = iFromCellStyle.GetFont(iSourceWorkbook); IFont iToFont = iTargetWorkbook.CreateFont(); iToFont.Color = iFromFont.Color;//颜色 iToFont.FontHeightInPoints = iFromFont.FontHeightInPoints;//字号 iToFont.FontName = iFromFont.FontName;//字体 iToFont.IsBold = iFromFont.IsBold;//加粗 iToFont.IsItalic = iFromFont.IsItalic;//斜体 iToFont.IsStrikeout = iFromFont.IsStrikeout;//删除线 iToFont.Underline = iFromFont.Underline;//下划线 iToNewCellStyle.SetFont(iToFont); //保存到缓存集合中 listCellStyle.Add(iToNewCellStyle); &#125; //复制样式到指定表格中 iToCell.CellStyle = iToNewCellStyle; #endregion &#125; &#125; &#125; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; Word文件操作WordHelper提供创建文件（2003/2007）及替换段落表格标签（匹配替换’{标签}’,’#标签#’），替换图片功能。仅显示最外层引用方法，详细调用请在帮助类种查看！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/// &lt;summary&gt;/// 替换文本标签/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Word文件路径&lt;/param&gt;/// &lt;param name="strLabelName"&gt;标签名称(带标签符号)&lt;/param&gt;/// &lt;param name="strReplaceLabel"&gt;替换标签文本&lt;/param&gt;/// &lt;returns&gt;成功返回替换数量,失败返回-1&lt;/returns&gt;public static int ReplaceTextLabel(string strDataSourcePath, string strLabelName, string strReplaceLabel)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || !File.Exists(strDataSourcePath) || string.IsNullOrEmpty(strLabelName) || string.IsNullOrEmpty(strReplaceLabel)) &#123; return -1; &#125; int iNumber = 0; FileStream fileStreamOpen = new FileStream(strDataSourcePath, FileMode.Open, FileAccess.Read); XWPFDocument wordDocument = new XWPFDocument(fileStreamOpen); foreach (XWPFParagraph wordParagraph in wordDocument.Paragraphs) &#123; if (wordParagraph.ParagraphText.IndexOf(strLabelName) &gt;= 0) &#123; string strReplaceTextLabel = wordParagraph.ParagraphText.Replace(strLabelName, strReplaceLabel); foreach (XWPFRun wordRun in wordParagraph.Runs) &#123; wordRun.SetText(string.Empty, 0); &#125; wordParagraph.CreateRun().SetText(strReplaceTextLabel, 0); iNumber++; &#125; &#125; foreach (XWPFTable wordTable in wordDocument.Tables) &#123; foreach (XWPFTableRow wordTableRow in wordTable.Rows) &#123; foreach (XWPFTableCell wordTableCell in wordTableRow.GetTableCells()) &#123; foreach (XWPFParagraph wordParagraph in wordTableCell.Paragraphs) &#123; if (wordParagraph.ParagraphText.IndexOf(strLabelName) &gt;= 0) &#123; string strReplaceTextLabel = wordParagraph.ParagraphText.Replace(strLabelName, strReplaceLabel); foreach (XWPFRun wordRun in wordParagraph.Runs) &#123; wordRun.SetText(string.Empty, 0); &#125; wordParagraph.CreateRun().SetText(strReplaceTextLabel, 0); iNumber++; &#125; &#125; &#125; &#125; &#125; FileStream fileStreamSave = new FileStream(strDataSourcePath, FileMode.Create); wordDocument.Write(fileStreamSave); fileStreamSave.Close(); wordDocument.Close(); return iNumber; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return -1; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/// &lt;summary&gt;/// 替换表格标签(DataTable替换)/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Word文件路径&lt;/param&gt;/// &lt;param name="strLabelName"&gt;标签名称(带标签符号)&lt;/param&gt;/// &lt;param name="dtReplaceLabel"&gt;替换标签DataTable&lt;/param&gt;/// &lt;returns&gt;成功返回1,失败返回-1&lt;/returns&gt;public static int ReplaceDataTableLabel(string strDataSourcePath, string strLabelName, DataTable dtReplaceLabel)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || !File.Exists(strDataSourcePath) || string.IsNullOrEmpty(strLabelName) || dtReplaceLabel == null || dtReplaceLabel.Rows.Count &lt; 1) &#123; return -1; &#125; FileStream fileStreamOpen = new FileStream(strDataSourcePath, FileMode.Open, FileAccess.Read); XWPFDocument wordDocument = new XWPFDocument(fileStreamOpen); int iLableRowPosition = -1; int iLableCellPosition = -1; foreach (XWPFTable wordTable in wordDocument.Tables) &#123; for (int iTableRow = 0; iTableRow &lt; wordTable.Rows.Count; iTableRow++) &#123; for (int iTableCell = 0; iTableCell &lt; wordTable.Rows[iTableRow].GetTableCells().Count; iTableCell++) &#123; foreach (XWPFParagraph wordParagraph in wordTable.Rows[iTableRow].GetTableCells()[iTableCell].Paragraphs) &#123; if (wordParagraph.ParagraphText.IndexOf(strLabelName) &gt;= 0) &#123; if (iLableRowPosition &lt; 0 &amp;&amp; iLableCellPosition &lt; 0) &#123; iLableRowPosition = iTableRow; iLableCellPosition = iTableCell; &#125; &#125; if (iLableRowPosition &gt;= 0 &amp;&amp; iLableCellPosition &gt;= 0) &#123; int iCurrentRow = iTableRow - iLableRowPosition; int iCurrentCell = iTableCell - iLableCellPosition; if ((iCurrentRow &lt; dtReplaceLabel.Rows.Count &amp;&amp; iCurrentRow &gt;= 0) &amp;&amp; (iCurrentCell &lt; dtReplaceLabel.Columns.Count &amp;&amp; iCurrentCell &gt;= 0)) &#123; foreach (XWPFRun wordRun in wordParagraph.Runs) &#123; wordRun.SetText(string.Empty, 0); &#125; wordParagraph.CreateRun().SetText(dtReplaceLabel.Rows[iCurrentRow][iCurrentCell].ToString(), 0); &#125; &#125; &#125; &#125; &#125; &#125; FileStream fileStreamSave = new FileStream(strDataSourcePath, FileMode.Create); wordDocument.Write(fileStreamSave); fileStreamSave.Close(); wordDocument.Close(); return 1; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return -1; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/// &lt;summary&gt;/// 替换图片标签(使用DocX.dll类库,调用这个方法后NPOI无法读取文档)/// &lt;/summary&gt;/// &lt;param name="strDataSourcePath"&gt;Word文件路径&lt;/param&gt;/// &lt;param name="strLabelName"&gt;标签名称(带标签符号)&lt;/param&gt;/// &lt;param name="strImagePath"&gt;替换的图片路径&lt;/param&gt;/// &lt;param name="iImageWidth"&gt;替换的图片宽度(小于0则显示原图宽度)&lt;/param&gt;/// &lt;param name="iImageHeight"&gt;替换的图片高度(小于0则显示原图高度)&lt;/param&gt;/// &lt;returns&gt;成功返回替换数量,失败返回-1&lt;/returns&gt;public static int ReplaceImageLabel(string strDataSourcePath, string strLabelName, string strImagePath, int iImageWidth, int iImageHeight)&#123; try &#123; if (string.IsNullOrEmpty(strDataSourcePath) || !File.Exists(strDataSourcePath) || string.IsNullOrEmpty(strLabelName) || string.IsNullOrEmpty(strImagePath) || !File.Exists(strImagePath)) &#123; return -1; &#125; int iNumber = 0; //使用DocX.dll类库 DocX mDocX = DocX.Load(strDataSourcePath); //遍历段落 foreach (Paragraph wordParagraph in mDocX.Paragraphs) &#123; if (wordParagraph.Text.IndexOf(strLabelName) &gt;= 0) &#123; //添加图片 Novacode.Image pImag = mDocX.AddImage(strImagePath); Picture pPicture = pImag.CreatePicture(); //如果传入宽度小于0,则以原始大小插入 if (iImageWidth &gt;= 0) &#123; pPicture.Width = iImageWidth; &#125; //如果传入高度小于0,则以原始大小插入 if (iImageHeight &gt;= 0) &#123; pPicture.Height = iImageHeight; &#125; //将图像插入到段落后面 wordParagraph.InsertPicture(pPicture); //清空文本(清空放在前面会导致替换失败文字消失) wordParagraph.ReplaceText(strLabelName, string.Empty); iNumber++; &#125; &#125; mDocX.SaveAs(strDataSourcePath); return iNumber; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return -1; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>npoi</tag>
        <tag>docx</tag>
        <tag>excel</tag>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZIP压缩文件帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F25%2Fcsharp-ZIPHelper%2F</url>
    <content type="text"><![CDATA[操作 ZIP/7z 压缩文件帮助类，以及压缩数据文本的 GZIP 帮助类 简介工作中会有需求把数据集打包成压缩文件，封装一个帮助以方便调用。ZIP 通用且最为常见的压缩格式。7-ZIP 自由开源的压缩格式，压缩效果要比普通的ZIP效果要好。GZIP 用于压缩数据流或文本。 帮助类代码及引用ZIP：ZIPHelper 引用 ICSharpCode.SharpZipLib.Zip 库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197/// &lt;summary&gt;/// 压缩ZIP文件/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="listFolderOrFilePath"&gt;需要压缩的文件夹或文件&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CompressionZip(string strZipPath, List&lt;string&gt; listFolderOrFilePath)&#123; return CompressionZip(strZipPath, listFolderOrFilePath, string.Empty);&#125;/// &lt;summary&gt;/// 压缩ZIP文件(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="listFolderOrFilePath"&gt;需要压缩的文件夹或文件&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool CompressionZip(string strZipPath, List&lt;string&gt; listFolderOrFilePath, string strPassword)&#123; try &#123; ZipOutputStream ComStream = new ZipOutputStream(File.Create(strZipPath)); //压缩等级(0-9) ComStream.SetLevel(9); //压缩文件加密 if (!string.IsNullOrEmpty(strPassword)) &#123; ComStream.Password = strPassword; &#125; foreach (string strFolderOrFilePath in listFolderOrFilePath) &#123; if (Directory.Exists(strFolderOrFilePath)) &#123; //如果路径是文件目录 CompressionZipDirectory(strFolderOrFilePath, ComStream, string.Empty); &#125; else if (File.Exists(strFolderOrFilePath)) &#123; //如果路径是文件路径 FileStream fileStream = File.OpenRead(strFolderOrFilePath); byte[] btsLength = new byte[fileStream.Length]; fileStream.Read(btsLength, 0, btsLength.Length); ZipEntry zipEntry = new ZipEntry(new FileInfo(strFolderOrFilePath).Name); ComStream.PutNextEntry(zipEntry); ComStream.Write(btsLength, 0, btsLength.Length); &#125; &#125; ComStream.Finish(); ComStream.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 压缩ZIP文件夹/// &lt;/summary&gt;/// &lt;param name="strRootPath"&gt;根目录路径&lt;/param&gt;/// &lt;param name="ComStream"&gt;ZIP文件输出流&lt;/param&gt;/// &lt;param name="strSubPath"&gt;子目录路径&lt;/param&gt;private static void CompressionZipDirectory(string strRootPath, ZipOutputStream ComStream, string strSubPath)&#123; try &#123; //创建当前文件夹 ZipEntry zipEntry = new ZipEntry(Path.Combine(strSubPath, Path.GetFileName(strRootPath) + "/")); ComStream.PutNextEntry(zipEntry); ComStream.Flush(); //遍历压缩目录 foreach (string strFolder in Directory.GetDirectories(strRootPath)) &#123; CompressionZipDirectory(strFolder, ComStream, Path.Combine(strSubPath, Path.GetFileName(strRootPath))); &#125; //遍历压缩文件 foreach (string strFileName in Directory.GetFiles(strRootPath)) &#123; FileStream fileStream = File.OpenRead(strFileName); byte[] btsLength = new byte[fileStream.Length]; fileStream.Read(btsLength, 0, btsLength.Length); zipEntry = new ZipEntry(Path.Combine(strSubPath, Path.GetFileName(strRootPath) + "/" + Path.GetFileName(strFileName))); ComStream.PutNextEntry(zipEntry); ComStream.Write(btsLength, 0, btsLength.Length); if (fileStream != null) &#123; fileStream.Close(); fileStream.Dispose(); &#125; &#125; if (zipEntry != null) &#123; zipEntry = null; &#125; GC.Collect(); GC.Collect(1); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;/// &lt;summary&gt;/// 解压缩ZIP文件/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strDeCompressionPath"&gt;需要解压到的指定位置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeCompressionZip(string strZipPath, string strDeCompressionPath)&#123; return DeCompressionZip(strZipPath, strDeCompressionPath, string.Empty);&#125;/// &lt;summary&gt;/// 解压缩ZIP文件(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strDeCompressionPath"&gt;需要解压到的指定位置&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeCompressionZip(string strZipPath, string strDeCompressionPath, string strPassword)&#123; try &#123; if (string.IsNullOrEmpty(strZipPath) || !File.Exists(strZipPath)) &#123; return false; &#125; ZipInputStream inputStream = new ZipInputStream(File.OpenRead(strZipPath)); //压缩文件解密 if (!string.IsNullOrEmpty(strPassword)) &#123; inputStream.Password = strPassword; &#125; ZipEntry zipEntry = null; while ((zipEntry = inputStream.GetNextEntry()) != null) &#123; if (!string.IsNullOrEmpty(zipEntry.Name)) &#123; string strFileName = Path.Combine(strDeCompressionPath, zipEntry.Name); strFileName = strFileName.Replace('/', '\\'); if (strFileName.EndsWith("\\")) &#123; Directory.CreateDirectory(strFileName); &#125; else &#123; FileStream fileStream = null; int intSize = 2048; byte[] btsData = new byte[intSize]; while (true) &#123; intSize = inputStream.Read(btsData, 0, btsData.Length); if (fileStream == null) &#123; fileStream = File.Create(strFileName); &#125; if (intSize &gt; 0) &#123; fileStream.Write(btsData, 0, btsData.Length); &#125; else &#123; break; &#125; &#125; if (fileStream != null) &#123; fileStream.Close(); fileStream.Dispose(); &#125; &#125; &#125; &#125; if (zipEntry != null) &#123; zipEntry = null; &#125; if (inputStream != null) &#123; inputStream.Close(); inputStream.Dispose(); &#125; GC.Collect(); GC.Collect(1); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; 7-ZIP：ZIP7Helper 动态引用 7z.dll 库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284/// &lt;summary&gt;/// 获得当前系统X86架构7ZIP类库路径/// &lt;/summary&gt;public static string strX86_DllPath&#123; get &#123; return string.Format(@"&#123;0&#125;\x86\7z.dll", System.Environment.CurrentDirectory); &#125;&#125;/// &lt;summary&gt;/// 获得当前系统X64架构7ZIP类库路径/// &lt;/summary&gt;public static string strX64_DllPath&#123; get &#123; return string.Format(@"&#123;0&#125;\x64\7z.dll", System.Environment.CurrentDirectory); &#125;&#125;/// &lt;summary&gt;/// 动态链接7ZIP类库/// &lt;/summary&gt;private static void SetLibraryPath7z()&#123; //动态链接7ZIP类库 if (IntPtr.Size == 8) &#123; SevenZipExtractor.SetLibraryPath(strX64_DllPath); &#125; else &#123; SevenZipExtractor.SetLibraryPath(strX86_DllPath); &#125;&#125;/// &lt;summary&gt;/// 压缩7-ZIP文件/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="fileFullNames"&gt;需要压缩的文件&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool Compression7Zip(string strZipPath, params string[] fileFullNames)&#123; try &#123; //动态链接7ZIP类库 SetLibraryPath7z(); //默认格式为(*.7z) strZipPath = Path.ChangeExtension(strZipPath, "7z"); //压缩7-ZIP文件 SevenZipCompressor sevenZipCompressor = new SevenZipCompressor(); //压缩等级(默认正常值) sevenZipCompressor.CompressionLevel = CompressionLevel.Normal; //压缩格式(默认7z压缩) sevenZipCompressor.ArchiveFormat = OutArchiveFormat.SevenZip; //是否保持目录结构(默认为true) sevenZipCompressor.DirectoryStructure = true; //是否包含空目录(默认true) sevenZipCompressor.IncludeEmptyDirectories = true; //压缩目录时是否使用顶层目录(默认false) sevenZipCompressor.PreserveDirectoryRoot = false; //加密7z头(默认false) sevenZipCompressor.EncryptHeaders = false; //文件加密算法 sevenZipCompressor.ZipEncryptionMethod = ZipEncryptionMethod.ZipCrypto; //尽快压缩(不会触发*Started事件,仅触发*Finished事件) sevenZipCompressor.FastCompression = false; //压缩文件 sevenZipCompressor.CompressFiles(strZipPath, fileFullNames); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 压缩7-ZIP文件(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;param name="fileFullNames"&gt;需要压缩的文件&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool Compression7Zip(string strZipPath, string strPassword, params string[] fileFullNames)&#123; try &#123; //动态链接7ZIP类库 SetLibraryPath7z(); //默认格式为(*.7z) strZipPath = Path.ChangeExtension(strZipPath, "7z"); //压缩7-ZIP文件 SevenZipCompressor sevenZipCompressor = new SevenZipCompressor(); //压缩等级(默认正常值) sevenZipCompressor.CompressionLevel = CompressionLevel.Normal; //压缩格式(默认7z压缩) sevenZipCompressor.ArchiveFormat = OutArchiveFormat.SevenZip; //是否保持目录结构(默认为true) sevenZipCompressor.DirectoryStructure = true; //是否包含空目录(默认true) sevenZipCompressor.IncludeEmptyDirectories = true; //压缩目录时是否使用顶层目录(默认false) sevenZipCompressor.PreserveDirectoryRoot = false; //加密7z头(默认false) sevenZipCompressor.EncryptHeaders = true; //文件加密算法 sevenZipCompressor.ZipEncryptionMethod = ZipEncryptionMethod.ZipCrypto; //尽快压缩(不会触发*Started事件,仅触发*Finished事件) sevenZipCompressor.FastCompression = false; //压缩文件 sevenZipCompressor.CompressFilesEncrypted(strZipPath, strPassword, fileFullNames); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 压缩7-ZIP文件夹/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件夹&lt;/param&gt;/// &lt;param name="strDirectory"&gt;需要压缩的文件夹&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool Compression7ZipDirectory(string strZipPath, string strDirectory)&#123; try &#123; //动态链接7ZIP类库 SetLibraryPath7z(); //默认格式为(*.7z) strZipPath = Path.ChangeExtension(strZipPath, "7z"); //压缩7-ZIP文件 SevenZipCompressor sevenZipCompressor = new SevenZipCompressor(); //压缩等级(默认正常值) sevenZipCompressor.CompressionLevel = CompressionLevel.Normal; //压缩格式(默认7z压缩) sevenZipCompressor.ArchiveFormat = OutArchiveFormat.SevenZip; //是否保持目录结构(默认为true) sevenZipCompressor.DirectoryStructure = true; //是否包含空目录(默认true) sevenZipCompressor.IncludeEmptyDirectories = true; //压缩目录时是否使用顶层目录(默认false) sevenZipCompressor.PreserveDirectoryRoot = false; //加密7z头(默认false) sevenZipCompressor.EncryptHeaders = false; //文件加密算法 sevenZipCompressor.ZipEncryptionMethod = ZipEncryptionMethod.ZipCrypto; //尽快压缩(不会触发*Started事件,仅触发*Finished事件) sevenZipCompressor.FastCompression = false; //压缩文件 sevenZipCompressor.CompressDirectory(strDirectory, strZipPath); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 压缩7-ZIP文件夹(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件夹&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;param name="strDirectory"&gt;需要压缩的文件夹&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool Compression7ZipDirectory(string strZipPath, string strPassword, string strDirectory)&#123; try &#123; //动态链接7ZIP类库 SetLibraryPath7z(); //默认格式为(*.7z) strZipPath = Path.ChangeExtension(strZipPath, "7z"); //压缩7-ZIP文件 SevenZipCompressor sevenZipCompressor = new SevenZipCompressor(); //压缩等级(默认正常值) sevenZipCompressor.CompressionLevel = CompressionLevel.Normal; //压缩格式(默认7z压缩) sevenZipCompressor.ArchiveFormat = OutArchiveFormat.SevenZip; //是否保持目录结构(默认为true) sevenZipCompressor.DirectoryStructure = true; //是否包含空目录(默认true) sevenZipCompressor.IncludeEmptyDirectories = true; //压缩目录时是否使用顶层目录(默认false) sevenZipCompressor.PreserveDirectoryRoot = false; //加密7z头(默认false) sevenZipCompressor.EncryptHeaders = true; //文件加密算法 sevenZipCompressor.ZipEncryptionMethod = ZipEncryptionMethod.ZipCrypto; //尽快压缩(不会触发*Started事件,仅触发*Finished事件) sevenZipCompressor.FastCompression = false; //压缩文件 sevenZipCompressor.CompressDirectory(strDirectory, strZipPath, strPassword); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 解压缩7-ZIP文件/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strDeCompressionPath"&gt;需要解压到的指定位置&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeCompression7Zip(string strZipPath, string strDeCompressionPath)&#123; try &#123; if (string.IsNullOrEmpty(strZipPath) || !File.Exists(strZipPath)) &#123; return false; &#125; //动态链接7ZIP类库 SetLibraryPath7z(); //创建目录 if (!Directory.Exists(strDeCompressionPath)) &#123; Directory.CreateDirectory(strDeCompressionPath); &#125; //解压数据 SevenZipExtractor sevenZipExtractor = new SevenZipExtractor(strZipPath); foreach (ArchiveFileInfo itemArchiveFileInfo in sevenZipExtractor.ArchiveFileData) &#123; sevenZipExtractor.ExtractFiles(strDeCompressionPath, itemArchiveFileInfo.Index); &#125; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 解压缩7-ZIP文件(加密)/// &lt;/summary&gt;/// &lt;param name="strZipPath"&gt;ZIP压缩文件保存位置&lt;/param&gt;/// &lt;param name="strDeCompressionPath"&gt;需要解压到的指定位置&lt;/param&gt;/// &lt;param name="strPassword"&gt;压缩文件密码&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeCompression7Zip(string strZipPath, string strDeCompressionPath, string strPassword)&#123; try &#123; if (string.IsNullOrEmpty(strZipPath) || !File.Exists(strZipPath)) &#123; return false; &#125; //动态链接7ZIP类库 SetLibraryPath7z(); //创建目录 if (!Directory.Exists(strDeCompressionPath)) &#123; Directory.CreateDirectory(strDeCompressionPath); &#125; //解压数据 SevenZipExtractor sevenZipExtractor = new SevenZipExtractor(strZipPath, strPassword); foreach (ArchiveFileInfo itemArchiveFileInfo in sevenZipExtractor.ArchiveFileData) &#123; sevenZipExtractor.ExtractFiles(strDeCompressionPath, itemArchiveFileInfo.Index); &#125; return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125; GZIP：GZIPHelper 引用 System.IO.Compression.GZipStream 库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/// &lt;summary&gt;/// 压缩GZIP数据/// &lt;/summary&gt;/// &lt;param name="bytesSourceData"&gt;源数据&lt;/param&gt;/// &lt;returns&gt;压缩数据&lt;/returns&gt;public static byte[] CompressionGZIP(byte[] bytesSourceData)&#123; try &#123; MemoryStream memoryStream = new MemoryStream(); GZipStream compressedzipStream = new GZipStream(memoryStream, CompressionMode.Compress, true); compressedzipStream.Write(bytesSourceData, 0, bytesSourceData.Length); compressedzipStream.Close(); return memoryStream.ToArray(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 解压缩GZIP数据/// &lt;/summary&gt;/// &lt;param name="bytesSourceData"&gt;源数据&lt;/param&gt;/// &lt;returns&gt;解压缩数据&lt;/returns&gt;public static byte[] DeCompressionGZIP(byte[] bytesSourceData)&#123; try &#123; MemoryStream memoryStream = new MemoryStream(bytesSourceData); GZipStream compressedzipStream = new GZipStream(memoryStream, CompressionMode.Decompress); MemoryStream outBuffer = new MemoryStream(); byte[] block = new byte[1024]; while (true) &#123; int bytesRead = compressedzipStream.Read(block, 0, block.Length); if (bytesRead &lt;= 0) break; else outBuffer.Write(block, 0, bytesRead); &#125; compressedzipStream.Close(); return outBuffer.ToArray(); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 压缩String类型GZIP数据/// &lt;/summary&gt;/// &lt;param name="strSourceData"&gt;源数据&lt;/param&gt;/// &lt;returns&gt;压缩数据(Base64)&lt;/returns&gt;public static string CompressionStringGZIP(string strSourceData)&#123; try &#123; if (!string.IsNullOrEmpty(strSourceData)) &#123; byte[] rawData = Encoding.UTF8.GetBytes(strSourceData); byte[] zippedData = CompressionGZIP(rawData); return Convert.ToBase64String(zippedData); &#125; else &#123; return string.Empty; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;/// &lt;summary&gt;/// 解压缩String类型GZIP数据/// &lt;/summary&gt;/// &lt;param name="strSourceData"&gt;源数据(Base64)&lt;/param&gt;/// &lt;returns&gt;解压缩数据&lt;/returns&gt;public static string DeCompressionStringGZIP(string strSourceData)&#123; try &#123; if (!string.IsNullOrEmpty(strSourceData)) &#123; byte[] zippedData = Convert.FromBase64String(strSourceData.ToString()); return Encoding.UTF8.GetString(DeCompressionGZIP(zippedData)); &#125; else &#123; return string.Empty; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return string.Empty; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>zip</tag>
        <tag>7z</tag>
        <tag>gzip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FTP 共享帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F24%2Fcsharp-FTPSharingHelper%2F</url>
    <content type="text"><![CDATA[基于 Serv-U 搭建的 FTP 帮助类 简介Serv-U 是一种被广泛运用的FTP服务器端软件。现FTP服务器还是公司企业普遍运用的文件储存方式，编写帮助类用于自动上传下载管理服务。 核心代码FTPSharingHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354/// &lt;summary&gt;/// FTP服务器URL(统一资源定位符)/// &lt;/summary&gt;public static string strFTPServerURL &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器IP地址/// &lt;/summary&gt;public static string strFTPServerIP &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器端口号/// &lt;/summary&gt;public static string strFTPServerPort &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器路径/// &lt;/summary&gt;public static string strFTPServerPath &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器用户名/// &lt;/summary&gt;public static string strFTPServerUserID &#123; get; set; &#125;/// &lt;summary&gt;/// FTP服务器用户密码/// &lt;/summary&gt;public static string strFTPServerPassword &#123; get; set; &#125;/// &lt;summary&gt; /// 实现了文件传输协议(FTP)客户端/// &lt;/summary&gt; FtpWebRequest Request = null;/// &lt;summary&gt;/// FTP连接URL/// &lt;/summary&gt;/// &lt;param name="FTPServerURL"&gt;FTP服务器URL(统一资源定位符)&lt;/param&gt;/// &lt;param name="FTPServerUserID"&gt;FTP服务器用户名&lt;/param&gt;/// &lt;param name="FTPServerPassword"&gt;FTP服务器用户密码&lt;/param&gt;public void FTPConnectionURL(string FTPServerURL, string FTPServerUserID, string FTPServerPassword)&#123; strFTPServerURL = FTPServerURL; strFTPServerUserID = FTPServerUserID; strFTPServerPassword = FTPServerPassword;&#125;/// &lt;summary&gt;/// FTP连接URL/// &lt;/summary&gt;/// &lt;param name="FTPServerIP"&gt;FTP服务器IP地址&lt;/param&gt;/// &lt;param name="FTPServerPort"&gt;FTP服务器端口号&lt;/param&gt;/// &lt;param name="FTPServerPath"&gt;FTP服务器路径&lt;/param&gt;/// &lt;param name="FTPServerUserID"&gt;FTP服务器用户名&lt;/param&gt;/// &lt;param name="FTPServerPassword"&gt;FTP服务器用户密码&lt;/param&gt;public void FTPConnectionURL(string FTPServerIP, string FTPServerPort, string FTPServerPath, string FTPServerUserID, string FTPServerPassword)&#123; strFTPServerIP = FTPServerIP; strFTPServerPort = FTPServerPort; strFTPServerPath = FTPServerPath; strFTPServerUserID = FTPServerUserID; strFTPServerPassword = FTPServerPassword; strFTPServerURL = "ftp://" + strFTPServerIP + ":" + strFTPServerPort + "/" + strFTPServerPath + "/";&#125;/// &lt;summary&gt;/// 获得URL路径下文件列表/// &lt;/summary&gt;/// &lt;returns&gt;文件列表List&lt;/returns&gt;public List&lt;string&gt; GetFilesDetailList()&#123; try &#123; List&lt;string&gt; listAllFiles = new List&lt;string&gt;(); Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.ListDirectoryDetails; WebResponse Response = Request.GetResponse(); StreamReader Reader = new StreamReader(Response.GetResponseStream()); string strLine = Reader.ReadLine(); while (strLine != null) &#123; if (AnalysisLISTCommand(strLine).FileType == "-") &#123; listAllFiles.Add(AnalysisLISTCommand(strLine).FileName); &#125; strLine = Reader.ReadLine(); &#125; Reader.Close(); Response.Close(); return listAllFiles; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 获得URL路径下文件夹列表/// &lt;/summary&gt;/// &lt;returns&gt;文件列表List&lt;/returns&gt;public List&lt;string&gt; GetFoldersDetailList()&#123; try &#123; List&lt;string&gt; listAllFiles = new List&lt;string&gt;(); Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.ListDirectoryDetails; WebResponse Response = Request.GetResponse(); StreamReader Reader = new StreamReader(Response.GetResponseStream()); string strLine = Reader.ReadLine(); while (strLine != null) &#123; if (AnalysisLISTCommand(strLine).FileType == "d") &#123; listAllFiles.Add(AnalysisLISTCommand(strLine).FileName); &#125; strLine = Reader.ReadLine(); &#125; Reader.Close(); Response.Close(); return listAllFiles; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 获得指定URL路径下指定文件属性/// &lt;/summary&gt;/// &lt;param name="strFileName"&gt;URL中指定文件名&lt;/param&gt;/// &lt;returns&gt;FTP-FTP-LIST命令返回参数数据模型,失败返回NULL&lt;/returns&gt;public FTPListTypeModel GetFolderOrFileType(string strFileName)&#123; try &#123; FtpWebRequest fRequest = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFileName)); fRequest.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); fRequest.Method = WebRequestMethods.Ftp.ListDirectoryDetails; FtpWebResponse Response = (FtpWebResponse)fRequest.GetResponse(); Stream ftpStream = Response.GetResponseStream(); StreamReader Reader = new StreamReader(ftpStream); string strLine = Reader.ReadLine(); Reader.Close(); Response.Close(); return AnalysisLISTCommand(strLine); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 新建URL路径下文件夹/// &lt;/summary&gt;/// &lt;param name="strFolderName"&gt;文件夹名称&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool CreateFolder(string strFolderName)&#123; try &#123; Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFolderName)); Request.Method = WebRequestMethods.Ftp.MakeDirectory; Request.UseBinary = true; Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); FtpWebResponse response = (FtpWebResponse)Request.GetResponse(); Stream ftpStream = response.GetResponseStream(); ftpStream.Close(); response.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除URL路径下指定文件/// &lt;/summary&gt;/// &lt;param name="strFileName"&gt;URL中指定文件名&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool DeleteFile(string strFileName)&#123; try &#123; Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFileName)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.DeleteFile; Request.KeepAlive = false; FtpWebResponse Response = (FtpWebResponse)Request.GetResponse(); Stream ftpStream = Response.GetResponseStream(); ftpStream.Close(); Response.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除URL路径下指定文件夹/// &lt;/summary&gt;/// &lt;param name="strFolderName"&gt;文件夹名&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool DeleteFolder(string strFolderName)&#123; try &#123; Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFolderName)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.RemoveDirectory; Request.KeepAlive = false; FtpWebResponse Response = (FtpWebResponse)Request.GetResponse(); Stream ftpStream = Response.GetResponseStream(); ftpStream.Close(); Response.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 上传文件到指定URL路径/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;需要上传的文件路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool UploadFile(string strFilePath)&#123; try &#123; FileInfo fileInfo = new FileInfo(strFilePath); Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + fileInfo.Name)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.UploadFile; Request.KeepAlive = false; Request.UseBinary = true; Request.ContentLength = fileInfo.Length; int buffLength = 2048; byte[] buff = new byte[buffLength]; int contentLen; FileStream fileFtpStream = fileInfo.OpenRead(); Stream ftpStream = Request.GetRequestStream(); contentLen = fileFtpStream.Read(buff, 0, buffLength); while (contentLen != 0) &#123; ftpStream.Write(buff, 0, contentLen); contentLen = fileFtpStream.Read(buff, 0, buffLength); &#125; ftpStream.Close(); fileFtpStream.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 下载指定URL中的文件到指定路径/// &lt;/summary&gt;/// &lt;param name="strFilePath"&gt;文件下载到的路径&lt;/param&gt;/// &lt;param name="strFileName"&gt;URL中指定文件名&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public bool DownloadFile(string strFilePath, string strFileName)&#123; try &#123; if (!Directory.Exists(strFilePath)) &#123; Directory.CreateDirectory(strFilePath); &#125; FileStream fileStream = new FileStream(strFilePath + "\\" + strFileName, FileMode.Create); Request = (FtpWebRequest)FtpWebRequest.Create(new Uri(strFTPServerURL + strFileName)); Request.Credentials = new NetworkCredential(strFTPServerUserID, strFTPServerPassword); Request.Method = WebRequestMethods.Ftp.DownloadFile; Request.UseBinary = true; FtpWebResponse response = (FtpWebResponse)Request.GetResponse(); Stream ftpStream = response.GetResponseStream(); int bufferSize = 2048; int readCount; byte[] buffer = new byte[bufferSize]; readCount = ftpStream.Read(buffer, 0, bufferSize); while (readCount &gt; 0) &#123; fileStream.Write(buffer, 0, readCount); readCount = ftpStream.Read(buffer, 0, bufferSize); &#125; ftpStream.Close(); fileStream.Close(); response.Close(); return true; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 解析FTP-LIST命令/// &lt;/summary&gt;/// &lt;param name="strListCommand"&gt;FTP-LIST命令&lt;/param&gt;private FTPListTypeModel AnalysisLISTCommand(string strListCommand)&#123; FTPListTypeModel ListType = new FTPListTypeModel(); //根据空格拆分成 9 部分 string[] strListCommandSplit = strListCommand.Split(new char[] &#123; ' ', '\t' &#125;, StringSplitOptions.RemoveEmptyEntries); //文件类型 位数(1) ListType.FileType = strListCommandSplit[0].Substring(0, 1); //文件属主拥有权限 位数(2-4) ListType.UserOwnership = strListCommandSplit[0].Substring(1, 3); //文件属主同一组用户拥有权限 位数(5-7) ListType.GroupUserOwnership = strListCommandSplit[0].Substring(4, 3); //其他用户拥有权限 位数(8-10) ListType.OtherUserOwnership = strListCommandSplit[0].Substring(7, 3); //未知参数1 (1) ListType.UnknownParameter1 = strListCommandSplit[1]; //未知参数2 (user) ListType.UnknownParameter2 = strListCommandSplit[2]; //未知参数3 (group) ListType.UnknownParameter3 = strListCommandSplit[3]; //文件大小(文件夹为0) ListType.FileSize = strListCommandSplit[4]; //文件月份 ListType.FileMonth = strListCommandSplit[5]; //文件日期 ListType.FileDay = strListCommandSplit[6]; //文件年份或时间 ListType.FileYearOrTime = strListCommandSplit[7]; //文件名称 ListType.FileName = strListCommandSplit[8]; return ListType;&#125; 应用一个同学的需求：公司是做三维模型模具的，领导要求每个人每次修改上传至FTP，然后领导每天会定时完整下载（虽然我也不理解为什么他们不用SVN或者GIT，需求是什么样的就做成什么样嘛！）。功能需求是制作一个控制台程序，通过任务计划中每天下班定时执行即可。FTP参数调用本地INI配置文件。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859static void Main(string[] args)&#123; string strPath = System.AppDomain.CurrentDomain.SetupInformation.ApplicationBase + "Config.ini"; string strFTP = INIHelper.INIGetStringValue(strPath, "System", "FTP", ""); string strUser = INIHelper.INIGetStringValue(strPath, "System", "User", ""); string strPassword = INIHelper.INIGetStringValue(strPath, "System", "Password", ""); string strSavePath = INIHelper.INIGetStringValue(strPath, "System", "SavePath", ""); FTPSharingHelper ftp = new FTPSharingHelper(); ftp.FTPConnectionURL(strFTP, strUser, strPassword); DownloadFile(ftp, strFTP, strUser, strPassword, strSavePath);&#125;/// &lt;summary&gt;/// 下载目录所有文件/// &lt;/summary&gt;/// &lt;param name="ftp"&gt;FTP链接&lt;/param&gt;/// &lt;param name="strFTP"&gt;链接地址&lt;/param&gt;/// &lt;param name="strUser"&gt;用户名&lt;/param&gt;/// &lt;param name="strPassword"&gt;密码&lt;/param&gt;/// &lt;param name="strSavePath"&gt;保存路径&lt;/param&gt;public static void DownloadFile(FTPSharingHelper ftp, string strFTP, string strUser, string strPassword, string strSavePath)&#123; try &#123; ftp.FTPConnectionURL(strFTP, strUser, strPassword); //下载当前目录文件 List&lt;string&gt; list1 = ftp.GetFilesDetailList(); if (list1 != null) &#123; foreach (var item in list1) &#123; ftp.DownloadFile(strSavePath, item); &#125; &#125; //下载文件夹文件 List&lt;string&gt; list2 = ftp.GetFoldersDetailList(); if (list2 != null) &#123; foreach (var item in list2) &#123; if (item.Substring(0, 1).Equals(".")) &#123; continue; &#125; string strNewFTP = strFTP + item + "/"; string strNewSavePath = strSavePath + "\\" + item; if (!Directory.Exists(strNewSavePath)) &#123; Directory.CreateDirectory(strNewSavePath); &#125; DownloadFile(ftp, strNewFTP, strUser, strPassword, strNewSavePath); &#125; &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>ftp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件共享帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F23%2Fcsharp-FileSharingHelper%2F</url>
    <content type="text"><![CDATA[基于 Win32 API 与 CMD 命令制作可视化文件共享工具 简介不论是工作使用或是平时经常会出现两台电脑网线直连拷贝文件的情况（通过外网传输速度会受带宽限制，飞秋这种局域网聊天软件需要两台电脑同时安装，硬件存储设备需要拷贝两次，Ftp需要搭建环境，所以大部分情况下文件共享还是最好的解决方案），但是就像我这种对系统比较熟悉的人，每次操作也要找一会，与其记住命令不如做出一个可视化界面。 核心代码FileSharingHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/// &lt;summary&gt;/// 读取共享文件信息/// &lt;/summary&gt;/// &lt;returns&gt;共享信息DataTable('name':'共享文件名称','path':'共享文件路径','permissions':'访问控制权限','type':'共享文件属性')&lt;/returns&gt;public static DataTable InquireShareFile()&#123; try &#123; ManagementObjectSearcher searcher = new ManagementObjectSearcher("select * from win32_share"); DataTable ShareFile = new DataTable(); ShareFile.Columns.Add("name"); ShareFile.Columns.Add("path"); ShareFile.Columns.Add("permissions"); ShareFile.Columns.Add("type"); foreach (ManagementObject share in searcher.Get()) &#123; try &#123; //获取共享文件信息 string name = share["Name"].ToString(); string path = share["Path"].ToString(); string type = share["Type"].ToString(); if (type == "0") &#123; type = "磁盘驱动器"; &#125; else if (type == "1") &#123; type = "打印队列"; &#125; else if (type == "2") &#123; type = "设备"; &#125; else if (type == "3") &#123; type = "IPC"; &#125; else if (type == "2147483648") &#123; type = "磁盘驱动器管理"; &#125; else if (type == "2147483649") &#123; type = "打印队列管理"; &#125; else if (type == "2147483650") &#123; type = "设备管理"; &#125; else if (type == "2147483651") &#123; type = "IPC 管理员"; &#125; //获得共享文件访问权限(通过cmd搜索) string Permissions = ""; string cmd = string.Format("net share &#123;0&#125;", name); string strOutput = ImplementationCMD(cmd); if (strOutput.IndexOf("FULL") &gt; -1) &#123; Permissions = "完全控制"; &#125; else if (strOutput.IndexOf("READ") &gt; -1) &#123; Permissions = "只读"; &#125; else if (strOutput.IndexOf("CHANGE") &gt; -1) &#123; Permissions = "读取/写入"; &#125; //数据写入DataTable DataRow dr = ShareFile.NewRow(); dr["name"] = name; dr["path"] = path; dr["permissions"] = Permissions; dr["type"] = type; ShareFile.Rows.Add(dr); &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125; &#125; return ShareFile; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;/// &lt;summary&gt;/// 新增共享/// &lt;/summary&gt;/// &lt;param name="FolderPath"&gt;共享文件路径&lt;/param&gt;/// &lt;param name="ShareName"&gt;共享文件名称&lt;/param&gt;/// &lt;param name="Permissions"&gt;访问控制权限('完全控制':'FULL','只读':'READ','读取/写入':'CHANGE')&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool AddShareFolder(string FolderPath, string ShareName, string Permissions)&#123; try &#123; //输入命令NET SHARE sharename=drive:path [/GRANT:user,[READ | CHANGE | FULL] string cmd = string.Format(@"net share &#123;0&#125;=&#123;1&#125; /grant:&#123;2&#125;,&#123;3&#125;", ShareName, FolderPath, System.Environment.UserName, Permissions); string strOutput = ImplementationCMD(cmd); return strOutput.IndexOf("共享成功") &gt; -1 ? true : false; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 新增共享/// &lt;/summary&gt;/// &lt;param name="FolderPath"&gt;共享文件路径&lt;/param&gt;/// &lt;param name="ShareName"&gt;共享文件名称&lt;/param&gt;/// &lt;param name="PermissionsType"&gt;访问控制权限(枚举)&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool AddShareFolder(string FolderPath, string ShareName, SharingPermissions.PermissionsType PermissionsType)&#123; try &#123; //输入命令NET SHARE sharename=drive:path [/GRANT:user,[READ | CHANGE | FULL] string cmd = string.Format(@"net share &#123;0&#125;=&#123;1&#125; /grant:&#123;2&#125;,&#123;3&#125;", ShareName, FolderPath, System.Environment.UserName, PermissionsType); string strOutput = ImplementationCMD(cmd); return strOutput.IndexOf("共享成功") &gt; -1 ? true : false; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 删除共享/// &lt;/summary&gt;/// &lt;param name="FolderPath"&gt;共享文件夹路径&lt;/param&gt;/// &lt;returns&gt;成功返回true,失败返回false&lt;/returns&gt;public static bool DeleteShareFolder(string FolderPath)&#123; try &#123; //输入命令NET SHARE sharename \\computername /DELETE string cmd = string.Format(@"net share &#123;0&#125; /delete /y", FolderPath); string strOutput = ImplementationCMD(cmd); return strOutput.IndexOf("已经删除") &gt; -1 ? true : false; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return false; &#125;&#125;/// &lt;summary&gt;/// 执行CMD命令/// &lt;/summary&gt;/// &lt;param name="cmd"&gt;cmd命令&lt;/param&gt;/// &lt;returns&gt;cmd窗口的输出信息&lt;/returns&gt;private static string ImplementationCMD(string cmd)&#123; try &#123; //使用cmd命令对文件共享进行操作 System.Diagnostics.Process p = new System.Diagnostics.Process(); p.StartInfo.FileName = "cmd.exe"; //是否使用操作系统shell启动 p.StartInfo.UseShellExecute = false; //接受来自调用程序的输入信息 p.StartInfo.RedirectStandardInput = true; //由调用程序获取输出信息 p.StartInfo.RedirectStandardOutput = true; //重定向标准错误输出 p.StartInfo.RedirectStandardError = true; //不显示程序窗口 p.StartInfo.CreateNoWindow = true; //启动程序 p.Start(); //执行CMD命令 p.StandardInput.WriteLine(cmd); p.StandardInput.AutoFlush = true; p.StandardInput.WriteLine("exit"); //获取cmd窗口的输出信息 string strOutput = p.StandardOutput.ReadToEnd(); p.WaitForExit();//等待程序执行完退出进程 p.Close(); return strOutput; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); return null; &#125;&#125;]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>helper</tag>
        <tag>windows</tag>
        <tag>filesharing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[INI文件帮助类]]></title>
    <url>%2Fblog%2F2017%2F05%2F10%2Fcsharp-INIHelper%2F</url>
    <content type="text"><![CDATA[操作 INI 文件帮助类 简介INI 即初始化文件，是windows的系统配置文件所采用的存储格式。也是现在软件开发最常见的配置文件。INIHelper 帮助类主要提供INI配置文件创建，节点增删改。 INI文件操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284#region INI 文本帮助类 API 声明/// &lt;summary&gt;/// 获取所有节点名称(Section)/// &lt;/summary&gt;/// &lt;param name="lpszReturnBuffer"&gt;存放节点名称的内存地址,每个节点之间用\0分隔&lt;/param&gt;/// &lt;param name="nSize"&gt;内存大小(characters)&lt;/param&gt;/// &lt;param name="lpFileName"&gt;Ini文件&lt;/param&gt;/// &lt;returns&gt;内容的实际长度,为0表示没有内容,为nSize-2表示内存大小不够&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileSectionNames(IntPtr lpszReturnBuffer, uint nSize, string lpFileName);/// &lt;summary&gt;/// 获取某个指定节点(Section)中所有KEY和Value/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称&lt;/param&gt;/// &lt;param name="lpReturnedString"&gt;返回值的内存地址,每个之间用\0分隔&lt;/param&gt;/// &lt;param name="nSize"&gt;内存大小(characters)&lt;/param&gt;/// &lt;param name="lpFileName"&gt;Ini文件&lt;/param&gt;/// &lt;returns&gt;内容的实际长度,为0表示没有内容,为nSize-2表示内存大小不够&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileSection(string lpAppName, IntPtr lpReturnedString, uint nSize, string lpFileName);/// &lt;summary&gt;/// 读取INI文件中指定的Key的值/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称.如果为null,则读取INI中所有节点名称,每个节点名称之间用\0分隔&lt;/param&gt;/// &lt;param name="lpKeyName"&gt;Key名称.如果为null,则读取INI中指定节点中的所有KEY,每个KEY之间用\0分隔&lt;/param&gt;/// &lt;param name="lpDefault"&gt;读取失败时的默认值&lt;/param&gt;/// &lt;param name="lpReturnedString"&gt;读取的内容缓冲区,读取之后,多余的地方使用\0填充&lt;/param&gt;/// &lt;param name="nSize"&gt;内容缓冲区的长度&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件名&lt;/param&gt;/// &lt;returns&gt;实际读取到的长度&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, [In, Out] char[] lpReturnedString, uint nSize, string lpFileName);/// &lt;summary&gt;/// 另一种声明方式,使用 StringBuilder 作为缓冲区类型的缺点是不能接受\0字符,会将\0及其后的字符截断,所以对于lpAppName或lpKeyName为null的情况就不适用/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称.如果为null,则读取INI中所有节点名称,每个节点名称之间用\0分隔&lt;/param&gt;/// &lt;param name="lpKeyName"&gt;Key名称.如果为null,则读取INI中指定节点中的所有KEY,每个KEY之间用\0分隔&lt;/param&gt;/// &lt;param name="lpDefault"&gt;读取失败时的默认值&lt;/param&gt;/// &lt;param name="lpReturnedString"&gt;读取的内容缓冲区,读取之后,多余的地方使用\0填充&lt;/param&gt;/// &lt;param name="nSize"&gt;内容缓冲区的长度&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件名&lt;/param&gt;/// &lt;returns&gt;实际读取到的长度&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, StringBuilder lpReturnedString, uint nSize, string lpFileName);/// &lt;summary&gt;/// 再一种声明,使用string作为缓冲区的类型同char[]/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称.如果为null,则读取INI中所有节点名称,每个节点名称之间用\0分隔&lt;/param&gt;/// &lt;param name="lpKeyName"&gt;Key名称.如果为null,则读取INI中指定节点中的所有KEY,每个KEY之间用\0分隔&lt;/param&gt;/// &lt;param name="lpDefault"&gt;读取失败时的默认值&lt;/param&gt;/// &lt;param name="lpReturnedString"&gt;读取的内容缓冲区,读取之后,多余的地方使用\0填充&lt;/param&gt;/// &lt;param name="nSize"&gt;内容缓冲区的长度&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件名&lt;/param&gt;/// &lt;returns&gt;实际读取到的长度&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern uint GetPrivateProfileString(string lpAppName, string lpKeyName, string lpDefault, string lpReturnedString, uint nSize, string lpFileName);/// &lt;summary&gt;/// 将指定的键值对写到指定的节点,如果已经存在则替换./// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点,如果不存在此节点,则创建此节点&lt;/param&gt;/// &lt;param name="lpString"&gt;Item键值对,多个用\0分隔,形如key1=value1\0key2=value2;如果为string.Empty,则删除指定节点下的所有内容,保留节点;如果为null,则删除指定节点下的所有内容,并且删除该节点&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件&lt;/param&gt;/// &lt;returns&gt;是否成功写入&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto)]private static extern bool WritePrivateProfileSection(string lpAppName, string lpString, string lpFileName);/// &lt;summary&gt;/// 将指定的键和值写到指定的节点，如果已经存在则替换/// &lt;/summary&gt;/// &lt;param name="lpAppName"&gt;节点名称&lt;/param&gt;/// &lt;param name="lpKeyName"&gt;键名称。如果为null，则删除指定的节点及其所有的项目&lt;/param&gt;/// &lt;param name="lpString"&gt;值内容。如果为null，则删除指定节点中指定的键。&lt;/param&gt;/// &lt;param name="lpFileName"&gt;INI文件&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;[DllImport("kernel32.dll", CharSet = CharSet.Auto, SetLastError = true)][return: MarshalAs(UnmanagedType.Bool)]private static extern bool WritePrivateProfileString(string lpAppName, string lpKeyName, string lpString, string lpFileName);#endregion#region INI 文本帮助类 封装方法/// &lt;summary&gt;/// 读取INI文件中指定INI文件中的所有节点名称(Section)/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;Ini文件&lt;/param&gt;/// &lt;returns&gt;所有节点,没有内容返回string[0]&lt;/returns&gt;public static string[] INIGetAllSectionNames(string iniFile)&#123; //默认为32767 uint MAX_BUFFER = 32767; //返回值 string[] sections = new string[0]; //申请内存 IntPtr pReturnedString = Marshal.AllocCoTaskMem((int)MAX_BUFFER * sizeof(char)); uint bytesReturned = GetPrivateProfileSectionNames(pReturnedString, MAX_BUFFER, iniFile); if (bytesReturned != 0) &#123; //读取指定内存的内容 string local = Marshal.PtrToStringAuto(pReturnedString, (int)bytesReturned).ToString(); //每个节点之间用\0分隔,末尾有一个\0 sections = local.Split(new char[] &#123; '\0' &#125;, StringSplitOptions.RemoveEmptyEntries); &#125; //释放内存 Marshal.FreeCoTaskMem(pReturnedString); return sections;&#125;/// &lt;summary&gt;/// 获取INI文件中指定节点(Section)中的所有条目(key=value形式)/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;Ini文件&lt;/param&gt;/// &lt;param name="section"&gt;节点名称&lt;/param&gt;/// &lt;returns&gt;指定节点中的所有项目,没有内容返回string[0]&lt;/returns&gt;public static string[] INIGetAllItems(string iniFile, string section)&#123; //返回值形式为 key=value,例如 Color=Red; uint MAX_BUFFER = 32767; string[] items = new string[0]; //分配内存 IntPtr pReturnedString = Marshal.AllocCoTaskMem((int)MAX_BUFFER * sizeof(char)); uint bytesReturned = GetPrivateProfileSection(section, pReturnedString, MAX_BUFFER, iniFile); if (!(bytesReturned == MAX_BUFFER - 2) || (bytesReturned == 0)) &#123; string returnedString = Marshal.PtrToStringAuto(pReturnedString, (int)bytesReturned); items = returnedString.Split(new char[] &#123; '\0' &#125;, StringSplitOptions.RemoveEmptyEntries); &#125; //释放内存 Marshal.FreeCoTaskMem(pReturnedString); return items;&#125;/// &lt;summary&gt;/// 获取INI文件中指定节点(Section)中的所有条目的Key列表/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;Ini文件&lt;/param&gt;/// &lt;param name="section"&gt;节点名称&lt;/param&gt;/// &lt;returns&gt;如果没有内容,反回string[0]&lt;/returns&gt;public static string[] INIGetAllItemKeys(string iniFile, string section)&#123; string[] value = new string[0]; const int SIZE = 1024 * 10; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; char[] chars = new char[SIZE]; uint bytesReturned = GetPrivateProfileString(section, null, null, chars, SIZE, iniFile); if (bytesReturned != 0) &#123; value = new string(chars).Split(new char[] &#123; '\0' &#125;, StringSplitOptions.RemoveEmptyEntries); &#125; chars = null; return value;&#125;/// &lt;summary&gt;/// 读取INI文件中指定KEY的字符串型值/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;Ini文件&lt;/param&gt;/// &lt;param name="section"&gt;节点名称&lt;/param&gt;/// &lt;param name="key"&gt;键名称&lt;/param&gt;/// &lt;param name="defaultValue"&gt;如果没此KEY所使用的默认值&lt;/param&gt;/// &lt;returns&gt;读取到的值&lt;/returns&gt;public static string INIGetStringValue(string iniFile, string section, string key, string defaultValue)&#123; string value = defaultValue; const int SIZE = 1024 * 10; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; if (string.IsNullOrEmpty(key)) &#123; throw new ArgumentException("必须指定键名称(key)", "key"); &#125; StringBuilder sb = new StringBuilder(SIZE); uint bytesReturned = GetPrivateProfileString(section, key, defaultValue, sb, SIZE, iniFile); if (bytesReturned != 0) &#123; value = sb.ToString(); &#125; sb = null; return value;&#125;/// &lt;summary&gt;/// 在INI文件中,将指定的键值对写到指定的节点,如果已经存在则替换/// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点,如果不存在此节点,则创建此节点&lt;/param&gt;/// &lt;param name="items"&gt;键值对,多个用\0分隔,形如key1=value1\0key2=value2&lt;/param&gt;/// &lt;returns&gt;&lt;/returns&gt;public static bool INIWriteItems(string iniFile, string section, string items)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; if (string.IsNullOrEmpty(items)) &#123; throw new ArgumentException("必须指定键值对", "items"); &#125; return WritePrivateProfileSection(section, items, iniFile);&#125;/// &lt;summary&gt;/// 在INI文件中,指定节点写入指定的键及值.如果已经存在,则替换.如果没有则创建./// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点&lt;/param&gt;/// &lt;param name="key"&gt;键&lt;/param&gt;/// &lt;param name="value"&gt;值&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;public static bool INIWriteValue(string iniFile, string section, string key, string value)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; if (string.IsNullOrEmpty(key)) &#123; throw new ArgumentException("必须指定键名称", "key"); &#125; if (value == null) &#123; throw new ArgumentException("值不能为null", "value"); &#125; return WritePrivateProfileString(section, key, value, iniFile);&#125;/// &lt;summary&gt;/// 在INI文件中,删除指定节点中的指定的键./// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点&lt;/param&gt;/// &lt;param name="key"&gt;键&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;public static bool INIDeleteKey(string iniFile, string section, string key)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; if (string.IsNullOrEmpty(key)) &#123; throw new ArgumentException("必须指定键名称", "key"); &#125; return WritePrivateProfileString(section, key, null, iniFile);&#125;/// &lt;summary&gt;/// 在INI文件中,删除指定的节点./// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;public static bool INIDeleteSection(string iniFile, string section)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; return WritePrivateProfileString(section, null, null, iniFile);&#125;/// &lt;summary&gt;/// 在INI文件中,删除指定节点中的所有内容./// &lt;/summary&gt;/// &lt;param name="iniFile"&gt;INI文件&lt;/param&gt;/// &lt;param name="section"&gt;节点&lt;/param&gt;/// &lt;returns&gt;操作是否成功&lt;/returns&gt;public static bool INIEmptySection(string iniFile, string section)&#123; if (string.IsNullOrEmpty(section)) &#123; throw new ArgumentException("必须指定节点名称", "section"); &#125; return WritePrivateProfileSection(section, string.Empty, iniFile);&#125;#endregion]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>ini</tag>
        <tag>helper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 在此处打开命令窗口]]></title>
    <url>%2Fblog%2F2017%2F01%2F26%2Fwindows-OpenCMDHere%2F</url>
    <content type="text"><![CDATA[Win10 鼠标右键在此处打开CMD窗口 简介Windows 10 一直想使用 Power Shell 代替原有的 CMD，功能更加强大的同时也伴随很多弊病，例如：内存占用（测试CMD占用10.9MB内存，PowerShell占用37.2MB内存）、启动和执行速度较慢（高配电脑打扰了）、蓝色的底也看起来并不怎么舒服（虽然都能改）、多按两下Backspace还滴滴滴滴滴。 解决方案主要修改地址在Win10的文件夹处Shift+鼠标右键原有的”在此处打开命令窗口(M)”被修改为”在此处打开 Powershell 窗口(S)”，通过修改注册表的方式在鼠标右键添加CMD的打开方式（当前目录）。复制以下内容到文本中存为 reg文件，双击运行添加到注册表中即可。1234567Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCMDHere]&quot;ShowBasedOnVelocityId&quot;=dword:00639bc8[HKEY_CLASSES_ROOT\Directory\Background\shell\OpenCMDHere\command]@=&quot;cmd.exe /s /k pushd \&quot;%V\&quot;&quot;]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>windows</tag>
        <tag>registry</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ADO.NET 帮助类]]></title>
    <url>%2Fblog%2F2016%2F12%2F21%2Fcsharp-ADOHelper%2F</url>
    <content type="text"><![CDATA[使用 ADO.NET 二次封装ORM框架的数据库操作帮助类 简介工作中大量需要多种不同数据格式互相转换，通过ADO.NET实现可视化数据转换工具，目前支持关系型数据库SqlServer、Oracle、MySql、Access、SQLite。 设计简易的ORM框架，多种数据库操作封装为一套帮助类中，后期使用不需要过多考虑数据库类型，以及减少在代码中拼写SQL语句。近乎通用的连接方式以及增删改查，支持事务处理。 帮助类、官方文档及其调用方式SQLServer：SqlServerHelper 引用 System.Data.SqlClient 库调用方式：1234SqlServerHelper sqlHelper = new SqlServerHelper();sqlHelper.SqlServerConnectionString(string server, string database, string uid, string pwd);sqlHelper.Open();sqlHelper.Close(); Oracle：OracleHelper 引用 System.Data.OracleClient 库调用方式：1234OracleHelper sqlHelper = new OracleHelper();sqlHelper.OracleConnectionString(string Source, string Id, string Password);sqlHelper.Open();sqlHelper.Close(); MySQL：MySqlHelper 引用 MySql.Data.MySqlClient 库调用方式：1234MySqlHelper sqlHelper = new MySqlHelper();sqlHelper.MySqlConnectionString(string server, string id, string password, string database);sqlHelper.Open();sqlHelper.Close(); Access：AccessHelper 引用 System.Data.OleDb 库调用方式：12345AccessHelper sqlHelper = new AccessHelper();sqlHelper.AccessConnectionPath_Office2003(string source);sqlHelper.AccessConnectionPath_Office2007(string source);sqlHelper.Open();sqlHelper.Close(); SQLite：SQLiteHelper 引用 System.Data.SQLite 库调用方式：1234SQLiteHelper sqlHelper = new SQLiteHelper();sqlHelper.SQLiteConnectionPath(string source);sqlHelper.Open();sqlHelper.Close(); 数据转换帮助类由于每种数据库的字段类型、字符格式长度等不一致，所以专门写了一个用于互相兼容的帮助类，用于自动识别源数据库与目标数据库差异，自动修改。数据转换帮助类 删除DataTable中的空行数据源以C#基础类型DataTable传递，在实际使用中存在空行导致异常12345678910111213141516171819202122232425262728293031323334353637/// &lt;summary&gt;/// 删除DataTable中的空行/// 弱引用,可直接修改参数/// &lt;/summary&gt;/// &lt;param name="dtDataSource"&gt;源数据(DataTable)&lt;/param&gt;/// &lt;returns&gt;删除空行后的DataTable&lt;/returns&gt;public static DataTable RemoveEmpty(DataTable dtDataSource)&#123; try &#123; List&lt;DataRow&gt; listRemove = new List&lt;DataRow&gt;(); for (int i = 0; i &lt; dtDataSource.Rows.Count; i++) &#123; bool IsNull = true; for (int j = 0; j &lt; dtDataSource.Columns.Count; j++) &#123; if (!string.IsNullOrEmpty(dtDataSource.Rows[i][j].ToString().Trim())) &#123; IsNull = false; &#125; &#125; if (IsNull) &#123; listRemove.Add(dtDataSource.Rows[i]); &#125; &#125; for (int i = 0; i &lt; listRemove.Count; i++) &#123; dtDataSource.Rows.Remove(listRemove[i]); &#125; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125; return dtDataSource;&#125; DataTable与List互相转换实际使用中List比DataTable更方便使用，提供互相转换方法方便开发123456789101112131415161718192021222324252627282930313233343536373839404142/// &lt;summary&gt;/// DataTable转换为List&lt;T&gt;/// &lt;/summary&gt;/// &lt;typeparam name="T"&gt;数据模型&lt;/typeparam&gt;/// &lt;param name="dtDataSource"&gt;源数据(DataTable)&lt;/param&gt;/// &lt;returns&gt;成功返回List&lt;T&gt;,失败返回null&lt;/returns&gt;public static List&lt;T&gt; ConvertToList&lt;T&gt;(DataTable dtDataSource) where T : class,new()&#123; try &#123; List&lt;T&gt; listT = new List&lt;T&gt;(); foreach (DataRow drDataSource in dtDataSource.Rows) &#123; T t = new T(); PropertyInfo[] propertyInfos = t.GetType().GetProperties(); foreach (PropertyInfo propertyInfo in propertyInfos) &#123; string tempName = propertyInfo.Name; if (dtDataSource.Columns.Contains(tempName)) &#123; if (!propertyInfo.CanWrite) continue; object value = drDataSource[tempName]; if (value != DBNull.Value) &#123; if (propertyInfo.GetMethod.ReturnParameter.ParameterType.Name == "Int32") &#123; value = Convert.ToInt32(value); &#125; propertyInfo.SetValue(t, value, null); &#125; &#125; &#125; listT.Add(t); &#125; return listT; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125; return null;&#125; 1234567891011121314151617181920212223242526272829303132333435/// &lt;summary&gt;/// List&lt;T&gt;转换为DataTable/// &lt;/summary&gt;/// &lt;param name="listDataSource"&gt;源数据&lt;/param&gt;/// &lt;returns&gt;成功返回DataTable,失败返回null&lt;/returns&gt;public static DataTable ConvertDataTable(IList listDataSource)&#123; try &#123; DataTable dataTable = new DataTable(); if (listDataSource.Count &gt; 0) &#123; PropertyInfo[] propertyInfos = listDataSource[0].GetType().GetProperties(); foreach (PropertyInfo propertyInfo in propertyInfos) &#123; dataTable.Columns.Add(propertyInfo.Name, propertyInfo.PropertyType); &#125; foreach (var vDataSource in listDataSource) &#123; ArrayList arrayList = new ArrayList(); foreach (PropertyInfo propertyInfo in propertyInfos) &#123; arrayList.Add(propertyInfo.GetValue(vDataSource, null)); &#125; dataTable.LoadDataRow(arrayList.ToArray(), true); &#125; &#125; return dataTable; &#125; catch (Exception ex) &#123; TXTHelper.Logs(ex.ToString()); &#125; return null;&#125; String转Unicode,并去除’\ufeff’非法字符个别数据中存在有非法字符，避免异常，转换时批量处理1234567891011121314151617181920212223242526272829303132333435363738/// &lt;summary&gt;/// 去除非法字符'\\ufeff'/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;数据源&lt;/param&gt;/// &lt;returns&gt;修正后的字符&lt;/returns&gt;public static string RemoveIllegal(string strSource)&#123; return UnicodeToString(StringToUnicode(strSource));&#125;/// &lt;summary&gt;/// String转Unicode,并去除'\\ufeff'非法字符/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;数据源&lt;/param&gt;/// &lt;returns&gt;Unicode编码字符&lt;/returns&gt;public static string StringToUnicode(string strSource)&#123; StringBuilder stringBuilder = new StringBuilder(); //先把字符串转换成 UTF-16 的Btye数组 byte[] bytes = Encoding.Unicode.GetBytes(strSource); for (int i = 0; i &lt; bytes.Length; i += 2) &#123; //根据Unicode规则，每两个byte表示一个汉字，并且后前顺序，英文前面补00 stringBuilder.AppendFormat("\\u&#123;0&#125;&#123;1&#125;", bytes[i + 1].ToString("x").PadLeft(2, '0'), bytes[i].ToString("x").PadLeft(2, '0')); &#125; //去掉'?'的Unicode码,?=003f,Unicode以\u开头,\\为转义\ return stringBuilder.Replace("\\ufeff", string.Empty).ToString();&#125;/// &lt;summary&gt;/// Unicode转String/// &lt;/summary&gt;/// &lt;param name="strSource"&gt;数据源&lt;/param&gt;/// &lt;returns&gt;String类型编码字符&lt;/returns&gt;public static string UnicodeToString(string strSource)&#123; return new Regex(@"\\u([0-9A-F]&#123;4&#125;)", RegexOptions.IgnoreCase | RegexOptions.Compiled).Replace(strSource, x =&gt; string.Empty + Convert.ToChar(Convert.ToUInt16(x.Result("$1"), 16)));&#125; 字段类型转换由于每种数据库字段类型及字段长度和主键不一致，根据每种目标数据库做单独修改代码过长，请查阅目录下方法 TypeProcessing]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>mysql</tag>
        <tag>helper</tag>
        <tag>sqlite</tag>
        <tag>ado.net</tag>
        <tag>sql server</tag>
        <tag>oracle</tag>
        <tag>access</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C/S端开发基础框架]]></title>
    <url>%2Fblog%2F2016%2F12%2F20%2Fcsharp-DevFramework%2F</url>
    <content type="text"><![CDATA[基于 Wpf + Prism + DevExpress 制作的插件式开发基础框架 工作已经临近半年了，日常在工作中有所积累，打算写一套自己的帮助类，后逐步发展为一个桌面端快速开发的框架。使用 Wpf + Prism + DevExpress 作为基础，Ribbon样式的插件式开发方式。同时又基于帮助类实现了几个简单的功能，后续再博客中会逐步记录帮助类。 注册工具获取计算机硬件信息（网卡MAC地址、CPU-ID、硬盘序列号、内存序列号、主板序列号、BIOS序列号、显卡信息），拼接加密生成唯一序列号，可用于软件激活使用。详细请查阅：电脑硬件信息帮助类 生成二维码基于 ZXing.QrCode 库制作的横条码、二维码生成工具，可添加LOGO，也可动态识别横条码、二维码。详细请查阅：二维码帮助类 加密解密工具提供几种对称密钥加密与非对称加密算法，以及哈希算法，也可以加密文件夹。详细请查阅：加密解密帮助类 文件共享通过调用Windows API接口实现文件共享可视化操作（需管理员权限）。详细请查阅：文件共享帮助类 数据库转换工具工作中大量需要多种不同数据格式互相转换，通过ADO.NET实现可视化数据转换工具，目前支持关系型数据库SqlServer、Oracle、MySql、Access、SQLite。详细请查阅：ADO.NET 帮助类]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>wpf</tag>
        <tag>helper</tag>
        <tag>devexpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令启动程序]]></title>
    <url>%2Fblog%2F2016%2F08%2F10%2Fwindows-QueryCmd%2F</url>
    <content type="text"><![CDATA[通过运行或CMD命令启动软件 简介作为一个强迫症来说，电脑桌面当然是越精简越好，杂乱的文件不能有，甚至想干掉所有图标…Windows的强大足以完全用快捷键操作系统了，鼠标用得少了效率也提高不少。之前有想过用 Mac OS 的 Dock 的工具栏样式显示软件图标，但是没有MAC总觉得少点什么。通过 运行（Win+R） 的方式启动软件或许是个不错的方式，系统有集成很多自带的软件或者安装打包有环境变量的软件都可以输入名称运行（例如：calc、notepad、mspaint、mstsc）。 设置创建启动目录，存放想要启动的快捷图标，修改快捷方式启动的名称 配置环境变量（在环境变量Path下增加启动目录）Win7 Win10 通过 Win+R 打开运行窗口，输入启动名称即可。例：运行PS 2019年7月16日补充记录一个更好的替代或是搭配使用的工具Wox：官方网站（An effective launcher for windows）GitHub：https://github.com/Wox-launcher/Wox]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>cmd</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑挂机锁]]></title>
    <url>%2Fblog%2F2016%2F05%2F31%2Fcsharp-DesktopLock%2F</url>
    <content type="text"><![CDATA[初学C#开发，Windows平台电脑挂机锁 项目介绍：大学临毕业前想要做出点成品，漂洋过海跑到北京作为面试的资本。没有什么好点子，是一个同学的主意，本着学习的目的，还是比较实用的功能（没人会用的…）就做这个了。曾经一度认为只有桌面端软件才叫软件，奈何学校教学只有基础的语法还有偏向于WEB开发，有试过用java的awt和swing设计图形化界面，但是效果并不是很理想，后来有了解到微软平台MFC、QT、Winform,但是界面的画风显得很古老，使用异形窗体后会有很严重的锯齿，最后选用WPF作为主界面。项目开源地址：https://github.com/Sadness96/DesktopLock贴吧发布地址：http://tieba.baidu.com/p/4584097900项目虽然简单，BUG还有很多，甚至不如Windows自带的Win+L锁屏好使，但是经过几天的边学边做，真的给我明确了未来的方向。 设置菜单界面可通过三种方式设置挂机锁，1.密码解锁；2.时间解锁（根据系统当前时间拼接作为密码）；3.U盘解锁（通过写入加密数据到U盘，插入U盘时即可解锁）； 修改锁屏壁纸默认三种锁屏图片可选或自定义图片。 定时锁屏关机界面可定时多长时间后锁屏或关机。 USB写入密码插入U盘后写入加密秘钥，可通过设置U盘解锁方式，在插入U盘后系统自动解锁。 关于 锁屏可调节透明度，挂机时显示桌面运行的程序。]]></content>
      <categories>
        <category>C#.Net</category>
      </categories>
      <tags>
        <tag>c#</tag>
        <tag>wpf</tag>
        <tag>ini</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈尔滨信息工程学院]]></title>
    <url>%2Fblog%2F2016%2F05%2F10%2Fschool-University%2F</url>
    <content type="text"><![CDATA[选择不同，命运自然不同我不喜欢这个学校，因为在我来这之前，就已经发生了很多让人厌恶的故事。但是我还是来了，人生总要伴随着痛苦嘛。接受了，就是成长。但是我也很感谢这里，让我拥有两年的时间，得到足够成长，一切都按照计划进行着，下一步…等发生了再去记录吧！ 记录做过的成品，真正成长的开始：c（企业员工信息管理系统）使用C语言编写简易的控制台管理程序，实训有录像剪辑视频（使用会声会影）。由于涉及到她人肖像问题，不方便发布，感兴趣可以单独联系博主。插曲：制作视频的时候很赶工，几个小女生视频录一半着急忙慌就回家放假了，我带着朋友跑网吧通宵剪辑视频，他玩着联盟看我剪了一宿…然后在最后渲染的时候已经凌晨五点了，非常幸运的死机了，我凭着记忆快速重启电脑，安装好软件后重新剪辑，在通宵下机之前完成了。 java（学生成绩管理系统）使用Java的awt和swing设计开发C/S端程序，使用SQL Server数据库管理，exe4j打包为exe程序。]]></content>
      <categories>
        <category>School</category>
      </categories>
      <tags>
        <tag>c</tag>
        <tag>java</tag>
        <tag>会声会影</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[齐齐哈尔职业教育中心学校]]></title>
    <url>%2Fblog%2F2014%2F10%2F05%2Fschool-HighSchool%2F</url>
    <content type="text"><![CDATA[曾经不被人认可的小孩，自己选择了职高我在入学的第一天，校门前的滚动屏写着：“恭喜XXX同学考入天津大学，欢迎来到职业教育中心学校，不走高考独木桥。”在很多人眼里职高或技校很乱，学习不好的人考不到高中的人才会去这里学一门手艺。对！也不对！在这里，我认识的大部分人没有一个安逸的家，每个人在这里都在为自己的未来打拼。职高真的就不如普通的高中么？（过多个人言论，博主眼界有限，并不符合所有人情况）初中临近毕业的时候，我和一个好朋友选择了去职高，而另外几个同学被家里强制安排在普通高中里，我为了所谓的理想选择计算机专业（在2011年的时候很盛行说网瘾少年）我的好朋友选择了学汽修，几年过去了，高考终究又是一个坎，普通高中的同学们毕业选了专科或是三本，专业嘛，汽修、模具制造等等等…然而我和我的好朋友已经学了这个专业三年，我们跟去学汽修的同学说发动机原理，他听不懂。我跟模具制造的同学说AutoCAD他听不懂…大学终究要选择一个专业方向，普通高中真的会更好么？如果以上说的是一些学习较差的朋友，博主还有认识学习非常好考到重点高中的朋友，在临高考时迷茫了，似乎上学只是为了应付考试，不知道自己的定位，不知道应该考什么专业，有人通过我的建议找到了自己的目标，而有些人也盲目的听从了家里的安排。希望所有迷茫的人，终究能找到属于自己的位置。 在此记录曾经做过的，即是幼稚的回忆，又代表了成长：photoshop flash移动端浏览器和部分浏览器已不支持Flash播放访问速度慢或网页不兼容可能导致无法访问，可单独下载储存地址：https://github.com/Sadness96/sadness96.github.io/tree/master/flash/memory-HighSchool]]></content>
      <categories>
        <category>School</category>
      </categories>
      <tags>
        <tag>photoshop</tag>
        <tag>flash</tag>
      </tags>
  </entry>
</search>
